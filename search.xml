<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/10/25/BubbleSort/</url>
    <content><![CDATA[<p>冒泡排序（英语：Bubble Sort）又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误&gt;就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”&gt;到数列的顶端。</p>
<a id="more"></a>


<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>依次比较两个相邻的元素，如果它们顺序错误，则交换，最终大数会沉向尾部。重复上面的步骤知道数组有序，下面以正序为例进行详细说明整个过程。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[9] [8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>第一步：比较<font color="red">[9]</font>和<font color="red">[8]</font>，由于<font color="red">[9]</font>大于<font color="red">[8]</font>，按照正序逻辑<font color="red">[9]</font>在后面，因此需要交换它们的位置，得到新的数组如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[8] [9] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>第二步：比较比较<font color="red">[9]</font>和<font color="red">[7]</font>，同理需要交换它们的位置，得到新的数组如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[8] [7] [9] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>依次比较原理同上，直到最后一组元素相邻元素比较之后，我们可以得到第一轮冒泡之后的结果，如下所示，可以很明显看到元素<font color="red">[9]</font>最终沉到了尾部，因为它是正序里面最大的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[8] [7] [1] [3] [5] [9]</span><br></pre></td></tr></table></figure>

<p>同理我们进行第二轮冒泡，会将<font color="red">[8]</font>沉到元素尾部，得到如下结果，这里需要注意，由于第一轮冒泡，已经把最大的元素<font color="red">[9]</font>放到了最后一个位置，第二轮冒泡则无需和<font color="red">[9]</font>进行比较，就可以把<font color="red">[8]</font>放到倒数第二的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[7] [1] [3] [5] [8] [9]</span><br></pre></td></tr></table></figure>

<p>最终在经过了n-1轮冒泡之后（n为元素个数），我们可以最终得到一个有序的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9]</span><br></pre></td></tr></table></figure>



<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>冒泡排序是稳定的排序算法，其时间复杂度计算公式如下。可以看到冒泡排序，最好的情况与最坏的情况下，时间复杂度均为2^n，空间复杂度为1，平均时间复杂度为2^n。</p>
</blockquote>
<p>$$<br>(n-1) + (n-2) + (n-3) + … + 1 = ((n-1) + 1) * (n-1) / 2 = \frac{n * (n-1)}{2}<br>$$</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>less函数与exch函数参见文章排序算法序言。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(less(c[j+<span class="number">1</span>], c[j]))&#123;</span><br><span class="line">                exch(c, j, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>冒泡排序</tag>
        <tag>数据结构与算法</tag>
        <tag>稳定排序</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/10/28/HillSort/</url>
    <content><![CDATA[<p>希尔排序（Shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。根据设计者希尔（Donald Shell）的名字命名，该算法由1959年公布。</p>
<a id="more"></a>


<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>假定步长为h，则把数组分为h组，从前往后间隔h的元素为一组。先在组内进行插入排序，保证每个组内是有序的，再按照步长为1进行一次全面插入排序，从而得到有序数组。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9] [8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>第一步，假设h为<code>3</code>，则根据规则原数组分为如下三组</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9] [1]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[8] [3]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [5]</span><br></pre></td></tr></table></figure>

<p>第二步，在三个小组内，分别进行插入排序，得到三个有序子数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [8]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[5] [7]</span><br></pre></td></tr></table></figure>

<p>第三步，三个子数组按照原来的位置存放，得到第一轮排序后的数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [9] [8] [7]</span><br></pre></td></tr></table></figure>

<p>第四步，按照步长为<code>[1]</code>进行一次插入排序，即可得到有序数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9]</span><br></pre></td></tr></table></figure>



<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>希尔排序是一个不稳定的排序算法，其最好情况下时间复杂度为<code>O(n)</code>，最坏情况下时间复杂度为<code>2^n</code>，平均时间复杂度为<code>2^n</code>，空间复杂度为<code>O(!)</code>。时间复杂度计算公式如下。</p>
</blockquote>
<p>$$<br>待补充<br>$$</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Shell</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &lt; N / <span class="number">3</span>)&#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(c[j], c[j-h]); j -= h)&#123;</span><br><span class="line">                exch(c, j, j-h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>希尔排序</tag>
        <tag>不稳定排序</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2020/10/25/InsertSort/</url>
    <content><![CDATA[<p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐&gt;步向后挪位，为最新元素提供插入空间。</p>
<a id="more"></a>

<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>每次从剩余的未排序的元素中选取一个元素插入到前面已排序的元素中，使整体有序。下面以正序为例说明整个过程。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[9] [8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>第一步：选择<font color="red">[9]</font>插入到前面已排序的元素中，由于是第一个元素，已经排序好了。可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9] [8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>未排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>已排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9]</span><br></pre></td></tr></table></figure>

<p>第二步：选择<font color="red">[8]</font>插入到前面已排序的元素中，<font color="red">[8]</font>比<font color="red">[9]</font>小，因此在<font color="red">[9]</font>前面，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[8] [9] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>未排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>已排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[8] [9]</span><br></pre></td></tr></table></figure>

<p>第三步：选择<font color="red">[7]</font>插入到前面已排序的元素中，<font color="red">[7]</font>比<font color="red">[8]</font>小，因此在<font color="red">[8]</font>前面，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [8] [9] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>未排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>已排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [8] [9]</span><br></pre></td></tr></table></figure>

<p>第四步：选择<font color="red">[1]</font>插入到前面已排序的元素中，<font color="red">[1]</font>比<font color="red">[7]</font>小，因此在<font color="red">[7]</font>前面，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [7] [8] [9] [3] [5]</span><br></pre></td></tr></table></figure>

<p>未排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [5]</span><br></pre></td></tr></table></figure>

<p>已排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [7] [8] [9]</span><br></pre></td></tr></table></figure>

<p>第五步：选择<font color="red">[3]</font>插入到前面已排序的元素中，<font color="red">[3]</font>小于<font color="red">[7]</font>大于<font color="red">[1]</font>，因此<font color="red">[3]</font>在<font color="red">[1]</font>和<font color="red">[7]</font>之间，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [7] [8] [9] [5]</span><br></pre></td></tr></table></figure>

<p>未排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[5]</span><br></pre></td></tr></table></figure>

<p>已排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [7] [8] [9]</span><br></pre></td></tr></table></figure>

<p>第六步：同理插入<font color="red">[5]</font>，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9]</span><br></pre></td></tr></table></figure>

<p>未排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>已排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9]</span><br></pre></td></tr></table></figure>

<p>最终得到一个正序数组。</p>
<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>插入排序是稳定的排序算法，其时间复杂度计算公式如下。可以看到插入排序最好的情况时间复杂度为n，最坏的情况下时间复杂度均为2^n，空间复杂度为O(1)，平均时间复杂度为2^n。</p>
</blockquote>
<p>$$<br>k1 + k2 + k3 + k4 + … kn = \sum_{k=1}^{n}{k_n} (1 &lt;= k1,k2,…,kn &lt;= n-1)<br>$$</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(c[j], c[j-<span class="number">1</span>]); j--)&#123;</span><br><span class="line">            exch(c, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>稳定排序</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/10/26/QuickSort/</url>
    <content><![CDATA[<p>快速排序（英语：Quicksort），又称分区交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。通常明显比其&gt;他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。</p>
<a id="more"></a>


<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>是一种分治的思想。它将一个数组分成两个子数组，两部分独立的排序。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[5] [8] [9] [7] [1] [3] [9]</span><br></pre></td></tr></table></figure>

<p>假定第一个元素<font color="red">[5]</font>为哨兵，标记哨兵为x，使用临时变量<code>temp</code>存放哨兵的值，则原数据如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[x] [8] [9] [7] [1] [3] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [5]</span><br><span class="line">left = 1</span><br><span class="line">right = 6</span><br></pre></td></tr></table></figure>

<p>第一步：，从数组尾部开始扫描，如果当前元素<code>c[right]</code>大于哨兵的值，则索引<code>right</code>减1，继续扫描，如果当前元素<code>c[right]</code>小于哨兵的值，则交换哨兵与当前元素的值。因为<font color="red">[3]</font>小于<font color="red">[9]</font>，因此交换<font color="red">[3]</font>和哨兵<font color="red">[x]</font>，得到如下结果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [8] [9] [7] [1] [x] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [5]</span><br><span class="line">left = 1</span><br><span class="line">right = 5</span><br></pre></td></tr></table></figure>

<p>第二步，从数组头部开始扫描，如果当前元素<code>c[left]</code>小于哨兵的值，则索引<code>left</code>加1，继续扫描，如果当前元素<code>c[left]</code>大于哨兵的值，则交换哨兵与当前元素的值。因为<font color="red">[8]</font>大于<font color="red">[5]</font>，因此交换<font color="red">[8]</font>和哨兵<font color="red">[x]</font>，得到如下结果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [x] [9] [7] [1] [8] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [9]</span><br><span class="line">left = 1</span><br><span class="line">right = 5</span><br></pre></td></tr></table></figure>

<p>第三步，继续从<code>right-1</code>处继续扫描，重复步骤一，得到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [1] [9] [7] [x] [8] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [9]</span><br><span class="line">left = 1</span><br><span class="line">right = 4</span><br></pre></td></tr></table></figure>

<p>第四步，继续从<code>left+1</code>处继续扫描，重复步骤二，得到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [1] [x] [7] [9] [8] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [9]</span><br><span class="line">left = 2</span><br><span class="line">right = 4</span><br></pre></td></tr></table></figure>

<p>一直重复上面的步骤直到，<code>left</code>大于等于<code>right</code>结束扫描，最后把临时变量temp的值存入<font color="red">[x]</font>处，第一轮快速排序结束。可以得到第一轮结果如下，可以很明显看到小于<font color="red">[5]</font>的值全在左边，大于<font color="red">[5]</font>的值全在右边。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [1] [5] [7] [9] [8] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [9]</span><br><span class="line">left = 2</span><br><span class="line">right = 2</span><br></pre></td></tr></table></figure>


<p>第二轮，把第一轮的结果看成如下两个数组，对每个数组，重复第一轮的排序方法，直到左右数组均有序。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [1]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [9] [8] [9]</span><br></pre></td></tr></table></figure>

<p>最终可以得到有序数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9] [9]</span><br></pre></td></tr></table></figure>



<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>快速排序是不稳定的排序算法，其时间复杂度计算公式如下，可以看到快速排序最好情况下时间复杂度为<code>O(nlogn)</code>，最坏情况下时间复杂度为<code>2^n</code>，平均时间复杂度为<code>O(nlogn)</code>。</p>
</blockquote>
<p>$$<br>待补充<br>$$</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>less函数与exch函数参见文章排序算法序言。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    sort(c, <span class="number">0</span>, c.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= start) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = partition(c, start, end);</span><br><span class="line">    sort(c, start, j - <span class="number">1</span>);</span><br><span class="line">    sort(c, j+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = start, j = end + <span class="number">1</span>;</span><br><span class="line">    Comparable v = c[start];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (less(c[++i], v))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == end)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (less(v, c[--j]))&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == start)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(c, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(c, start, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>不稳定排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/10/26/SelectionSort/</url>
    <content><![CDATA[<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<a id="more"></a>


<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>每次在未排序的数组中，找到最大或者最小的元素，放到已排序数组的末尾，依次进行，直到数组全部有序。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9] [8] [9] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>第一步，在原始数组中找到最小元素<font color="red">[1]</font>，起始位置的<font color="red">[9]</font>进行交换，结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [8] [9] [7] [9] [3] [5]</span><br></pre></td></tr></table></figure>

<p>第二步，在剩余未排序数组中找到最小元素<font color="red">[3]</font>与<font color="red">[8]</font>进行交换，结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [9] [7] [9] [8] [5]</span><br></pre></td></tr></table></figure>

<p>第三步，在剩余未排序数组中找到最小元素<font color="red">[5]</font>与索引三处的<font color="red">[9]</font>进行交换，结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [9] [8] [9]</span><br></pre></td></tr></table></figure>

<p>第四步，在剩余未排序数组中找到最小元素<font color="red">[7]</font>，其已经处在正确位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [9] [8] [9]</span><br></pre></td></tr></table></figure>

<p>第五步，在剩余未排序数组中找到最小元素<font color="red">[8]</font>，前面的<font color="red">[9]</font>进行交换，结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9] [9]</span><br></pre></td></tr></table></figure>

<p>第六步，在剩余未排序数组中找到最小元素<font color="red">[9]</font>，其已经处在正确位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9] [9]</span><br></pre></td></tr></table></figure>

<p>排序完毕，数组已经有序。</p>
<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>从第一步就可以明显看出，两个<code>[9]</code>交换了次序，因此插入排序是不稳定的排序算法。其时间复杂度计算公式如下。可以看到选择排序最好的情况下时间复杂度为2^n，最坏的情况下时间复杂度为2^n，空间复杂度为O(1)，平均时间复杂度为2^n。</p>
</blockquote>
<p>$$<br>(n-1) + (n-2) + … + 1 = \frac{n * (n-1)}{2}<br>$$</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>less函数与exch函数参见文章排序算法序言。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(c[j], c[j-<span class="number">1</span>]); j--)&#123;</span><br><span class="line">            exch(c, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>不稳定排序</tag>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法引言</title>
    <url>/2020/10/25/SortIntroduction/</url>
    <content><![CDATA[<p>排序算法是最常见的算法之一，常见的排序算法有<code>冒泡排序</code>、<code>插入排序</code>、<code>选择排序</code>、<code>希尔排序</code>、<code>归并排序</code>、<code>堆排序</code>、<code>快速排序</code>。其目的是为了实现&gt;对数组中元素的排序。通常排序分为正序和倒序。</p>
<a id="more"></a>


<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><blockquote>
<ul>
<li>最好、最坏、平均时间复杂度</li>
<li><code>时间复杂度</code>计算公式</li>
<li>比较次数和交换次数</li>
</ul>
</blockquote>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><blockquote>
<ul>
<li><code>空间复杂度</code>，衡量空间上的内存消耗</li>
<li><code>原地排序</code>，代指空间复杂度为O(1)的排序</li>
</ul>
</blockquote>
<h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><blockquote>
<ul>
<li><code>稳定</code>的算法在排序的过程中不会改变元素彼此的位置的相对次序,反之<code>不稳定</code>的排序算法经常会改变这个次序。以某两个相等元素<code>c[i]</code>和<code>c[j]</code>为例，假如在原始待排序数组中<code>c[i] == c[j]</code>，并且<code>c[i]</code>位置在<code>c[j]</code>之前。那么如果整个排序过程中，<code>c[i]</code>均在<code>c[j]</code>之前，则说明排序算法是稳定的，反之则是不稳定的。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3][4][9] .... [i] ... [j] ...</span><br></pre></td></tr></table></figure>



<h2 id="公共函数"><a href="#公共函数" class="headerlink" title="公共函数"></a>公共函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*比较两个元素大小*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*交换两个元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Comparable t = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>排序算法</tag>
        <tag>稳定与不稳定</tag>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo样式个性化配置</title>
    <url>/2021/03/31/hexo-preference/</url>
    <content><![CDATA[<p>hexo博客搭建好之后，如何调整样式对于没有前端基础的人来说是一件很困难的事情，下面分享我样式调整过程中的一些经验，由于我使用的是Next主题，所以如果是其它的主题的仅做参考，有可能细节之处不太一样。</p>
<a id="more"></a>



<h2 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blog home dir</span></span><br><span class="line">BLOG_HOME=/Users/lei/workspace/MyBlog</span><br></pre></td></tr></table></figure>



<h2 id="解锁样式定制配置"><a href="#解锁样式定制配置" class="headerlink" title="解锁样式定制配置"></a>解锁样式定制配置</h2><p>（1）打开next主题配置文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$&#123;BLOG_HOME&#125;</span>/themes/next/_config.yml</span><br></pre></td></tr></table></figure>



<p>（2）搜索<code>custom_file_path</code>可以看到如下配置，把反注释掉<code>style: source/_data/styles.styl</code>配置，记住去掉<code>#</code>号即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>



<p>（3）注意上面的<code>source/_data</code>目录指的是博客<code>home</code>目录下的<code>source/_data</code>目录，首先创建<code>_data</code>目录，然后创建<code>styles.style</code>文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create _data directory</span></span><br><span class="line">mkdir -p <span class="variable">$&#123;BLOG_HOME&#125;</span>/<span class="built_in">source</span>/_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># create _data file</span></span><br><span class="line">touch <span class="variable">$&#123;BLOG_HOME&#125;</span>/<span class="built_in">source</span>/_data/styles.styl</span><br></pre></td></tr></table></figure>



<h2 id="自定义样式配置"><a href="#自定义样式配置" class="headerlink" title="自定义样式配置"></a>自定义样式配置</h2><p>下面直接晒出我的配置，自己可以打开<code>Chrome</code>浏览器的检查功能，慢慢对照样式进行调整，其实主要是为了<code>PC</code>端与移动端的适配，保证<code>PC</code>端简洁大方，移动端不至于空白太多。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//背景图片配置</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    background:url(/images/background.jpeg);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed;</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文章部分配置</span></span><br><span class="line"><span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1px</span> <span class="number">3%</span> <span class="number">1px</span> <span class="number">3%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">80%</span>;</span><br><span class="line">    +mobile() &#123;</span><br><span class="line">   	<span class="attribute">padding</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动端自适应</span></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">   +mobile() &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">1%</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动端自适应</span></span><br><span class="line"><span class="selector-class">.use-motion</span> .post-block&#123;</span><br><span class="line">   +mobile() &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动端自适应</span></span><br><span class="line"><span class="selector-class">.comments</span> &#123;</span><br><span class="line">   +mobile() &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">      <span class="attribute">overflow</span>: hidden;   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动端自适应</span></span><br><span class="line"><span class="selector-class">.gt-container</span> <span class="selector-class">.gt-meta</span> &#123;</span><br><span class="line">   +mobile() &#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">1.25em</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内容最上面留白配置</span></span><br><span class="line">.<span class="attribute">content</span>&#123;</span><br><span class="line">   <span class="attribute">padding-top</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超链接配置</span></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">   <span class="attribute">color</span>: <span class="number">#0645AD</span>;</span><br><span class="line">   <span class="attribute">border-bottom</span>: none;</span><br><span class="line">   <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0645AD</span>;</span><br><span class="line">   &amp;:hover &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#0B0080</span>;</span><br><span class="line">      <span class="attribute">border-bottom</span>: none;</span><br><span class="line">      <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0B0080</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//graphviz图片自适应</span></span><br><span class="line"><span class="selector-class">.post-body</span> svg &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多级目录自动展开</span></span><br><span class="line"><span class="selector-class">.post-toc</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo简单使用</title>
    <url>/2021/03/18/hexo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><font color=green><strong>Hexo</strong></font> 是一个简单，美观，使用起来方便，支持各种二次定制的博客框架。并且支持丰富的<font color=green><strong>Markdown</strong></font>插件，是程序员不可多得的博客框架。</p>
<a id="more"></a>


<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>基本<font color=green><strong>Hexo</strong></font>使用命令介绍。</p>
<h3 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo new <span class="string">&#x27;title&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>创建完博客之后，会自动在<font color=blue> <strong>source/_posts</strong>/</font>目录下面创建一个同名的md结尾的<font color=green><strong>Markdown</strong></font>文件，此时只需要使用markdown编辑器打开md文件撰写博客即可，例如Typora或者Atomic等等。</p>
<h3 id="本地预览博客"><a href="#本地预览博客" class="headerlink" title="本地预览博客"></a>本地预览博客</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo s</span></span><br></pre></td></tr></table></figure>

<p>撰写完博客之后，在正式发布到博客网站之后，可以先使用<font color=green><strong>server</strong></font>命令本地启动博客服务器，预览博客效果，在确认没有问题之后再发布到正式网站上面。</p>
<h3 id="正式发布博客"><a href="#正式发布博客" class="headerlink" title="正式发布博客"></a>正式发布博客</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo clean &amp;&amp; hexo g -d</span></span><br></pre></td></tr></table></figure>

<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://theme-next.iissnan.com/theme-settings.html" title="Next Theme主题配置">Next Theme</a>     - next theme主题官方配置教程</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka命令</title>
    <url>/2021/03/27/kafka%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>kafka是一款优秀且常见的MQ，具有安装方便，使用方便，应用场景广泛等一系列优点，个人认为是最好用的MQ之一。</p>
<a id="more"></a>

<h2 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kafka version</span></span><br><span class="line">version=kafka_2.12-1.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka topic</span></span><br><span class="line">topic=ChristmasEvent</span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka bootstrap server</span></span><br><span class="line">Kafka_server=19.94.08.13:19092</span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka zookeeper server</span></span><br><span class="line">zk_server=19.14.08.13:21810</span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka consumer group</span></span><br><span class="line">consumer_group=bless-server</span><br></pre></td></tr></table></figure>



<h2 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建Topic</h2><p>创建kafka topic，其中replication-factor代表副本数，partitions代表分区数。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-topics.sh --create --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --replication-factor 1 --partitions 1 --topic <span class="variable">$&#123;topic&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="查看Topic内容（当前开始）"><a href="#查看Topic内容（当前开始）" class="headerlink" title="查看Topic内容（当前开始）"></a>查看Topic内容（当前开始）</h2><p>从当前时刻开始，用于实时查看kafka的消息。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-console-consumer.sh --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span> --topic <span class="variable">$&#123;topic&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="查看Topic内容（从头开始）"><a href="#查看Topic内容（从头开始）" class="headerlink" title="查看Topic内容（从头开始）"></a>查看Topic内容（从头开始）</h2><p>从头开始，用于实时查看kafka消息，仅限开发调测环境使用，当kafka消息过多时可能会导致异常问题。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-console-consumer.sh --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span> --topic <span class="variable">$&#123;topic&#125;</span> --from-beginning</span><br></pre></td></tr></table></figure>



<h2 id="查看消费组（旧版本）"><a href="#查看消费组（旧版本）" class="headerlink" title="查看消费组（旧版本）"></a>查看消费组（旧版本）</h2><p>查看消费者组情况，适用于用于旧版本kafka客户端。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --list --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="查看消费组（新版本）"><a href="#查看消费组（新版本）" class="headerlink" title="查看消费组（新版本）"></a>查看消费组（新版本）</h2><p>查看消费者组情况，适用于用于新版本kafka客户端。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --new-consumer --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span> --list</span><br></pre></td></tr></table></figure>



<h2 id="查看消费组（使用ZK连接而非Java-Api）"><a href="#查看消费组（使用ZK连接而非Java-Api）" class="headerlink" title="查看消费组（使用ZK连接而非Java Api）"></a>查看消费组（使用ZK连接而非Java Api）</h2><p>查看消费者组情况，仅限于使用zk连接的消费者。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --list</span><br></pre></td></tr></table></figure>



<h2 id="查看单个消费组详情（Java-Api）"><a href="#查看单个消费组详情（Java-Api）" class="headerlink" title="查看单个消费组详情（Java Api）"></a>查看单个消费组详情（Java Api）</h2><p>查看单个消费者组情况，使用Java Api连接的消费者。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --new-consumer --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span> --group <span class="variable">$&#123;consumer_group&#125;</span> --describe</span><br></pre></td></tr></table></figure>



<h2 id="查看单个消费组详情（ZK）"><a href="#查看单个消费组详情（ZK）" class="headerlink" title="查看单个消费组详情（ZK）"></a>查看单个消费组详情（ZK）</h2><p>查看单个消费者组情况，使用zk连接的消费者。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --group <span class="variable">$&#123;consumer_group&#125;</span> --describe</span><br></pre></td></tr></table></figure>



<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>直接在命令行发布一条消息，可以用于开发环境调测，重放消息等。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-console-producer.sh --broker-list <span class="variable">$&#123;kafka_server&#125;</span> --topic <span class="variable">$&#123;topic&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="查看Topic列表"><a href="#查看Topic列表" class="headerlink" title="查看Topic列表"></a>查看Topic列表</h2><p>查看kafka当前Topic列表。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-topics.sh --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --list</span><br></pre></td></tr></table></figure>



<h2 id="查看单个Topic详情"><a href="#查看单个Topic详情" class="headerlink" title="查看单个Topic详情"></a>查看单个Topic详情</h2><p>查看单个Topic详情。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-topics.sh --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --topic <span class="variable">$&#123;topic&#125;</span> --describe</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1011 在 D 天内送达包裹的能力</title>
    <url>/2021/08/28/leetcode-1011/</url>
    <content><![CDATA[<p>题目描述：传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p>
<p>传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minWeight = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = weights.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            maxWeight += weights[i];</span><br><span class="line">            <span class="keyword">if</span> (weights[i] &gt; minWeight) &#123;</span><br><span class="line">                minWeight = weights[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = minWeight;</span><br><span class="line">        <span class="keyword">int</span> right = maxWeight;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> currentDays = calculateDays(weights, mid);</span><br><span class="line">            <span class="keyword">if</span> (currentDays == days) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentDays &lt; days) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentDays &gt; days) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> days = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpWeight = weight;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; weights.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpWeight &gt;= weights[i]) &#123;</span><br><span class="line">                tmpWeight -= weights[i];</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (i == weights.length) &#123;</span><br><span class="line">                    days++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmpWeight = weight;</span><br><span class="line">                days++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
        <tag>难度中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-105 从前序与中序遍历序列构造二叉树</title>
    <url>/2021/08/02/leetcode-105/</url>
    <content><![CDATA[<p>题目描述：给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, inorder, <span class="number">0</span>, inorder.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> rootIdx, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 单个节点直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (start == end - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[start]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 前序第一个节点为二叉树根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[rootIdx]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 寻找根节点在中序序列中的索引值</span></span><br><span class="line">        <span class="keyword">int</span> rootIdxInOrder = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt; end; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[idx] == root.val) &#123;</span><br><span class="line">                rootIdxInOrder = idx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 中序序列中根节点左部分节点构成左子树</span></span><br><span class="line">        TreeNode leftNode = buildTree(preorder, rootIdx + <span class="number">1</span>, inorder, start, rootIdxInOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 中序序列中根节点右部分节点构成右子树</span></span><br><span class="line">        TreeNode rightNode = buildTree(preorder, rootIdx + <span class="number">1</span> + rootIdxInOrder - start, inorder, rootIdxInOrder + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 连接左右子树</span></span><br><span class="line">        root.left = leftNode;</span><br><span class="line">        root.right = rightNode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>前序、中序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-106 从中序与后续遍历序列构造二叉树</title>
    <url>/2021/08/03/leetcode-106/</url>
    <content><![CDATA[<p>题目描述：根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder, <span class="number">0</span>, inorder.length, postorder, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> rootIdx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 单个节点直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (start == end - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[start]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 后续最后一个节点为二叉树根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[rootIdx]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 寻找根节点在中序序列中的索引值</span></span><br><span class="line">        <span class="keyword">int</span> rootIdxInOrder = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt; end; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[idx] == root.val) &#123;</span><br><span class="line">                rootIdxInOrder = idx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 中序序列中根节点左部分节点构成左子树</span></span><br><span class="line">        TreeNode leftNode = buildTree(inorder, start, rootIdxInOrder, postorder, rootIdx - (end - rootIdxInOrder));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 中序序列中根节点右部分节点构成右子树</span></span><br><span class="line">        TreeNode rightNode = buildTree(inorder, rootIdxInOrder + <span class="number">1</span>, end, postorder, rootIdx - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 连接左右子树</span></span><br><span class="line">        root.left = leftNode;</span><br><span class="line">        root.right = rightNode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>中序、后序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-114 二叉树展开为链表</title>
    <url>/2021/07/30/leetcode-114/</url>
    <content><![CDATA[<p>题目描述：给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</li>
<li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        convertTree2List(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertTree2List</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 转换左子树</span></span><br><span class="line">        TreeNode leftHeadNode = convertTree2List(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 转换右子树</span></span><br><span class="line">        TreeNode rightHeadNode = convertTree2List(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 找到左子树的叶子节点</span></span><br><span class="line">        TreeNode leftTailNode = leftHeadNode;</span><br><span class="line">        <span class="keyword">while</span> (leftTailNode != <span class="keyword">null</span> &amp;&amp; leftTailNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            leftTailNode = leftTailNode.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 拼接左右子树与根节点</span></span><br><span class="line">        <span class="keyword">if</span> (leftTailNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.right = rightHeadNode;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.right = leftHeadNode;</span><br><span class="line">            leftTailNode.right = rightHeadNode;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-116 填充每个节点的下一个右侧节点指针</title>
    <url>/2021/07/31/leetcode-116/</url>
    <content><![CDATA[<p>题目描述：给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">  	Node left;</span><br><span class="line">  	Node right;</span><br><span class="line">  	Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理左子树</span></span><br><span class="line">        Node leftNode = connect(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 处理右子树</span></span><br><span class="line">        Node rightNode = connect(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 处理根节点</span></span><br><span class="line">        <span class="keyword">while</span> (leftNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            leftNode.next = rightNode;</span><br><span class="line">            leftNode = leftNode.right;</span><br><span class="line">            rightNode = rightNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-130 被围绕的区域</title>
    <url>/2021/08/19/leetcode-130/</url>
    <content><![CDATA[<p>题目描述：给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="连通图实现"><a href="#连通图实现" class="headerlink" title="连通图实现"></a>连通图实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子树个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录每个节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录每个节点的子树的节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 子树初始节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两颗子树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p 节点p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q 节点q</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = findRoot(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = findRoot(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size[pRoot] &gt; size[qRoot]) &#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            size[pRoot] = size[qRoot] + size[pRoot];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            size[qRoot] = size[pRoot] + size[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个节点是否属于同一颗子树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p 节点p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q 节点q</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否属于同一颗子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = findRoot(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = findRoot(q);</span><br><span class="line">        <span class="keyword">return</span> pRoot == qRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到当前节点的根节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = parent[parent[x]];</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前子树个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 初始化连通图</span></span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(m * n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 假设有个m*n节点，视为非包围O节点的根节点</span></span><br><span class="line">        <span class="keyword">int</span> dummy = m * n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 处理前后两列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                uf.union(i * n, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                uf.union(i * n + n - <span class="number">1</span>, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 处理上下两行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                uf.union(j, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                uf.union((m - <span class="number">1</span>) * n + j, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 处理每个非边缘节点</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> p = i * n + j;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = i + dp[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = j + dp[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> q = x * n + y;</span><br><span class="line">                            uf.union(p, q);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 根据结果处理数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!uf.connected(dummy, i * n + j)) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>矩阵</tag>
        <tag>二维数组</tag>
        <tag>图</tag>
        <tag>连通性</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1373 二叉搜索子树的最大键值和</title>
    <url>/2021/08/09/leetcode-1373/</url>
    <content><![CDATA[<p>题目描述：给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。</p>
<p>二叉搜索树的定义如下：</p>
<ul>
<li>任意节点的左子树中的键值都 小于 此节点的键值。</li>
<li>任意节点的右子树中的键值都 大于 此节点的键值。</li>
<li>任意节点的左子树和右子树都是二叉搜索树。</li>
<li>每棵树有 <code>1</code> 到 <code>40000</code> 个节点。</li>
<li>每个节点的键值在 <code>[-4 * 10^4 , 4 * 10^4]</code> 之间。</li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        postBST(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * int[] 是否是二叉搜索树，左子树最小值，右子树最大值，如果是二叉搜索树则求和</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] postBST(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] left = postBST(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = postBST(root.right);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>]) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = Math.min(root.val, left[<span class="number">1</span>]);</span><br><span class="line">            res[<span class="number">2</span>] = Math.max(root.val, right[<span class="number">2</span>]);</span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">            maxSum = Math.max(res[<span class="number">3</span>], maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉搜索树</tag>
        <tag>难度困难</tag>
        <tag>子树</tag>
        <tag>最大键值和</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-141 环形链表</title>
    <url>/2021/08/30/leetcode-141/</url>
    <content><![CDATA[<p>题目描述：给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode quickPoint = head.next.next;</span><br><span class="line">        ListNode slowPoint = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (quickPoint.next != <span class="keyword">null</span> &amp;&amp; quickPoint.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (quickPoint == slowPoint) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            quickPoint = quickPoint.next.next;</span><br><span class="line">            slowPoint = slowPoint.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>环形链表</tag>
        <tag>难度简单</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-142 环形链表</title>
    <url>/2021/08/21/leetcode-142/</url>
    <content><![CDATA[<p>题目描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<a id="more"></a>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判断是否有环</span></span><br><span class="line">        ListNode fastNode = head;</span><br><span class="line">        ListNode slowNode = head;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != <span class="keyword">null</span> &amp;&amp; fastNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fastNode = fastNode.next.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            <span class="keyword">if</span> (fastNode == slowNode) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 说明没环，直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (fastNode != slowNode || fastNode == <span class="keyword">null</span> || fastNode.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 计算环大小</span></span><br><span class="line">        <span class="keyword">int</span> cycleSize = <span class="number">1</span>;</span><br><span class="line">        fastNode = fastNode.next.next;</span><br><span class="line">        slowNode = slowNode.next;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != slowNode) &#123;</span><br><span class="line">            fastNode = fastNode.next.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            cycleSize++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 快指针先走环大小步，然后和慢指针一起走，会在环开始位置相遇</span></span><br><span class="line">        fastNode = slowNode = head;</span><br><span class="line">        <span class="keyword">while</span> (cycleSize-- != <span class="number">0</span>) &#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != slowNode) &#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>环形链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-146 LRU 缓存机制</title>
    <url>/2021/08/20/leetcode-146/</url>
    <content><![CDATA[<p>题目描述：运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p>
<ul>
<li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li>
<li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有序HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cache.put(key, value);</span><br><span class="line">            makeRecently(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cache.size() &gt;= <span class="keyword">this</span>.cap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.cache.remove(<span class="keyword">this</span>.cache.keySet().iterator().next());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.cache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新key为最近</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="keyword">this</span>.cache.remove(key);</span><br><span class="line">        <span class="keyword">this</span>.cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>LRU算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-167 两数之和 II - 输入有序数组</title>
    <url>/2021/09/03/leetcode-167/</url>
    <content><![CDATA[<p>题目描述：给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p>
<p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> idx = find(numbers, target - numbers[i], i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (idx == -<span class="number">1</span> || idx == i) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[<span class="number">1</span>] = idx + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>有序数组</tag>
        <tag>两数之和</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-19 删除链表的倒数第 N 个结点</title>
    <url>/2021/09/02/leetcode-19/</url>
    <content><![CDATA[<p>题目描述：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode fastNode = head;</span><br><span class="line">        ListNode slowNode = head;</span><br><span class="line">        <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fastNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            slowNode = head.next;</span><br><span class="line">            <span class="keyword">return</span> slowNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fastNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slowNode.next = slowNode.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>链表</tag>
        <tag>删除</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-226 翻转二叉树</title>
    <url>/2021/07/29/leetcode-226/</url>
    <content><![CDATA[<p>题目描述：翻转一棵二叉树。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = invertTree(root.left);</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = node;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>反转</tag>
        <tag>难度简单</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-230 二叉搜索树中第K小的元素</title>
    <url>/2021/08/05/leetcode-230/</url>
    <content><![CDATA[<p>题目描述：给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="中序实现"><a href="#中序实现" class="headerlink" title="中序实现"></a>中序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inorders(root);</span><br><span class="line">        <span class="keyword">return</span> nodes.get(k).val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorders</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.left);</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        inorders(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idxVal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inorders(root, k);</span><br><span class="line">        <span class="keyword">return</span> idxVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorders</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.left, k);</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="keyword">if</span> (idx == k) &#123;</span><br><span class="line">            idxVal = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉搜索树</tag>
        <tag>第K小元素</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-234 回文链表</title>
    <url>/2021/07/28/leetcode-234/</url>
    <content><![CDATA[<p>题目描述：请判断一个链表是否为回文链表。你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 遍历计算链表长度</span></span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 寻找中间节点</span></span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">int</span> subLen = len / <span class="number">2</span> + len % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (subLen-- != <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 反转右半链表区间剩余节点</span></span><br><span class="line">        ListNode subHead2 = reverse(node);</span><br><span class="line">        ListNode subHead1 = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 分别对比左链表区间元素与右链表区间元素</span></span><br><span class="line">        <span class="keyword">while</span> (subHead1 != <span class="keyword">null</span> &amp;&amp; subHead2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (subHead1.val != subHead2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            subHead1 = subHead1.next;</span><br><span class="line">            subHead2 = subHead2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表反转</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 链表头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回反转后的链表头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
        <tag>难度简单</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-236 二叉树的最近公共祖先</title>
    <url>/2021/08/17/leetcode-236/</url>
    <content><![CDATA[<p>题目描述：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 为空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 等于其中一个节点则返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 处理左子树</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="comment">//4. 处理右子树</span></span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//5. 处理结果</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>最近公共祖先节点</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-239 滑动窗口最大值</title>
    <url>/2021/08/25/leetcode-239/</url>
    <content><![CDATA[<p>题目描述：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.getLast() &lt; e) &#123;</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Integer e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.equals(queue.getFirst())) &#123;</span><br><span class="line">            queue.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Window window = <span class="keyword">new</span> Window();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            window.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            window.add(nums[i]);</span><br><span class="line">            res[i - k + <span class="number">1</span>] = window.getMax();</span><br><span class="line">            window.remove(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度困难</tag>
        <tag>最大值</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-25 K个一组翻转链表</title>
    <url>/2021/07/27/leetcode-25/</url>
    <content><![CDATA[<p>题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。你可以设计一个只使用常数额外空间的算法来解决此问题吗？你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<a id="more"></a>

<h2 id="原题介绍"><a href="#原题介绍" class="headerlink" title="原题介绍"></a>原题介绍</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><div><div class="graphviz">digraph leetcode_92_1 {
    
    bgcolor="#f7f7f7"

<pre><code>rankdir=LR
subgraph cluster_name &#123;
    
    subgraph cluster_1 &#123;
        n0 [label=&quot;1&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        n1 [label=&quot;2&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        n2 [label=&quot;3&quot; shape=circle,color=yellow,fillcolor=lightyellow,style=filled]
        n3 [label=&quot;4&quot; shape=circle,color=yellow,fillcolor=lightyellow,style=filled]
        n4 [label=&quot;5&quot; shape=circle,color=black,fillcolor=white,style=filled]
        rank=same;
        n0 -&gt; n1 -&gt; n2 -&gt; n3 -&gt; n4 
        style=invis
    &#125;

    subgraph cluster_2 &#123;
        r0 [label=&quot;2&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        r1 [label=&quot;1&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        r2 [label=&quot;4&quot; shape=circle,color=yellow,fillcolor=lightyellow,style=filled]
        r3 [label=&quot;3&quot; shape=circle,color=yellow,fillcolor=lightyellow,style=filled]
        r4 [label=&quot;5&quot; shape=circle,color=black,fillcolor=white,style=filled]

        rank=same;
        r0 -&gt; r1 -&gt; r2 -&gt; r3 -&gt; r4 
        style=invis
    &#125;    

    n2 -&gt; r2[constraint=false,color=&quot;red&quot;,pad=30]    

&#125;

label=&lt;&lt;B&gt;图 1.1 示例一&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入：head</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]<span class="string">,</span> <span class="string">k</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">输出：[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure>



<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode nextNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 遍历计算链表长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 每组k各元素，计算分组数</span></span><br><span class="line">        <span class="keyword">int</span> group = len / k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 分别处理每个组，分别进行反转</span></span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt;= group; idx++) &#123;</span><br><span class="line">            newHead = reverseBetween(head, k * (idx - <span class="number">1</span>) + <span class="number">1</span>, k * idx);</span><br><span class="line">            head = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转链表区间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 链表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 区间左</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 区间右</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新链表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || right == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            head.next = reverseBetween(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverse(head, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转链表前right个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head  链表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 前right个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新链表头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || right == <span class="number">1</span>) &#123;</span><br><span class="line">            nextNode = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverse(head.next, right - <span class="number">1</span>);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = nextNode;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
        <tag>难度困难</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-26 删除有序数组中的重复项</title>
    <url>/2021/09/10/leetcode-26/</url>
    <content><![CDATA[<p>题目描述：给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != nums[left]) &#123;</span><br><span class="line">                nums[++left] = nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>有序数组</tag>
        <tag>重复项</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-27 移除元素</title>
    <url>/2021/09/12/leetcode-27/</url>
    <content><![CDATA[<p>题目描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] != val) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] == val) &#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>重复项</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-283 移动零</title>
    <url>/2021/09/13/leetcode-283/</url>
    <content><![CDATA[<p>题目描述：给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[left++] = nums[right++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            nums[left++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度简单</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-295 数据流的中位数</title>
    <url>/2021/08/18/leetcode-295/</url>
    <content><![CDATA[<p>题目描述：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; small;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; large;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.large = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.small = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.small.size() &gt;= <span class="keyword">this</span>.large.size()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.small.add(num);</span><br><span class="line">            <span class="keyword">this</span>.large.add(<span class="keyword">this</span>.small.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.large.add(num);</span><br><span class="line">            <span class="keyword">this</span>.small.add(<span class="keyword">this</span>.large.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.small.size() &gt; <span class="keyword">this</span>.large.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.small.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.small.size() &lt; <span class="keyword">this</span>.large.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.large.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>.large.peek() + <span class="keyword">this</span>.small.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度困难</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-297 二叉树的序列化与反序列化</title>
    <url>/2021/08/15/leetcode-297/</url>
    <content><![CDATA[<p>题目描述：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 104]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="前序实现"><a href="#前序实现" class="headerlink" title="前序实现"></a>前序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NULL_NODE = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SEPARATOR = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NULL_NODE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(root.val) + SEPARATOR + serialize(root.left) + SEPARATOR + serialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 分离二叉树节点</span></span><br><span class="line">        String[] allNodeVal = data.split(SEPARATOR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 尾插法二叉树节点</span></span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String nodeVal : allNodeVal) &#123;</span><br><span class="line">            nodes.addLast(nodeVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 递归处理二叉树节点</span></span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodes LinkedList&lt;String&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理非空节点</span></span><br><span class="line">        String firstVal = nodes.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (NULL_NODE.equals(firstVal)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(firstVal));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 递归处理左子树</span></span><br><span class="line">        node.left = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 递归处理右子树</span></span><br><span class="line">        node.right = deserialize(nodes);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="后序实现"><a href="#后序实现" class="headerlink" title="后序实现"></a>后序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NULL_NODE = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SEPARATOR = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NULL_NODE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serialize(root.left) + SEPARATOR + serialize(root.right) + SEPARATOR + String.valueOf(root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 分离二叉树节点</span></span><br><span class="line">        String[] nodes = data.split(SEPARATOR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 头插法二叉树节点</span></span><br><span class="line">        LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">            list.addFirst(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 递归处理二叉树节点</span></span><br><span class="line">        <span class="keyword">return</span> deserialize(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodes LinkedList&lt;String&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理非空节点</span></span><br><span class="line">        String firstVal = nodes.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (NULL_NODE.equals(firstVal)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(firstVal));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 递归处理右子树</span></span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 递归处理左子树</span></span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序实现"><a href="#中序实现" class="headerlink" title="中序实现"></a>中序实现</h3><p>中序只能序列化，无法反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NULL_NODE = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SEPARATOR = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NULL_NODE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serialize(root.left) + SEPARATOR + String.valueOf(root.val) + SEPARATOR + serialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="层序实现"><a href="#层序实现" class="headerlink" title="层序实现"></a>层序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NULL_NODE = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SEPARATOR = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 层序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 序列化字符串</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 层序遍历</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = list.removeFirst();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(NULL_NODE).append(SEPARATOR);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(node.val).append(SEPARATOR);</span><br><span class="line">            list.addLast(node.left);</span><br><span class="line">            list.addLast(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 排除最后一个多余的分隔符</span></span><br><span class="line">        <span class="keyword">return</span> sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理根节点</span></span><br><span class="line">        String[] nodes = data.split(SEPARATOR);</span><br><span class="line">        LinkedList&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 层序遍历</span></span><br><span class="line">        list.addLast(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodes.length; ) &#123;</span><br><span class="line">            TreeNode parent = list.removeFirst();</span><br><span class="line">            <span class="comment">//3.1 处理左节点</span></span><br><span class="line">            String left = nodes[i++];</span><br><span class="line">            <span class="keyword">if</span> (NULL_NODE.equals(left)) &#123;</span><br><span class="line">                parent.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(left));</span><br><span class="line">                list.addLast(parent.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.2 处理右节点</span></span><br><span class="line">            String right = nodes[i++];</span><br><span class="line">            <span class="keyword">if</span> (NULL_NODE.equals(right)) &#123;</span><br><span class="line">                parent.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(right));</span><br><span class="line">                list.addLast(parent.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>序列化与反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-3 无重复字符的最长子串</title>
    <url>/2021/09/07/leetcode-3/</url>
    <content><![CDATA[<p>题目描述：给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, start = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            need.merge(c, <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">            <span class="keyword">while</span> (need.get(c).equals(<span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - <span class="number">1</span> - left &gt; len) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - <span class="number">1</span> - left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                need.compute(l, (k, v) -&gt; --v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left &gt; len ? right - left : len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>字符串</tag>
        <tag>无重复</tag>
        <tag>最长字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-300 最长递增子序列</title>
    <url>/2021/09/15/leetcode-300/</url>
    <content><![CDATA[<p>题目描述：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>递增子序列</tag>
        <tag>最长</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-341 扁平化嵌套列表迭代器</title>
    <url>/2021/08/16/leetcode-341/</url>
    <content><![CDATA[<p>题目描述：给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。</p>
<p>实现扁平迭代器类 NestedIterator ：</p>
<ol>
<li>NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器。</li>
</ol>
<ul>
<li><p>int next() 返回嵌套列表的下一个整数。</p>
</li>
<li><p>boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。<br>你的代码将会用下述伪代码检测：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">initialize iterator with nestedList</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> iterator.hasNext()</span><br><span class="line">    append iterator.next() to the end of res</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="NestedInteger"><a href="#NestedInteger" class="headerlink" title="NestedInteger"></a>NestedInteger</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;NestedInteger&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedInteger</span><span class="params">(Integer node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedInteger</span><span class="params">(List&lt;NestedInteger&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.node = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.node != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Integer&gt; it;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 扁平化展开嵌套列表</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger nit : nestedList) &#123;</span><br><span class="line">            traverse(nit, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理展开后的列表</span></span><br><span class="line">        <span class="keyword">this</span>.it = list.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.it.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.it.hasNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归展开列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nit  NestedInteger</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list List&lt;Integer&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(NestedInteger nit, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nit.isInteger()) &#123;</span><br><span class="line">            list.add(nit.getInteger());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger childNit : nit.getList()) &#123;</span><br><span class="line">            traverse(childNit, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="惰性实现"><a href="#惰性实现" class="headerlink" title="惰性实现"></a>惰性实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;NestedInteger&gt; it;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.it = <span class="keyword">new</span> LinkedList&lt;&gt;(nestedList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.it.remove(<span class="number">0</span>).getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断下一个原始是否是Integer</span></span><br><span class="line"><span class="comment">     * 如果是Integer则直接返回</span></span><br><span class="line"><span class="comment">     * 如果不是则使用头插法展开</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.it.isEmpty() &amp;&amp; !<span class="keyword">this</span>.it.get(<span class="number">0</span>).isInteger()) &#123;</span><br><span class="line">            List&lt;NestedInteger&gt; nit = <span class="keyword">this</span>.it.remove(<span class="number">0</span>).getList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nit.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">this</span>.it.addFirst(nit.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.it.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>扁平化迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-344 反转字符串</title>
    <url>/2021/09/04/leetcode-344/</url>
    <content><![CDATA[<p>题目描述：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> odd = s.length % <span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> half = s.length / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= half; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            s[i] = s[s.length - <span class="number">1</span> - i];</span><br><span class="line">            s[s.length - <span class="number">1</span> - i] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>反转字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-354 俄罗斯套娃信封问题</title>
    <url>/2021/09/16/leetcode-354/</url>
    <content><![CDATA[<p>题目描述：给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。</p>
<p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(envelopes, (o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> o2[<span class="number">1</span>] - o1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; envelopes.length; i++) &#123;</span><br><span class="line">            nums[i] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lengthOfLIS(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度困难</tag>
        <tag>俄罗斯套娃</tag>
        <tag>信封</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-355 设计推特</title>
    <url>/2021/08/22/leetcode-355/</url>
    <content><![CDATA[<p>题目描述：设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：</p>
<ol>
<li>   postTweet(userId, tweetId): 创建一条新的推文</li>
<li>   getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。</li>
<li>   follow(followerId, followeeId): 关注一个用户</li>
<li>   unfollow(followerId, followeeId): 取消关注一个用户</li>
</ol>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tweet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Tweet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer tweetId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(Integer tweetId, Long createTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tweetId = tweetId;</span><br><span class="line">        <span class="keyword">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getTweetId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tweetId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTweetId</span><span class="params">(Integer tweetId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tweetId = tweetId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getCreateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreateTime</span><span class="params">(Long createTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Tweet o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="keyword">this</span>.createTime - o.getCreateTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Tweet&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;tweetId=&quot;</span> + tweetId +</span><br><span class="line">                <span class="string">&quot;, createTime=&quot;</span> + createTime +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; followerIds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; followeeIds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Tweet&gt; tweets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer userId, List&lt;Integer&gt; followerIds, List&lt;Integer&gt; followeeIds, LinkedList&lt;Tweet&gt; tweets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.followerIds = followerIds;</span><br><span class="line">        <span class="keyword">this</span>.followeeIds = followeeIds;</span><br><span class="line">        <span class="keyword">this</span>.tweets = tweets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getFollowerIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> followerIds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFollowerIds</span><span class="params">(List&lt;Integer&gt; followerIds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.followerIds = followerIds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getFolloweeIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> followeeIds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFolloweeIds</span><span class="params">(List&lt;Integer&gt; followeeIds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.followeeIds = followeeIds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LinkedList&lt;Tweet&gt; <span class="title">getTweets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tweets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTweets</span><span class="params">(LinkedList&lt;Tweet&gt; tweets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tweets = tweets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userId=&quot;</span> + userId +</span><br><span class="line">                <span class="string">&quot;, followerIds=&quot;</span> + followerIds +</span><br><span class="line">                <span class="string">&quot;, followeeIds=&quot;</span> + followeeIds +</span><br><span class="line">                <span class="string">&quot;, tweets=&quot;</span> + tweets +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, User&gt; users;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.users = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        Tweet tweet = <span class="keyword">new</span> Tweet(tweetId, System.nanoTime());</span><br><span class="line">        User user = <span class="keyword">this</span>.users.getOrDefault(userId, createUser(userId));</span><br><span class="line">        user.getTweets().addFirst(tweet);</span><br><span class="line">        <span class="keyword">if</span> (user.getTweets().size() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            user.getTweets().subList(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.users.put(userId, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.users.containsKey(userId)) &#123;</span><br><span class="line">            List&lt;Tweet&gt; tweets = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            tweets.addAll(<span class="keyword">this</span>.users.get(userId).getTweets());</span><br><span class="line">            <span class="keyword">this</span>.users.get(userId).getFollowerIds().stream().map(<span class="keyword">this</span>.users::get).map(User::getTweets).forEach(list -&gt; tweets.addAll(list));</span><br><span class="line">            List&lt;Integer&gt; result = tweets.stream().sorted(Comparator.reverseOrder()).distinct().map(Tweet::getTweetId).collect(Collectors.toList());</span><br><span class="line">            <span class="keyword">return</span> result.size() &gt; <span class="number">10</span> ? result.subList(<span class="number">0</span>, <span class="number">10</span>) : result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        User follower = <span class="keyword">this</span>.users.getOrDefault(followerId, createUser(followerId));</span><br><span class="line">        follower.getFollowerIds().add(followeeId);</span><br><span class="line">        <span class="keyword">this</span>.users.put(followerId, follower);</span><br><span class="line">        User followee = <span class="keyword">this</span>.users.getOrDefault(followeeId, createUser(followeeId));</span><br><span class="line">        followee.getFolloweeIds().add(followerId);</span><br><span class="line">        <span class="keyword">this</span>.users.put(followeeId, followee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.users.get(followerId).getFollowerIds().remove((Object) followeeId);</span><br><span class="line">        <span class="keyword">this</span>.users.get(followeeId).getFolloweeIds().remove((Object) followerId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> User <span class="title">createUser</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(userId, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-380  O(1) 时间插入、删除和获取随机元素</title>
    <url>/2021/09/08/leetcode-380/</url>
    <content><![CDATA[<p>题目描述：设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。</p>
<p>insert(val)：当元素 val 不存在时，向集合中插入该项。<br>remove(val)：元素 val 存在时，从集合中移除该项。<br>getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; array;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; valToIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.valToIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.valToIndex.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.array.add(val);</span><br><span class="line">        <span class="keyword">this</span>.valToIndex.put(val, <span class="keyword">this</span>.array.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.valToIndex.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="keyword">this</span>.valToIndex.get(val);</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="keyword">this</span>.array.get(idx);</span><br><span class="line">        <span class="keyword">this</span>.array.set(idx, <span class="keyword">this</span>.array.get(<span class="keyword">this</span>.array.size() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">this</span>.valToIndex.put(<span class="keyword">this</span>.array.get(idx), idx);</span><br><span class="line">        <span class="keyword">this</span>.array.set(<span class="keyword">this</span>.array.size() - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">this</span>.array.remove(<span class="keyword">this</span>.array.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.valToIndex.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> index = random.nextInt(<span class="keyword">this</span>.array.size());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-410 分割数组的最大值</title>
    <url>/2021/08/29/leetcode-410/</url>
    <content><![CDATA[<p>题目描述：给定一个非负整数数组 <code>nums</code> 和一个整数 <code>m</code> ，你需要将这个数组分成 <code>m</code> 个非空的连续子数组。</p>
<p>设计一个算法使得这 <code>m</code> 个子数组各自和的最大值最小。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minSum = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; minSum) &#123;</span><br><span class="line">                minSum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = minSum;</span><br><span class="line">        <span class="keyword">int</span> right = maxSum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> currentM = calculateM(nums, mid);</span><br><span class="line">            <span class="keyword">if</span> (currentM == m) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentM &gt; m) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentM &lt; m) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateM</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpSum = sum;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpSum &gt;= nums[i]) &#123;</span><br><span class="line">                tmpSum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">                    m++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmpSum = sum;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
        <tag>难度中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-438 找到字符串中所有字母异位词</title>
    <url>/2021/09/06/leetcode-438/</url>
    <content><![CDATA[<p>题目描述：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>异位词 指字母相同，但排列不同的字符串。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">            need.merge(p.charAt(i), <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, valid = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(r)) &#123;</span><br><span class="line">                window.merge(r, <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">                <span class="keyword">if</span> (window.get(r).equals(need.get(r))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (right - left == p.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (valid == need.size()) &#123;</span><br><span class="line">                    res.add(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(l)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window.get(l).equals(need.get(l))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window.compute(l, (k, v) -&gt; --v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>字符串</tag>
        <tag>排列</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-450 删除二叉搜索树中的节点</title>
    <url>/2021/08/10/leetcode-450/</url>
    <content><![CDATA[<p>题目描述：给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：</p>
<ul>
<li><p>首先找到需要删除的节点；</p>
</li>
<li><p>如果找到了，删除它。</p>
</li>
</ul>
<p>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode minNode = getMinNode(root.right);</span><br><span class="line">            root.val = minNode.val;</span><br><span class="line">            root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">getMinNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉搜索树</tag>
        <tag>删除节点</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-496 下一个更大元素 I</title>
    <url>/2021/08/23/leetcode-496/</url>
    <content><![CDATA[<p>题目描述：给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p>
<p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; maps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums2.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums2[i]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            Integer nextMaxVal = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            maps.put(nums2[i], nextMaxVal);</span><br><span class="line">            stack.add(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            res[i] = maps.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-503 下一个更大元素 II</title>
    <url>/2021/08/24/leetcode-503/</url>
    <content><![CDATA[<p>题目描述：给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cycle = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length * <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(nums, <span class="number">0</span>, cycle, <span class="number">0</span>, nums.length);</span><br><span class="line">        System.arraycopy(nums, <span class="number">0</span>, cycle, nums.length, nums.length);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[cycle.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cycle.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= cycle[i]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nextMax = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            res[i] = nextMax;</span><br><span class="line">            stack.push(cycle[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-538 把二叉搜索树转换为累加树</title>
    <url>/2021/08/06/leetcode-538/</url>
    <content><![CDATA[<p>题目描述：给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 小于 节点键的节点。</li>
<li>节点的右子树仅包含键 大于 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="后序实现"><a href="#后序实现" class="headerlink" title="后序实现"></a>后序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inorders(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">            nodes.get(i).val = nodes.get(i - <span class="number">1</span>).val + nodes.get(i).val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorders</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.right);</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        inorders(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inorders(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorders</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        inorders(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉搜索时树</tag>
        <tag>累加树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-567 字符串的排列</title>
    <url>/2021/09/05/leetcode-567/</url>
    <content><![CDATA[<p>题目描述：给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。</p>
<p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            need.merge(s1.charAt(i), <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> r = s2.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(r)) &#123;</span><br><span class="line">                window.merge(r, <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">                <span class="keyword">if</span> (window.get(r).equals(need.get(r))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (right - left == s1.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (valid == need.size()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> l = s2.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(l)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window.get(l).equals(need.get(l))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window.compute(l, (k, v) -&gt; --v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>字符串</tag>
        <tag>排列</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-652 寻找重复的子树</title>
    <url>/2021/08/04/leetcode-652/</url>
    <content><![CDATA[<p>题目描述：给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p>
<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Integer&gt; subTrees = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; duplicate = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        findDuplicateSubtrees(root);</span><br><span class="line">        <span class="keyword">return</span> duplicate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">postorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String left = postorder(root.left);</span><br><span class="line">        String right = postorder(root.right);</span><br><span class="line">        String subTree = left + <span class="string">&quot;,&quot;</span> + right + <span class="string">&quot;,&quot;</span> + root.val;</span><br><span class="line">        <span class="keyword">int</span> frequency = subTrees.getOrDefault(subTree, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (frequency == <span class="number">1</span>) &#123;</span><br><span class="line">            duplicate.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        subTrees.put(subTree, frequency + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> subTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>重复子树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-654 最大二叉树</title>
    <url>/2021/08/01/leetcode-654/</url>
    <content><![CDATA[<p>题目描述：给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：</p>
<ul>
<li>二叉树的根是数组 nums 中的最大元素。</li>
<li>左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。</li>
<li>右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。</li>
</ul>
<p>返回有给定数组 nums 构建的 最大二叉树 。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> constructMaximumBinaryTree(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 单个元素直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (start == end - <span class="number">1</span>) &#123;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(nums[start]);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 寻找最大元素</span></span><br><span class="line">        <span class="keyword">int</span> maxVal = nums[start];</span><br><span class="line">        <span class="keyword">int</span> maxIdx = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt; end; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] &gt; maxVal) &#123;</span><br><span class="line">                maxVal = nums[idx];</span><br><span class="line">                maxIdx = idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 最大元素为根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(maxVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 最大元素左边为左子树</span></span><br><span class="line">        TreeNode leftNode = constructMaximumBinaryTree(nums, start, maxIdx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 最大元素右边为右子树</span></span><br><span class="line">        TreeNode rightNode = constructMaximumBinaryTree(nums, maxIdx + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 连接左右子树</span></span><br><span class="line">        root.left = leftNode;</span><br><span class="line">        root.right = rightNode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-700 二叉搜索树中的搜索</title>
    <url>/2021/08/12/leetcode-700/</url>
    <content><![CDATA[<p>题目描述：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>提示：</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode searchNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        search(root, val);</span><br><span class="line">        <span class="keyword">return</span> searchNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">            searchNode = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            search(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            search(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉搜索树</tag>
        <tag>难度简单</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-701 二叉搜索树中的插入操作</title>
    <url>/2021/08/11/leetcode-701/</url>
    <content><![CDATA[<p>题目描述：给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<p>提示：</p>
<ul>
<li>给定的树上的节点数介于 0 和 10^4 之间</li>
<li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li>
<li>-10^8 &lt;= val &lt;= 10^8</li>
<li>新值和原始二叉搜索树中的任意节点值都不同</li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉搜索树</tag>
        <tag>插入</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-710 黑名单中的随机数</title>
    <url>/2021/09/09/leetcode-710/</url>
    <content><![CDATA[<p>题目描述：给定一个包含 [0，n) 中不重复整数的黑名单 blacklist ，写一个函数从 [0, n) 中返回一个不在 blacklist 中的随机整数。</p>
<p>对它进行优化使其尽量少调用系统方法 Math.random() 。</p>
<p>提示:</p>
<p>1 &lt;= n &lt;= 1000000000<br>0 &lt;= blacklist.length &lt; min(100000, N)<br>[0, n) 不包含 n ，详细参见 interval notation 。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; blackMapping;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] blacklist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.N = n;</span><br><span class="line">        <span class="keyword">this</span>.blackMapping = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b : blacklist) &#123;</span><br><span class="line">            <span class="keyword">this</span>.blackMapping.put(b, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> whiteSize = <span class="keyword">this</span>.N - blacklist.length;</span><br><span class="line">        <span class="keyword">int</span> left = whiteSize;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b : blacklist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &lt; whiteSize) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">this</span>.blackMapping.containsKey(left)) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.blackMapping.put(b, left++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> idx = random.nextInt(N - <span class="keyword">this</span>.blackMapping.size());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.blackMapping.containsKey(idx)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.blackMapping.get(idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度困难</tag>
        <tag>黑名单</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-72 编辑距离</title>
    <url>/2021/09/14/leetcode-72/</url>
    <content><![CDATA[<p>题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> dp1, <span class="keyword">int</span> dp2, <span class="keyword">int</span> dp3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(dp1, dp2), dp3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度困难</tag>
        <tag>两个单词</tag>
        <tag>转换</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-76 最小覆盖子串</title>
    <url>/2021/09/05/leetcode-76/</url>
    <content><![CDATA[<p>题目描述：给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need.merge(t.charAt(i), <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, start = <span class="number">0</span>, valid = <span class="number">0</span>, len = s.length() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">                window.merge(c, <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">                <span class="keyword">if</span> (need.get(c).equals(window.get(c))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(l)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window.get(l).equals(need.get(l))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window.compute(l, (k, v) -&gt; --v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == s.length() + <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.substring(start, start + len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度困难</tag>
        <tag>字符串</tag>
        <tag>子串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-797 所有可能的路径</title>
    <url>/2021/08/14/leetcode-797/</url>
    <content><![CDATA[<p>题目描述：给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。提示：</p>
<ul>
<li>n == graph.length</li>
<li>2 &lt;= n &lt;= 15</li>
<li>0 &lt;= graph[i][j] &lt; n</li>
<li>graph[i][j] != i </li>
<li>保证输入为有向无环图 (GAD)</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; allPaths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        path.add(<span class="number">0</span>);</span><br><span class="line">        allPathsSourceTarget(graph, <span class="number">0</span>, graph.length - <span class="number">1</span>, path);</span><br><span class="line">        <span class="keyword">return</span> allPaths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allPathsSourceTarget</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> k, <span class="keyword">int</span> n, List&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; currentPath = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">        <span class="keyword">if</span> (k == n) &#123;</span><br><span class="line">            allPaths.add(currentPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : graph[k])&#123;</span><br><span class="line">            currentPath.add(i);</span><br><span class="line">            allPathsSourceTarget(graph, i, n, currentPath);</span><br><span class="line">            currentPath.remove(currentPath.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>有向无环图</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-83 删除排序链表中的重复元素</title>
    <url>/2021/09/11/leetcode-83/</url>
    <content><![CDATA[<p>题目描述：存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p>
<p>返回同样按升序排列的结果链表。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode left = head, right = head.next;</span><br><span class="line">        <span class="keyword">while</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">                left.next = right;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>重复项</tag>
        <tag>有序链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-870 优势洗牌</title>
    <url>/2021/08/26/leetcode-870/</url>
    <content><![CDATA[<p>题目描述：给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] &gt; B[i] 的索引 i 的数目来描述。</p>
<p>返回 A 的任意排列，使其相对于 B 的优势最大化。</p>
<a id="more"></a>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Pair</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Pair o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getValue() - o.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair <span class="title">of</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Pair pair = <span class="keyword">new</span> Pair();</span><br><span class="line">        pair.setIndex(index);</span><br><span class="line">        pair.setValue(value);</span><br><span class="line">        <span class="keyword">return</span> pair;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] advantageCount(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums1.length;</span><br><span class="line">        PriorityQueue&lt;Pair&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((p1, p2) -&gt; p2.compareTo(p1));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            queue.add(Pair.of(i, nums2[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        <span class="keyword">int</span> idx1Start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx1End = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Pair maxPair = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (maxPair.getValue() &lt; nums1[idx1End]) &#123;</span><br><span class="line">                res[maxPair.getIndex()] = nums1[idx1End];</span><br><span class="line">                idx1End--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res[maxPair.getIndex()] = nums1[idx1Start];</span><br><span class="line">                idx1Start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>优势洗牌</tag>
        <tag>田忌赛马</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-875 爱吃香蕉的珂珂</title>
    <url>/2021/08/27/leetcode-875/</url>
    <content><![CDATA[<p>题目描述：珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p>
<p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p>
<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>
<p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = piles.length;</span><br><span class="line">        <span class="keyword">int</span> maxSpeed = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (piles[i] &gt; maxSpeed) &#123;</span><br><span class="line">                maxSpeed = piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = maxSpeed + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> hour = calculateHour(piles, mid);</span><br><span class="line">            <span class="keyword">if</span> (hour == h) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hour &lt; h) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hour &gt; h) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateHour</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hours = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; piles.length; i++) &#123;</span><br><span class="line">            hours += (piles[i] / speed + (piles[i] % speed != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hours;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-876 链表的中间结点</title>
    <url>/2021/09/01/leetcode-876/</url>
    <content><![CDATA[<p>题目描述：给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fastNode = head;</span><br><span class="line">        ListNode slowNode = head;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != <span class="keyword">null</span> &amp;&amp; fastNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fastNode = fastNode.next.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>链表</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-895 最大频率栈</title>
    <url>/2021/08/21/leetcode-895/</url>
    <content><![CDATA[<p>题目描述：实现 FreqStack，模拟类似栈的数据结构的操作的一个类。</p>
<p>FreqStack 有两个函数：</p>
<ul>
<li>push(int x)，将整数 x 推入栈中。</li>
<li>pop()，它移除并返回栈中出现最频繁的元素。<br>如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。</li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>```java<br>class FreqStack {<br>    // 记录 FreqStack 中元素的最大频率<br>    private int maxFreq = 0;<br>    // 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表<br>    private HashMap&lt;Integer, Integer&gt; valToFreq = new HashMap&lt;&gt;();<br>    // 记录频率 freq 对应的 val 列表，后文就称为 FV 表<br>    private HashMap&lt;Integer, Stack<Integer>&gt; freqToVals = new HashMap&lt;&gt;();</p>
<pre><code>public FreqStack() &#123;
&#125;

public void push(int val) &#123;
    //1. 计算每个元素出现的频率
    int frequency = this.valToFreq.getOrDefault(val, 0);
    frequency++;
    this.valToFreq.put(val, frequency);

    //2. 计算最大频率
    maxFreq = maxFreq &gt;= frequency ? maxFreq : frequency;

    //3. 计算频率对应元素栈
    Stack&lt;Integer&gt; valStack = this.freqToVals.getOrDefault(frequency, new Stack&lt;&gt;());
    valStack.add(val);
    this.freqToVals.put(frequency, valStack);
&#125;

public int pop() &#123;
    //1. 取出弹出元素
    int val = this.freqToVals.get(maxFreq).pop();

    //2. 重新计算当前元素频率
    int frequency = this.valToFreq.get(val);
    frequency--;
    this.valToFreq.put(val, frequency);

    //3. 当前频率已经没有元素了，需要重新计算最大频率
    if (this.freqToVals.get(maxFreq).isEmpty()) &#123;
        maxFreq = frequency;
    &#125;
    return val;
&#125;
</code></pre>
<p>}<br>```</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度困难</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 92 反转链表 II</title>
    <url>/2021/03/28/leetcode-92/</url>
    <content><![CDATA[<p>题目描述：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<a id="more"></a>



<h2 id="原题介绍"><a href="#原题介绍" class="headerlink" title="原题介绍"></a>原题介绍</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><div><div class="graphviz">digraph leetcode_92_1 {
    
    bgcolor="#f7f7f7"

<pre><code>rankdir=LR
subgraph cluster_name &#123;
    
    subgraph cluster_1 &#123;
        n0 [label=&quot;1&quot; shape=circle,color=blue,fillcolor=white,style=filled]
        n1 [label=&quot;2&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        n2 [label=&quot;3&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        n3 [label=&quot;4&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        n4 [label=&quot;5&quot; shape=circle,color=blue,fillcolor=white,style=filled]
        rank=same;
        n0 -&gt; n1 -&gt; n2 -&gt; n3 -&gt; n4 
        style=invis
    &#125;

    subgraph cluster_2 &#123;
        r0 [label=&quot;1&quot; shape=circle,color=blue,fillcolor=white,style=filled]
        r1 [label=&quot;4&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        r2 [label=&quot;3&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        r3 [label=&quot;2&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        r4 [label=&quot;5&quot; shape=circle,color=blue,fillcolor=white,style=filled]

        rank=same;
        r0 -&gt; r1 -&gt; r2 -&gt; r3 -&gt; r4 
        style=invis
    &#125;    

    n2 -&gt; r2[constraint=false,color=&quot;red&quot;,pad=30]    

&#125;

label=&lt;&lt;B&gt;图 1.1 算法示意图&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入：head</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]<span class="string">,</span> <span class="string">left</span> <span class="string">=</span> <span class="number">2</span><span class="string">,</span> <span class="string">right</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line"><span class="string">输出：[1,4,3,2,5]</span></span><br></pre></td></tr></table></figure>



<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入：head</span> <span class="string">=</span> [<span class="number">5</span>]<span class="string">,</span> <span class="string">left</span> <span class="string">=</span> <span class="number">1</span><span class="string">,</span> <span class="string">right</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="string">输出：[5]</span></span><br></pre></td></tr></table></figure>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="遍历拆分链表"><a href="#遍历拆分链表" class="headerlink" title="遍历拆分链表"></a>遍历拆分链表</h3><p>如下图所示，通过遍历以 <code>[left，right]</code>作为分界，把链表分为三个字表。</p>
<div><div class="graphviz">digraph leetcode_92_1 {
    
    bgcolor="#f7f7f7"

<pre><code>rankdir=LR
subgraph cluster_name &#123;
    subgraph cluster_1 &#123;
        n0 [label=&quot;1&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n1 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n2 [label=&quot;left-1&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n3 [label=&quot;left&quot; shape=circle,color=red,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n4 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n5 [label=&quot;right&quot; shape=circle,color=red,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n6 [label=&quot;right+1&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n7 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n8 [label=&quot;n&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        rank=same;
        n0 -&gt; n1 -&gt; n2
        n2 -&gt; n3[style=dashed,color=red]
        n3 -&gt; n4 -&gt; n5
        n5 -&gt; n6[style=dashed,color=red]
        n6 -&gt; n7 -&gt; n8
        style=invis
    &#125;

&#125;
label=&lt;&lt;B&gt;图 2.1 遍历拆分链表&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<h3 id="分别处理三个子表"><a href="#分别处理三个子表" class="headerlink" title="分别处理三个子表"></a>分别处理三个子表</h3><blockquote>
<ul>
<li>记录左边链表的head与end，记录右边链表的head。</li>
<li>遍历中间链表存入到栈当中，然后依次弹出栈中节点并链接为一个新的链表，根据栈后进先出的特性，新链表必定顺序是反过来的。</li>
<li>然后再依次按照左中右顺序拼接合并三个链表，得到最终结果。</li>
</ul>
</blockquote>
<div><div class="graphviz">digraph leetcode_92_1 {
    
    bgcolor="#f7f7f7"

<pre><code>rankdir=LR
subgraph cluster_name &#123;
    subgraph cluster_1 &#123;
        n0 [label=&quot;1&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n1 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n2 [label=&quot;left-1&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n3 [label=&quot;right&quot; shape=circle,color=red,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n4 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n5 [label=&quot;left&quot; shape=circle,color=red,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n6 [label=&quot;right+1&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n7 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n8 [label=&quot;n&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        rank=same;
        n0 -&gt; n1 -&gt; n2
        n2 -&gt; n3[style=dashed,color=red]
        n3 -&gt; n4 -&gt; n5
        n5 -&gt; n6[style=dashed,color=red]
        n6 -&gt; n7 -&gt; n8
        style=invis
    &#125;

&#125;
label=&lt;&lt;B&gt;图 2.2 最终结果&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 如果链表为空或者是单节点链表直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 初始化节点栈</span></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 初始化左链表的end节点</span></span><br><span class="line">        ListNode leftLinkedListEnd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 初始化右链表的start节点</span></span><br><span class="line">        ListNode rightLinkedListStart = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 定义链表索引，并初始化为1</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 循环遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (ListNode it = head; it != <span class="keyword">null</span>; it = it.next,idx++)&#123;</span><br><span class="line">            <span class="comment">//6.1 如果是处于[left,right]之间的节点，则存入栈中</span></span><br><span class="line">            <span class="keyword">if</span> ( idx &gt;= left &amp;&amp; idx &lt;= right)&#123;</span><br><span class="line">                stack.push(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6.2 如果是处于[1,left)之间的节点，则记录其end节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (idx &lt; left)&#123;</span><br><span class="line">                leftLinkedListEnd = it;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6.3 如果是处于(right,n]之间的节点，则记录其start节点，并跳出循环结束遍历</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rightLinkedListStart = it;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 依次弹出栈中元素反转中间链表</span></span><br><span class="line">        ListNode midLinkedListHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode midLinkedListEnd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (midLinkedListHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">                midLinkedListHead = stack.pop();</span><br><span class="line">                midLinkedListEnd = midLinkedListHead;</span><br><span class="line">                midLinkedListEnd.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                midLinkedListEnd.next = stack.pop();</span><br><span class="line">                midLinkedListEnd = midLinkedListEnd.next;</span><br><span class="line">                midLinkedListEnd.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8. 合并左链表</span></span><br><span class="line">        <span class="keyword">if</span> (leftLinkedListEnd != <span class="keyword">null</span>)&#123;</span><br><span class="line">            leftLinkedListEnd.next = midLinkedListHead;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            head = midLinkedListHead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9. 合并右链表</span></span><br><span class="line">        <span class="keyword">if</span> (rightLinkedListStart != <span class="keyword">null</span>)&#123;</span><br><span class="line">            midLinkedListEnd.next = rightLinkedListStart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//10. 返回最终链表head节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 临时节点</span></span><br><span class="line">    <span class="keyword">private</span> ListNode node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2. 判空处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 递归处理</span></span><br><span class="line">        <span class="keyword">return</span> reverse(head, left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reverse 前n个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n    前n个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. n==1表示一个元素直接返回，并记录后区节点</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.node = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 递归得到head.next后面的反转</span></span><br><span class="line">        ListNode end = reverse(head.next, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 反转 head 和 end</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 新的尾节点指向保存的后驱节点</span></span><br><span class="line">        head.next = <span class="keyword">this</span>.node;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reverse 中间n个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head  表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 有边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 如果left == 1 递归反转前n个元素</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> reverse(head, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 递归找到待反转起始位置</span></span><br><span class="line">        head.next = reverse(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" title="原题地址">原题地址</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-95 不同的二叉搜索树 II</title>
    <url>/2021/08/08/leetcode-95/</url>
    <content><![CDATA[<p>题目描述：给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; root = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (end &gt; start) &#123;</span><br><span class="line">            root.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt;= end; idx++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftTree = generateTrees(start, idx - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightTree = generateTrees(idx + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span> (TreeNode leftNode : leftTree) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode rightNode : rightTree) &#123;</span><br><span class="line">                    TreeNode rootNode = <span class="keyword">new</span> TreeNode(idx);</span><br><span class="line">                    rootNode.left = leftNode;</span><br><span class="line">                    rootNode.right = rightNode;</span><br><span class="line">                    root.add(rootNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-96 不同的二叉搜索树</title>
    <url>/2021/08/07/leetcode-96/</url>
    <content><![CDATA[<p>题目描述：给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt;= start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt;= end; idx++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftTreeStart = start;</span><br><span class="line">            <span class="keyword">int</span> leftTreeEnd = idx - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightTreeStart = idx + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightTreeEnd = end;</span><br><span class="line">            <span class="keyword">int</span> leftNum = (leftTreeEnd - leftTreeStart &lt; <span class="number">1</span>) ? <span class="number">1</span> : numTrees(leftTreeStart, leftTreeEnd);</span><br><span class="line">            <span class="keyword">int</span> rightNum = (rightTreeEnd - rightTreeStart &lt; <span class="number">1</span>) ? <span class="number">1</span> : numTrees(rightTreeStart, rightTreeEnd);</span><br><span class="line">            sum += leftNum * rightNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-98 验证二叉搜索树</title>
    <url>/2021/08/13/leetcode-98/</url>
    <content><![CDATA[<p>题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树搜索树</tag>
        <tag>验证</tag>
      </tags>
  </entry>
  <entry>
    <title>反转单链表的前n个元素</title>
    <url>/2021/04/01/reverse-linked-list-top-n/</url>
    <content><![CDATA[<p>反转单链表的前n个元素与反转单链表是类似的问题，同理其也会有三种方法去解决。可以增加一个栈来解决，这样相当于只对前n个元素进行压栈处理，同理也可以用遍历的方法解决，由于能用栈解决同样也就可以使用递归的方式解决。</p>
<a id="more"></a>

<h2 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h2><h2 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h2><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>难度中等</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/03/30/reverse-linked-list/</url>
    <content><![CDATA[<p>单链表的反转，我们能想到反转顺序最简单的数据结构就是栈了，如果可以用栈的话，那问题就简单了。顺序遍历单链表，依次入栈直到遍历结束，然后依次出栈重新有前到后连接为一个新的单链表，则自动实现了反转功能。</p>
<a id="more"></a>

<h2 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 遍历链表入栈</span></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 出栈重新建立链表</span></span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode newEnd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (newHead == <span class="keyword">null</span>)&#123;</span><br><span class="line">                newHead = node;</span><br><span class="line">                newEnd = newHead;</span><br><span class="line">                newHead.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                newEnd.next = node;</span><br><span class="line">                newEnd = newEnd.next;</span><br><span class="line">                newEnd.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h2><h3 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h3><div><div class="graphviz">digraph leetcode_92_1 {
    
    bgcolor="#f7f7f7"

<pre><code>rankdir=LR
subgraph cluster_name &#123;
    subgraph cluster_1 &#123;
        n0 [label=&quot;newEnd&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n1 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n2 [label=&quot;newHead&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n3 [label=&quot;node&quot; shape=circle,color=red,style=dashed,width=0.8,fixedsize=true]
        n4 [label=&quot;oldHead&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n5 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n6 [label=&quot;oldEnd&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        
        rank=same;
        n0 -&gt; n1 -&gt; n2[dir=back]
        n2 -&gt; n3[style=dashed,color=&quot;#f7f7f7&quot;]
        n3 -&gt; n4[style=dashed,color=red]
        n4 -&gt; n5 -&gt; n6
        style=invis
    &#125;

&#125;
label=&lt;&lt;B&gt;图 1.1 遍历反转链表&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 设置反转后新链表表头节点</span></span><br><span class="line">        ListNode newLinkedListHead = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 设置反转前旧链表表头节点</span></span><br><span class="line">        ListNode oldLinkedListHead = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 设置临时节点</span></span><br><span class="line">        ListNode tmpNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 遍历旧链表</span></span><br><span class="line">        <span class="keyword">while</span> (oldLinkedListHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//5.1 取出当前节点到临时节点</span></span><br><span class="line">            tmpNode = oldLinkedListHead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.2 重新设置旧链表表头</span></span><br><span class="line">            oldLinkedListHead = oldLinkedListHead.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.3 把取出的临时节点添加到反转后新链表的表头</span></span><br><span class="line">            <span class="keyword">if</span> (newLinkedListHead == <span class="keyword">null</span>)&#123;</span><br><span class="line">                newLinkedListHead = tmpNode;</span><br><span class="line">                newLinkedListHead.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                tmpNode.next = newLinkedListHead;</span><br><span class="line">                newLinkedListHead = tmpNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6. 返回反转后新链表</span></span><br><span class="line">        <span class="keyword">return</span> newLinkedListHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p>递归实现的原理和栈是类似的，因为递归本身就是利用了程序栈进行了压栈处理，因此好好理解一下第一种算法与第三种算法，有助于理解递归的原理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取递归得到的新表头</span></span><br><span class="line">        ListNode newHead = reverse(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 处理当前节点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 处理完之后新的尾节点置空</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 返回新的表头节点</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>难度中等</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>旅途的起点</title>
    <url>/2020/10/24/%E6%97%85%E9%80%94%E7%9A%84%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<p>今天刚把博客网站初步搭建好，从学生时代，到现在工作两年，一直以来都想好好写博客，写一些生活的感悟，以及技术上的文章。</p>
<a id="more"></a>


<h2 id="写博客背景"><a href="#写博客背景" class="headerlink" title="写博客背景"></a>写博客背景</h2><p>之前有在csdn上写博客的经历，但那是大学时候的事情了，后来也没有坚持下来。在快毕业的时候，同学买了一个博客视频，教你如何一步一步搭建自己的博客网站，那时候感觉搭建自己的网站挺新鲜的，然后尝试了之后，依然是半途而废。毕业之后，从事互联网工作，在国内某盛名996厂，不过有些名不符实，996没有，995到时不少。平时时间并不宽裕，因此也没有太多时间写博客。可能有人要问了，那为什么在工作两年之后，突然想到开始写博客了呢？原因之一是因为这一直以来是我自己非常想做的一件事情吧。事实证明，自己想了很久而没做的事情，即使过了很久，但是只要契机到了，你依然回去做。那么我这次开始写博客的契机又是什么呢？因为工作快二年半了，工作部门最近似乎也有些变动，有些不安吧。希望能在这大半年的时间里，好好整理一下所学习的知识，为可能的改变做准备吧。</p>
<h2 id="写博客的目的"><a href="#写博客的目的" class="headerlink" title="写博客的目的"></a>写博客的目的</h2><p>写博客主要为了记录生活的点滴，人生感悟以及作为一个技术宅的所学吧，算是对自己人生的一个整理吧。古有三十而立，想想我也是一个快而立之年的人了，总归要好好思考未来的人生道路该怎么走。平时工作忙的时候倒没觉得，但是一旦放假闲下来的时候，时常想一些奇奇怪怪的事情。人生想想还挺短暂的，也许未来还有四十年可活，也只有1万多天，如果每天能写一篇博客的话，余生还能写一万多篇博客。这未尝不是一件有趣的事情。人生嘛，说短不过几十载，说长嘛，还挺长的，总归要做一些有趣的事情，为单调重复的生活增添一些味道。博客能够帮助我们记录平凡的点滴，以及多彩的瞬间。此时正是英雄联盟S10之际，青春慢慢远去，我们的人生不能像英雄联盟一样可以随时重启，引用英雄联盟中的一句台词，我想对自己说，没有撤退可言。</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法序言</title>
    <url>/2021/03/21/%E7%AE%97%E6%B3%95%E5%BA%8F%E8%A8%80/</url>
    <content><![CDATA[<p>有一种观点认为，程序等于数据结构加算法，但是懂得了数据结构与算法并不一定能写出好的程序。本文主要介绍后面文章会用到的一些基本数据结构。</p>
<a id="more"></a>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>后面统一使用如下异常类，处理抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgorithmException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlgorithmException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlgorithmException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误码定义类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorCode4Algorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ErrorCode4Algorithm</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 越界异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INDEX_OUT_OF_RANGE = <span class="string">&quot;INDEX_OUT_OF_RANGE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未重写异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NOT_IMPLEMENT_EXCEPTION = <span class="string">&quot;NOT_IMPLEMENT_EXCEPTION&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="一维节点定义"><a href="#一维节点定义" class="headerlink" title="一维节点定义"></a>一维节点定义</h2><p>所有一维单链表统一如下节点进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.SuperBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向下一个节点的指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>序言</tag>
      </tags>
  </entry>
  <entry>
    <title>队列与栈一</title>
    <url>/2021/03/22/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E4%B8%80/</url>
    <content><![CDATA[<p>线性表是最基本的数据结构之一，其最终的物理结构不外乎两种，顺序表与链表。队列与栈都是线性表，只是其外在的逻辑表现形式不同而已。</p>
<a id="more"></a>

<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>顺序表是一种在物理上连续存储的结构，也即顺序表的元素在内存空间里是物理上连续的。</p>
<div><div class="graphviz">digraph array_list{

<pre><code>bgcolor=&quot;#f7f7f7&quot;

subgraph cluster_array &#123;


    node [shape=record, fontcolor=black,width=4.75, fixedsize=true];
    pointers[] [label=&quot;&lt;p0&gt; A+0 | &lt;p1&gt; A+1 | &lt;p2&gt; A+2 | &lt;p3&gt; A+3 | &lt;p4&gt; A+4 | &lt;p5&gt; A+5 | &lt;p6&gt; A+6 | &lt;p7&gt; A+7&quot;, color=blue];
    values [label=&quot;&lt;v0&gt; A[0] | &lt;v1&gt; A[1] | &lt;v2&gt; A[2] | &lt;v3&gt; A[3] | &lt;v4&gt; A[4] | &lt;v5&gt; A[5] | &lt;v6&gt; A[6] | &lt;v7&gt; A[7]&quot;, color=blue, fillcolor=lightblue, style=filled];
    indices [label=&quot;0 | 1 | 2 | 3| 4 | 5 | 6 | 7&quot;, color=&quot;#f7f7f7&quot;];

    node [shape=plaintext, fontcolor=&quot;black&quot;,width=1 fontsize=18,fixedsize=true];
    &quot;Pointers:&quot; -&gt; &quot;Values:&quot; -&gt; &quot;Indices:&quot;[color=&quot;#f7f7f7&quot;];

    &#123; rank=same; &quot;Pointers:&quot;; pointers &#125;
    &#123; rank=same; &quot;Values:&quot;; values &#125;
    &#123; rank=same; &quot;Indices:&quot;; indices &#125;   
&#125;

label = &lt;&lt;B&gt;图 1.1 顺序表&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种在逻辑空间上连续，但是物理空间上离散的线性表。链表前后节点使用指针相连，因此与线性表相比，链表需要更多的存储空间，但是却能更有效的利用空间，因为顺序表对存储要求必须是物理上一整块的空间。</p>
<div><div class="graphviz">digraph list_linked {
    
    bgcolor="#f7f7f7"

<pre><code>rankdir=LR
subgraph cluster_name &#123;
    n0 [label=&quot;&#123;&lt;data&gt;A[0]|&lt;next&gt;&#125;&quot; shape=record,color=blue,fillcolor=lightblue,style=filled]
    n1 [label=&quot;&#123;&lt;data&gt;A[1]|&lt;next&gt;&#125;&quot; shape=record,color=blue,fillcolor=lightblue,style=filled]
    n2 [label=&quot;&#123;&lt;data&gt;A[2]|&lt;next&gt;&#125;&quot; shape=record,color=blue,fillcolor=lightblue,style=filled]
    n3 [label=&quot;&#123;&lt;data&gt;A[3]|&lt;next&gt;&#125;&quot; shape=record,color=blue,fillcolor=lightblue,style=filled]
    n4 [label=&quot;&#123;&lt;data&gt;A[4]|&lt;next&gt;nil&#125;&quot; shape=record,color=blue,fillcolor=lightblue,style=filled]
 
    n0:next:0 -&gt; n1:data [tailclip=false,solid=true]
    n1:next:0 -&gt; n2:data [tailclip=false,solid=true]
    n2:next:0 -&gt; n3:data [tailclip=false,solid=true]
    n3:next:0 -&gt; n4:data [tailclip=false,solid=true]
&#125;

label=&lt;&lt;B&gt;图 2.1 链表&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<h2 id="线性表接口"><a href="#线性表接口" class="headerlink" title="线性表接口"></a>线性表接口</h2><p>线性表的基本接口，主要定义常见的几种方法，弹出元素、添加元素、线性表大小、获取线性表第一个元素、获取线性表最后一个元素以及对线性表进行判空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线性表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 弹出元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回线性表大小</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线性表大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 第一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">fist</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回最后一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是空线性表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否是空线性表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AlgorithmException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="抽象实现类"><a href="#抽象实现类" class="headerlink" title="抽象实现类"></a>抽象实现类</h2><p>统一处理异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.queue.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>栈</tag>
        <tag>线性表</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>队列与栈三</title>
    <url>/2021/03/27/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E4%B8%89/</url>
    <content><![CDATA[<p>栈也是一种常见的数据结构，栈的特点就是后进先出。</p>
<a id="more"></a>

<h2 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.statck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.AbstractList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_STACK_SIZE = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ArrayStack&lt;T&gt;(DEFAULT_STACK_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) stack[<span class="keyword">this</span>.size--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.length == <span class="keyword">this</span>.size) &#123;</span><br><span class="line">            resize(<span class="keyword">this</span>.stack, <span class="keyword">this</span>.size + DEFAULT_STACK_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stack[<span class="keyword">this</span>.size++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>.stack[<span class="keyword">this</span>.size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>.stack[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resize stack</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldStack old stack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newSize  new size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(Object[] oldStack, <span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        Object[] newStack = <span class="keyword">new</span> Object[newSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            newStack[i] = oldStack[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stack = newStack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="栈的链表实现"><a href="#栈的链表实现" class="headerlink" title="栈的链表实现"></a>栈的链表实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.statck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.AbstractList;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.node.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListNode&lt;T&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈底</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListNode&lt;T&gt; end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init stack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">this</span>.head.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.setVal(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode&lt;T&gt; currentNode = <span class="keyword">this</span>.end;</span><br><span class="line">        <span class="keyword">while</span> (currentNode.getNext() != <span class="keyword">this</span>.head) &#123;</span><br><span class="line">            currentNode = currentNode.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        T t = <span class="keyword">this</span>.head.getVal();</span><br><span class="line">        <span class="keyword">this</span>.head = currentNode;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        ListNode&lt;T&gt; newNode = <span class="keyword">new</span> ListNode&lt;T&gt;();</span><br><span class="line">        newNode.setVal(t);</span><br><span class="line">        newNode.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.setNext(newNode);</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.getNext();</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.end.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head == <span class="keyword">this</span>.end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>栈</tag>
        <tag>线性表</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>队列与栈二</title>
    <url>/2021/03/27/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E4%BA%8C/</url>
    <content><![CDATA[<p>队列是一种常见的数据结构，在生活中有很多应用场景，例如排队系统，常见的各种MQ基本上都算队列，队列的一个原则就是先进先出，保证了公平性。</p>
<a id="more"></a>



<h2 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h2><p>队列的数组实现方式如下，数组实现的有点在于每次出队都要进行大量元素的腾挪操作，非常耗时。并且当进行入队操作时，初始分配的队列长度不够的时候，需要申请一块更大的空间来腾挪旧的元素，再插入新元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.AbstractList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_QUEUE_SIZE = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ArrayQueue&lt;T&gt;(DEFAULT_QUEUE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        T t = (T) <span class="keyword">this</span>.queue[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue[i - <span class="number">1</span>] = <span class="keyword">this</span>.queue[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="keyword">this</span>.queue.length) &#123;</span><br><span class="line">            resize(<span class="keyword">this</span>.queue, <span class="keyword">this</span>.size + <span class="keyword">this</span>.DEFAULT_QUEUE_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue[<span class="keyword">this</span>.size++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>.queue[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>.queue[<span class="keyword">this</span>.size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resize array</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldQueue old queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newSize  new size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(Object[] oldQueue, <span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        Object[] newQueue = <span class="keyword">new</span> Object[newSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            newQueue[i] = oldQueue[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue = newQueue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="队列的链式实现"><a href="#队列的链式实现" class="headerlink" title="队列的链式实现"></a>队列的链式实现</h2><p>队列的链式实现如下，链式队列适合进行频繁的插入删除操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.AbstractList;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.node.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListNode&lt;T&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListNode&lt;T&gt; end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        T t = <span class="keyword">this</span>.head.getVal();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.getNext();</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.end.setVal(t);</span><br><span class="line">        ListNode&lt;T&gt; newEnd = <span class="keyword">new</span> ListNode&lt;T&gt;();</span><br><span class="line">        <span class="keyword">this</span>.end.setNext(newEnd);</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">this</span>.end.getNext();</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">this</span>.head.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.setVal(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span> || <span class="keyword">this</span>.head == <span class="keyword">this</span>.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.end.getVal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>栈</tag>
        <tag>线性表</tag>
        <tag>队列</tag>
      </tags>
  </entry>
</search>
