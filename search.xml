<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/10/25/BubbleSort/</url>
    <content><![CDATA[<p>冒泡排序（英语：Bubble Sort）又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误&gt;就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”&gt;到数列的顶端。</p>
<a id="more"></a>
<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>依次比较两个相邻的元素，如果它们顺序错误，则交换，最终大数会沉向尾部。重复上面的步骤知道数组有序，下面以正序为例进行详细说明整个过程。</p>
</blockquote>
<p>原数据：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">9</span>] [<span class="number">8</span>] [<span class="number">7</span>] [<span class="number">1</span>] [<span class="number">3</span>] [<span class="number">5</span>]</span><br></pre></td></tr></table></figure></p>
<p>第一步：比较<font color="red">[9]</font>和<font color="red">[8]</font>，由于<font color="red">[9]</font>大于<font color="red">[8]</font>，按照正序逻辑<font color="red">[9]</font>在后面，因此需要交换它们的位置，得到新的数组如下所示。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">8</span>] [<span class="number">9</span>] [<span class="number">7</span>] [<span class="number">1</span>] [<span class="number">3</span>] [<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>第二步：比较比较<font color="red">[9]</font>和<font color="red">[7]</font>，同理需要交换它们的位置，得到新的数组如下所示。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">8</span>] [<span class="number">7</span>] [<span class="number">9</span>] [<span class="number">1</span>] [<span class="number">3</span>] [<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>依次比较原理同上，直到最后一组元素相邻元素比较之后，我们可以得到第一轮冒泡之后的结果，如下所示，可以很明显看到元素<font color="red">[9]</font>最终沉到了尾部，因为它是正序里面最大的结果。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">8</span>] [<span class="number">7</span>] [<span class="number">1</span>] [<span class="number">3</span>] [<span class="number">5</span>] [<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>同理我们进行第二轮冒泡，会将<font color="red">[8]</font>沉到元素尾部，得到如下结果，这里需要注意，由于第一轮冒泡，已经把最大的元素<font color="red">[9]</font>放到了最后一个位置，第二轮冒泡则无需和<font color="red">[9]</font>进行比较，就可以把<font color="red">[8]</font>放到倒数第二的位置。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>] [<span class="number">1</span>] [<span class="number">3</span>] [<span class="number">5</span>] [<span class="number">8</span>] [<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>最终在经过了n-1轮冒泡之后（n为元素个数），我们可以最终得到一个有序的数组。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>] [<span class="number">3</span>] [<span class="number">5</span>] [<span class="number">7</span>] [<span class="number">8</span>] [<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>冒泡排序是稳定的排序算法，其时间复杂度计算公式如下。可以看到冒泡排序，最好的情况与最坏的情况下，时间复杂度均为2^n，空间复杂度为1，平均时间复杂度为2^n。</p>
</blockquote>
<script type="math/tex; mode=display">
(n-1) + (n-2) + (n-3) + ... + 1 = ((n-1) + 1) * (n-1) / 2 = \frac{n * (n-1)}{2}</script><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>less函数与exch函数参见文章排序算法序言。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(less(c[j+<span class="number">1</span>], c[j]))&#123;</span><br><span class="line">                exch(c, j, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>冒泡排序</tag>
        <tag>数据结构与算法</tag>
        <tag>稳定排序</tag>
      </tags>
  </entry>
  <entry>
    <title>CVN2是什么</title>
    <url>/2022/04/10/CVN2%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>cvn2全称是Card Verification Numnber 2，也即卡验证码，是银联信用卡安全码的名称，当前国际上不同的信用卡组织的叫法并不相同。</p>
<a id="more"></a>
<h2 id="一、cvn2是什么"><a href="#一、cvn2是什么" class="headerlink" title="一、cvn2是什么"></a>一、cvn2是什么</h2><blockquote>
<p><code>VISA</code> 的安全码叫做CVV2（Card Verification Value 2），有3位数字，平印在信用卡背面签名栏上卡号后4位处。</p>
<p><code>MasterCard</code>的安全码叫做CVC2（Card Validation Code 2），有3位数字，平印在信用卡背面签名栏上卡号后4位处。</p>
<p><code>Discover Card</code>的安全码叫做Cardmember ID，有3位数字，平印在信用卡背面签名栏上。</p>
<p><code>American Express</code>的安全码叫做CID（Card Identification Number），有4位数字，平印在信用卡正面信用卡卡号上方。</p>
<p><code>China UnionPay</code>的安全码叫做CVN2（Card Validation Number 2），有3位数字，平印在信用卡背面签名栏上卡号后4位处之后。</p>
<p><code>Japan Credit Bureau</code>的安全码叫做CAV2（ Card Authentication Value 2），有3位数字，平印在信用卡背面签名栏上卡号后4位处。</p>
</blockquote>
<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/visa.png" alt="visa"></p>
]]></content>
      <categories>
        <category>支付</category>
      </categories>
      <tags>
        <tag>支付</tag>
        <tag>银联卡</tag>
        <tag>支付三要素</tag>
        <tag>信用卡</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/10/28/HillSort/</url>
    <content><![CDATA[<p>希尔排序（Shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。根据设计者希尔（Donald Shell）的名字命名，该算法由1959年公布。</p>
<a id="more"></a>
<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>假定步长为h，则把数组分为h组，从前往后间隔h的元素为一组。先在组内进行插入排序，保证每个组内是有序的，再按照步长为1进行一次全面插入排序，从而得到有序数组。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9] [8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>
<p>第一步，假设h为<code>3</code>，则根据规则原数组分为如下三组</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9] [1]</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[8] [3]</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [5]</span><br></pre></td></tr></table></figure>
<p>第二步，在三个小组内，分别进行插入排序，得到三个有序子数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [9]</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [8]</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[5] [7]</span><br></pre></td></tr></table></figure>
<p>第三步，三个子数组按照原来的位置存放，得到第一轮排序后的数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [9] [8] [7]</span><br></pre></td></tr></table></figure>
<p>第四步，按照步长为<code>[1]</code>进行一次插入排序，即可得到有序数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9]</span><br></pre></td></tr></table></figure>
<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>希尔排序是一个不稳定的排序算法，其最好情况下时间复杂度为<code>O(n)</code>，最坏情况下时间复杂度为<code>2^n</code>，平均时间复杂度为<code>2^n</code>，空间复杂度为<code>O(!)</code>。时间复杂度计算公式如下。</p>
</blockquote>
<script type="math/tex; mode=display">
待补充</script><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Shell</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &lt; N / <span class="number">3</span>)&#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(c[j], c[j-h]); j -= h)&#123;</span><br><span class="line">                exch(c, j, j-h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>希尔排序</tag>
        <tag>不稳定排序</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2020/10/25/InsertSort/</url>
    <content><![CDATA[<p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐&gt;步向后挪位，为最新元素提供插入空间。</p>
<a id="more"></a>
<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>每次从剩余的未排序的元素中选取一个元素插入到前面已排序的元素中，使整体有序。下面以正序为例说明整个过程。</p>
</blockquote>
<p>原数据：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">9</span>] [<span class="number">8</span>] [<span class="number">7</span>] [<span class="number">1</span>] [<span class="number">3</span>] [<span class="number">5</span>]</span><br></pre></td></tr></table></figure></p>
<p>第一步：选择<font color="red">[9]</font>插入到前面已排序的元素中，由于是第一个元素，已经排序好了。可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9] [8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>
<p>未排序<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure></p>
<p>已排序<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9]</span><br></pre></td></tr></table></figure></p>
<p>第二步：选择<font color="red">[8]</font>插入到前面已排序的元素中，<font color="red">[8]</font>比<font color="red">[9]</font>小，因此在<font color="red">[9]</font>前面，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[8] [9] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>
<p>未排序<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [1] [3] [5]</span><br></pre></td></tr></table></figure></p>
<p>已排序<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[8] [9]</span><br></pre></td></tr></table></figure></p>
<p>第三步：选择<font color="red">[7]</font>插入到前面已排序的元素中，<font color="red">[7]</font>比<font color="red">[8]</font>小，因此在<font color="red">[8]</font>前面，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [8] [9] [1] [3] [5]</span><br></pre></td></tr></table></figure>
<p>未排序<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5]</span><br></pre></td></tr></table></figure></p>
<p>已排序<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [8] [9]</span><br></pre></td></tr></table></figure></p>
<p>第四步：选择<font color="red">[1]</font>插入到前面已排序的元素中，<font color="red">[1]</font>比<font color="red">[7]</font>小，因此在<font color="red">[7]</font>前面，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [7] [8] [9] [3] [5]</span><br></pre></td></tr></table></figure>
<p>未排序<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [5]</span><br></pre></td></tr></table></figure></p>
<p>已排序<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [7] [8] [9]</span><br></pre></td></tr></table></figure></p>
<p>第五步：选择<font color="red">[3]</font>插入到前面已排序的元素中，<font color="red">[3]</font>小于<font color="red">[7]</font>大于<font color="red">[1]</font>，因此<font color="red">[3]</font>在<font color="red">[1]</font>和<font color="red">[7]</font>之间，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [7] [8] [9] [5]</span><br></pre></td></tr></table></figure>
<p>未排序<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[5]</span><br></pre></td></tr></table></figure></p>
<p>已排序<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [7] [8] [9]</span><br></pre></td></tr></table></figure></p>
<p>第六步：同理插入<font color="red">[5]</font>，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9]</span><br></pre></td></tr></table></figure>
<p>未排序<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>已排序<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9]</span><br></pre></td></tr></table></figure></p>
<p>最终得到一个正序数组。</p>
<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>插入排序是稳定的排序算法，其时间复杂度计算公式如下。可以看到插入排序最好的情况时间复杂度为n，最坏的情况下时间复杂度均为2^n，空间复杂度为O(1)，平均时间复杂度为2^n。</p>
</blockquote>
<script type="math/tex; mode=display">
k1 + k2 + k3 + k4 + ... kn = \sum_{k=1}^{n}{k_n} (1 <= k1,k2,...,kn <= n-1)</script><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(c[j], c[j-<span class="number">1</span>]); j--)&#123;</span><br><span class="line">            exch(c, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>稳定排序</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql主从配置</title>
    <url>/2022/04/15/Mysql%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><code>Mysql Replication</code>，可以实现将数据从一台数据库服务器复制到另一台或者多台数据库服务器。默认情况下属于异步复制，无需维持长连接，通过配置，可以复制所有的库或者几个甚至其中一些表，并且这些功能都是<code>mysql</code>自带的。</p>
<a id="more"></a>
<h2 id="mysql配置说明"><a href="#mysql配置说明" class="headerlink" title="mysql配置说明"></a>mysql配置说明</h2><p>下面以<code>mysql</code>实例1作为主库，<code>mysql</code>实例2作为从库，其中主库具有增删改查功能，而从库仅仅有查询功能。</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat &gt; /etc/my.cnf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">主库配置</span></span><br><span class="line">server-id=1</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从库配置</span></span><br><span class="line">server-id=10</span><br></pre></td></tr></table></figure>
<h2 id="重启mysql服务"><a href="#重启mysql服务" class="headerlink" title="重启mysql服务"></a>重启mysql服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">杀死mysql服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">kill</span> -9 `ps -ef | grep mysql | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">检查旧mysql服务是否被停止</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ps aux | grep mysql</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动mysql多实例服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mysqld_multi start</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">检查mysql多实例情况</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mysqld_multi report</span></span><br></pre></td></tr></table></figure>
<h2 id="配置主库"><a href="#配置主库" class="headerlink" title="配置主库"></a>配置主库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">登录主库mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash">/usr/bin/mysql -S /data/mysqlsock/mysql.sock1 -p -uroot</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建从库链接的用户，其中xxx为从库用户密码</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE USER <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;xxx&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">授权从库登录用户，同步主库日志文件的权限，其中xxx为密码</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;10.10.10.1&#x27;</span> IDENTIFIED BY <span class="string">&#x27;xxx&#x27;</span>；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看主库状态，并记录File与Position的值</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show master status;</span></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |      437 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">退出从库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置从库"><a href="#配置从库" class="headerlink" title="配置从库"></a>配置从库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">登录从库</span></span><br><span class="line"><span class="meta">$</span><span class="bash">/usr/bin/mysql -S /data/mysqlsock/mysql.sock2 -uroot -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置从库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CHANGE MASTER TO MASTER_HOST=<span class="string">&#x27;10.10.10.1&#x27;</span>, MASTER_USER=<span class="string">&#x27;repl&#x27;</span>,MASTER_PASSWORD=<span class="string">&#x27;xxx&#x27;</span>,MASTER_PORT=3306,MASTER_LOG_FILE=<span class="string">&#x27;mysql-bin.000001&#x27;</span>,MASTER_LOG_POS=437;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动从库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> start slave;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看从库状态</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show slave status\G;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">退出mysql</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span>;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>suse</tag>
        <tag>主从</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql单机多实例</title>
    <url>/2022/04/15/Mysql%E5%8D%95%E6%9C%BA%E5%A4%9A%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p><code>mysql</code>默认端口为<code>3306</code>，因此默认一个机器上只能启动一个<code>mysql</code>实例，如果想要在一台机器上启动多个<code>mysql</code>实例，则需配置单机多实例。<strong><em>本文承接mysql安装教程。</em></strong></p>
<a id="more"></a>
<h2 id="mysql主从规划"><a href="#mysql主从规划" class="headerlink" title="mysql主从规划"></a>mysql主从规划</h2><div class="table-container">
<table>
<thead>
<tr>
<th>主/从库</th>
<th>IP地址</th>
<th>端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>primary（主库）</td>
<td>10.10.10.1</td>
<td>3306</td>
</tr>
<tr>
<td>replica（从库）</td>
<td>10.10.10.2</td>
<td>3306</td>
</tr>
</tbody>
</table>
</div>
<h2 id="创建mysql目录"><a href="#创建mysql目录" class="headerlink" title="创建mysql目录"></a>创建mysql目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建mysql多实例数据库目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir -vp /data/mysql_data&#123;1..2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建mysql sock的文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir /data/mysqlsock</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改mysqlsock文件夹的权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash">chmod 777 /data/mysqlsock/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改文件夹所有者为mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash">chown mysql.mysql -R /var/lib/mysql/mysql-files /data/mysql_data&#123;1..2&#125; /data/mysqlsock</span></span><br></pre></td></tr></table></figure>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">备份配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mv /etc/my.cnf /etc/my.cnf.bak</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建新的配置文件，并添加如下配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cat &gt; /etc/my.cnf</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld_multi]</span><br><span class="line">mysqld=/usr/sbin/mysqld</span><br><span class="line">mysqladmin=/usr/bin/mysqladmin</span><br><span class="line">log=/var/log/mysql/mysql_multi.log</span><br><span class="line"></span><br><span class="line">[mysqld1]</span><br><span class="line">datadir=/data/mysql_data1</span><br><span class="line">socket=/data/mysqlsock/mysql.sock1</span><br><span class="line">port=3306</span><br><span class="line">user=mysql</span><br><span class="line">performance_schema=off</span><br><span class="line">bind_address=0.0.0.0</span><br><span class="line">skip-name-resolve=0</span><br><span class="line"></span><br><span class="line">[mysqld2]</span><br><span class="line">datadir=/data/mysql_data2</span><br><span class="line">socket=/data/mysqlsock/mysql.sock2</span><br><span class="line">port=3307</span><br><span class="line">user=mysql</span><br><span class="line">performance_schema=off</span><br><span class="line">bind_address=0.0.0.0</span><br><span class="line">skip-name-resolve=0</span><br></pre></td></tr></table></figure>
<h2 id="初始化mysql多实例"><a href="#初始化mysql多实例" class="headerlink" title="初始化mysql多实例"></a>初始化mysql多实例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">初始化mysql多实例，搜索root@localhost: xxx，找到初始密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash">/usr/sbin/mysqld --initialize --user=mysql --datadir=/data/mysql_data1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">初始化mysq2多实例，搜索root@localhost: xxx，找到初始密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash">/usr/sbin/mysqld --initialize --user=mysql --datadir=/data/mysql_data2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看已经存在的mysql，并杀死已经存在的mysql教程</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ps aux|grep mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">kill</span> -9 xxx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看mysql运行情况</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mysqld_multi report</span></span><br><span class="line">Reporting MySQL servers</span><br><span class="line">MySQL server from group: mysqld1 is not running</span><br><span class="line">MySQL server from group: mysqld2 is not running</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动mysql多实例</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mysqld_multi start</span></span><br><span class="line">Reporting MySQL servers</span><br><span class="line">MySQL server from group: mysqld1 is running</span><br><span class="line">MySQL server from group: mysqld2 is running</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看服务进程，可以看到前面设置的端口号均已启动</span></span><br><span class="line">ps aux | grep mysql</span><br></pre></td></tr></table></figure>
<h2 id="登录mysql实例"><a href="#登录mysql实例" class="headerlink" title="登录mysql实例"></a>登录mysql实例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录mysql实例1，实例2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">/usr/bin/mysql -S /data/mysqlsock/mysql.sock1 -p<span class="string">&#x27;xxx&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置实例1的密码，xxx为初始密码</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SET PASSWORD=PASSWORD(<span class="string">&#x27;xxx&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出mysql</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span>;</span></span><br></pre></td></tr></table></figure>
<p><code>mysql实例2</code>同样进行初始化，并设置初始密码，这样mysql单机多实例则初始化完成了</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>suse</tag>
        <tag>单机多实例</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx + Keepalived高可用</title>
    <url>/2022/04/15/Nginx-Keepalived%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<p><code>nginx</code>是代理服务器，可以实现后端应用反向代理和负载均衡等功能，并且<code>nginx</code>具有应用健康检查功能，将故障节点从负载均衡池中移除，保证了后端应用的高可用。但是，如果<code>nginx</code>服务器出现问题，则无法对外提供服务。因此，我们必须要考虑到<code>nginx</code>服务的高可用性，一般采用主-主或者主-备的形式部署<code>nginx</code>服务。主机负责对外提供服务和后端应用健康检查，备机仅对后端应用进行健康检查。只有当主机出现问题时，备机才会接管工作。</p>
<a id="more"></a>
<h2 id="网络规划"><a href="#网络规划" class="headerlink" title="网络规划"></a>网络规划</h2><div class="table-container">
<table>
<thead>
<tr>
<th>IP地址</th>
<th>虚拟IP地址</th>
<th>节点</th>
</tr>
</thead>
<tbody>
<tr>
<td>10.10.10.1</td>
<td>20.20.20.1</td>
<td>master</td>
</tr>
<tr>
<td>10.10.10.2</td>
<td>20.20.20.2</td>
<td>backup</td>
</tr>
</tbody>
</table>
</div>
<h2 id="上传安装包"><a href="#上传安装包" class="headerlink" title="上传安装包"></a>上传安装包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建临时目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir -p /home/tmp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">上传安装包</span></span><br><span class="line">keepalived-1.2.17.tar.gz</span><br><span class="line">nginx-1.14.0.tar.gz</span><br><span class="line">openssl-1.1.1.tar.gz</span><br><span class="line">pcre-8.42.tar.gz</span><br><span class="line">zlib-1.2.11.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解压所有安装包</span></span><br><span class="line"><span class="meta">$</span><span class="bash">find . -<span class="built_in">type</span> f | xargs -I file tar -zxvf file</span></span><br></pre></td></tr></table></figure>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><h3 id="安装zlib依赖库"><a href="#安装zlib依赖库" class="headerlink" title="安装zlib依赖库"></a>安装zlib依赖库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入zlib目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/tmp/zlib-1.2.11</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>
<h3 id="安装pcre依赖库"><a href="#安装pcre依赖库" class="headerlink" title="安装pcre依赖库"></a>安装pcre依赖库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入pcre目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/tmp/pcre-8.42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>
<h3 id="升级openssl"><a href="#升级openssl" class="headerlink" title="升级openssl"></a>升级openssl</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看openssl版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash">openssl version</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果低于1.1.1版本，则需要升级</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/tmp/openssl-1.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./config</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make &amp;&amp; make install</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">链接升级后的动态库目录/usr/lib64</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ln -s /usr/<span class="built_in">local</span>/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ln -s /usr/<span class="built_in">local</span>/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看结果</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ls -al /usr/lib64/ | grep -P <span class="string">&#x27;(libssl|libcrypto)&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="安装nginx-1"><a href="#安装nginx-1" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入nginx目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/tmp/nginx-1.14.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --with-http_ssl_module --with-stream</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>
<h3 id="验证nginx"><a href="#验证nginx" class="headerlink" title="验证nginx"></a>验证nginx</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入nginx目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动nginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果找不到libpcre.so.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">刷新配置</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<p>浏览器打开<code>http://ip:80</code></p>
<h2 id="安装keepalived"><a href="#安装keepalived" class="headerlink" title="安装keepalived"></a>安装keepalived</h2><p><code>keepalived</code>的负载均衡框架依赖于<code>Linux</code>虚拟服务器内核模块<code>IPVS</code>，如果没有安装<code>IPVS</code>模块，需要安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看ipvs模块是否安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash">lsmod | grep ip_vs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建ipvs安装文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir -p /usr/<span class="built_in">local</span>/ipvs/</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cp /usr/src/linux/net/netfilter/ipvs/* /usr/<span class="built_in">local</span>/ipvs/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/ipvs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">编译并安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make -C /lib/modules/`uname -f`/build M=/usr/<span class="built_in">local</span>/ipvs modules</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看依赖</span></span><br><span class="line"><span class="meta">$</span><span class="bash">modinfo ip_vs.ko</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">逐一安装依赖以及ipvs模块</span></span><br><span class="line"><span class="meta">$</span><span class="bash">modprobe ipv6_lib</span></span><br><span class="line"><span class="meta">$</span><span class="bash">modprobe nf_conntrack</span></span><br><span class="line"><span class="meta">$</span><span class="bash">modprobe libcrc32c</span></span><br><span class="line"><span class="meta">$</span><span class="bash">modprobe ip6_tables</span></span><br><span class="line"><span class="meta">$</span><span class="bash">modprobe ip_vs.ko</span></span><br><span class="line"><span class="meta">$</span><span class="bash">depmod -a</span></span><br><span class="line"><span class="meta">$</span><span class="bash">modprobe ip_vs</span></span><br></pre></td></tr></table></figure>
<h3 id="安装keepalived-1"><a href="#安装keepalived-1" class="headerlink" title="安装keepalived"></a>安装keepalived</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入keepalived目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/tmp/keepalived-1.2.17</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span>/keepalived</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make &amp;&amp; make install</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建程序软连接，刷新动态链接库</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ln -s /usr/<span class="built_in">local</span>/keepalived/sbin/keepalived /sbin/</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ldconfig</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看keepalived是否安装成功</span></span><br><span class="line"><span class="meta">$</span><span class="bash">keepalived -v</span></span><br></pre></td></tr></table></figure>
<h3 id="将keepalived注册为服务"><a href="#将keepalived注册为服务" class="headerlink" title="将keepalived注册为服务"></a>将keepalived注册为服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">拷贝配置文件，启动文件，运行参数文件到系统指定目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cp /usr/<span class="built_in">local</span>/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalived</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cp -R /usr/<span class="built_in">local</span>/keepalived/etc/keepalived /etc/</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cp /usr/<span class="built_in">local</span>/keepalived/etc/sysconfig/keepalived /etc/sysconfig</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改keepalived启动脚本以适配suse，修改第12行与23行</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sed -i <span class="string">&quot;/init.d\/functions/s/^/\. \/lib\/lsb\/init-functions #/g&quot;</span> /etc/init.d/keepalived</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sed -i <span class="string">&quot;s/daemon //g&quot;</span> /etc/init.d/keepalived</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置开启启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash">chkconfig keepalived on</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">至此，如果需要启动服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash">service keepalived start</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果需要停止服务，则执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash">service keepalived stop</span></span><br></pre></td></tr></table></figure>
<h2 id="准备配置"><a href="#准备配置" class="headerlink" title="准备配置"></a>准备配置</h2><h3 id="主节点配置"><a href="#主节点配置" class="headerlink" title="主节点配置"></a>主节点配置</h3>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>keepalived</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql安装教程</title>
    <url>/2022/04/14/Mysql%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><code>mysql</code>是一个关系型数据库管理系统，属于<code>Oracle</code>旗下产品，是当前最好的<code>RDBMS</code>(<code>Relational Database Management System</code>，关系数据库管理系统）数据库应用软件之一。</p>
<a id="more"></a>
<h2 id="阅读需知"><a href="#阅读需知" class="headerlink" title="阅读需知"></a>阅读需知</h2><blockquote>
<p>以<code>$</code>开头的<code>shell</code>命令为用户执行的命令</p>
<p>斜体文本为注意事项</p>
</blockquote>
<h2 id="安装环境以及版本"><a href="#安装环境以及版本" class="headerlink" title="安装环境以及版本"></a>安装环境以及版本</h2><blockquote>
<p><strong>Suse</strong>:    <code>SUSE Linux Enterprise Server 11 ( x86_64 )</code></p>
<p><strong>Mysql</strong>: <code>mysql-5.7.23-1.sles11.x86_64.rpm-bundle</code></p>
</blockquote>
<h2 id="创建mysql用户"><a href="#创建mysql用户" class="headerlink" title="创建mysql用户"></a>创建mysql用户</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">用root用户创建mysql用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash">useradd -r -s /sbin/nologin mysql</span></span><br></pre></td></tr></table></figure>
<h2 id="上传安装包"><a href="#上传安装包" class="headerlink" title="上传安装包"></a>上传安装包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入home目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建临时目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir tmp</span></span><br></pre></td></tr></table></figure>
<p>上传<code>mysql</code>安装包<code>mysql-5.7.23-1.sles11.x86_64.rpm-bundle.tar</code>到<code>/home/tmp</code>目录。</p>
<h2 id="安装前检查"><a href="#安装前检查" class="headerlink" title="安装前检查"></a>安装前检查</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">检查系统是否安装过mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rpm -qa | grep mysql</span></span><br></pre></td></tr></table></figure>
<p>如果存在以下包名，则说明安装过mysql</p>
<blockquote>
<p>mysql-community-libs-5.7.23-1.sles11</p>
<p>mysql-community-client-5.7.23-1.sles11</p>
<p>mysql-community-server-5.7.23-1.sles11</p>
<p>mysql-community-common-5.7.23-1.sles11</p>
</blockquote>
<p>如果系统安装过mysql需要对原来的mysql进行卸载，由于mysql各个安装包存在依赖关系，需要安装一定的顺序卸载安装包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">rpm -e mysql-community-server-5.7.23-1.sles11</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rpm -e mysql-community-client-5.7.23-1.sles11</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rpm -e mysql-community-libs-5.7.23-1.sles11</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rpm -e mysql-community-common-5.7.23-1.sles11</span></span><br></pre></td></tr></table></figure>
<p>再卸载完成之后，再次使用上述命令检查mysql安装情况。</p>
<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入安装包目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/tmp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解压mysql安装包</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -xvf mysql-5.7.23-1.sles11.x86_64.rpm-bundle.tar</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装mysql，中间过程中需要确认，输入y回车即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash">zypper install mysql-community-&#123;server,client,common,libs&#125;-*</span></span><br></pre></td></tr></table></figure>
<h2 id="启动mysql服务"><a href="#启动mysql服务" class="headerlink" title="启动mysql服务"></a>启动mysql服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动mysql服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash">service mysql start</span></span><br></pre></td></tr></table></figure>
<p>如果<code>mysql</code>启动失败，检查是否有<code>mysql</code>进程运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ps aux | grep mysql</span></span><br></pre></td></tr></table></figure>
<p>如果存在已经运行的<code>mysql</code>进程，则需要杀死原来的<code>mysql</code>进程，<code>xxx</code>为进程号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">kill</span> -9 xxx</span></span><br></pre></td></tr></table></figure>
<p>再次启动mysql</p>
<h2 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看mysql日志，搜索字符串“root@localhost: xxx”,其中xxx就是root用户初始密码，如果没有密码，参考2.3.7章节</span></span><br><span class="line"><span class="meta">$</span><span class="bash">vi /var/<span class="built_in">log</span>/mysql/mysqld.log</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用root用户登录mysql,其中xxx为初始密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mysql -uroot -p<span class="string">&#x27;xxx&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改mysql登录密码安全限制(可选项)</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">set</span> global validate_password_policy=0;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">set</span> global validate_password_length=1;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改root用户登录密码，xxx为修改后的密码</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SET PASSWORD = PASSWORD(<span class="string">&#x27;xxx&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">退出mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">exit</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">再次登录mysql，测试新密码是否有用，yyy代表新密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mysql -uroot -p<span class="string">&#x27;yyy&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="日志中没有临时登录密码"><a href="#日志中没有临时登录密码" class="headerlink" title="日志中没有临时登录密码"></a>日志中没有临时登录密码</h2><p>修改<code>mysql</code>配置文件<code>/etc/my.cnf</code>，在最后一行添加语句<code>skip-grant-table</code>，保存退出后，重启mysql服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash">service mysql restart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">登录mysql数据库，不用输入密码，直接回车，遇到要求输入密码，再次回车，然后就可以成功登录mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mysql -uroot -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">切换数据库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use mysql;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查询user表</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from user;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改密码，其中xxx为修改后的密码</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update mysql.user <span class="built_in">set</span> authentication_string=password(<span class="string">&#x27;xxx&#x27;</span>) <span class="built_in">where</span> user=<span class="string">&#x27;root&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">刷新缓存，保证立即生效</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">退出mysql</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span>;</span></span><br></pre></td></tr></table></figure>
<p>使用新密码登录mysql，再次检查新密码是否修改成功。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>suse</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbtMQ安装教程</title>
    <url>/2022/04/12/RabbtMQ%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><code>RabbitMQ</code>是使用<code>Erlang</code>语言开发的开源消息队列系统，基于<code>AMQP</code>协议来实现。<code>AMQP</code>的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p>
<a id="more"></a>
<h2 id="RabbitMQ集群规划"><a href="#RabbitMQ集群规划" class="headerlink" title="RabbitMQ集群规划"></a>RabbitMQ集群规划</h2><div class="table-container">
<table>
<thead>
<tr>
<th>IP地址</th>
<th>主机名</th>
<th>端口</th>
<th>用户名</th>
<th>密码</th>
<th>节点类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>10.10.10.1</td>
<td>SZ001</td>
<td>5672</td>
<td>admin</td>
<td>admin</td>
<td>主节点</td>
</tr>
<tr>
<td>10.10.10.2</td>
<td>SZ002</td>
<td>5672</td>
<td>admin</td>
<td>admin</td>
<td>从节点</td>
</tr>
</tbody>
</table>
</div>
<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><blockquote>
<p><strong>Suse</strong>:    <code>SUSE Linux Enterprise Server 11 ( x86_64 )</code></p>
<p><strong>RabbitMQ</strong>:    <code>3.7.14</code></p>
<p><strong>Erlang</strong>:    <code>21.3</code></p>
<p><strong>Openssl</strong>:    <code>1.1.1</code></p>
</blockquote>
<h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><p>登录<code>suse</code>系统，创建临时文件夹<code>/home/tmp</code>，上传安装包</p>
<blockquote>
<p><strong>openssl-1.1.1.tar.gz</strong></p>
<p><strong>otp_src_21.3.tar.gz</strong></p>
<p><strong>rabbitmq-server-generic-unix-3.7.14.tar</strong></p>
</blockquote>
<h2 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h2><p>查看RabbitMQ所需要的Erlang版本</p>
<p><a href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入安装包所在目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/tmp</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解压Erlang安装包</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -zxvf otp_src_21.3.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入解压目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> otp_src_21.3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装依赖包</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./otp_build autoconf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">编译Erlang</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>
<p>配置Erlang环境变量<code>/etc/profile</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/lib/erlang/bin</span><br></pre></td></tr></table></figure>
<p>刷新配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>测试Erlang，出现如下情况说明安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">erl -version</span></span><br><span class="line">Erlang (SMP,ASYNC_THREADS,HIPE) (BEAM) emulator version 10.3</span><br></pre></td></tr></table></figure>
<h2 id="安装OpenSSL"><a href="#安装OpenSSL" class="headerlink" title="安装OpenSSL"></a>安装OpenSSL</h2><p>查看当前openssl版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">openssl version</span></span><br><span class="line">OpenSSL 0.9.8j-fips 07 Jan 2009</span><br></pre></td></tr></table></figure>
<p>如果低于<code>1.1.1</code>版本，需要升级，进入包所在目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/tmp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压openssl</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -zxvf openssl-1.1.1.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入openssl所在目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> openssl-1.1.1/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./config</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make &amp;&amp; make install</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">链接升级后的动态库到库目录/usr/lib64/</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ln -s /usr/<span class="built_in">local</span>/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ln -s /usr/<span class="built_in">local</span>/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1</span></span><br></pre></td></tr></table></figure>
<p>查看结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ls -la /usr/lib64/ | grep -P <span class="string">&#x27;(libssl|libcrypto)&#x27;</span></span></span><br><span class="line">-r-xr-xr-x  1 root root 1685176	Mar 25	2013 libcrypto.so.0.9.8</span><br><span class="line">lrwxrwxrwx  1 root root      33 Sep 18	2018 libcrypto.so.1.1 -&gt; /usr/local/lib64/libcrypto.so.1.1</span><br><span class="line">-r-xr-xr-x  1 root root  351360 Mar 25	2013 libssl.so.0.9.8</span><br><span class="line">lrwxrwxrwx  1 root root      30 Sep 18	2018 libssl.so.1.1 -&gt; /usr/local/lib64/libssl.so.1.1</span><br><span class="line">-rwxr-xr-x  1 root root  283640 May 11	2013 libssl3.so</span><br></pre></td></tr></table></figure>
<p>退出<code>suse</code>，然后再次登录，查看openssl版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">openssl version</span></span><br><span class="line">OpenSSL 1.1.1 11 Sep 2018</span><br></pre></td></tr></table></figure>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入包安装目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/tmp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解压RabbitMQ文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -xvf rabbitmq-server-generic-unix-3.7.14.tar</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">拷贝解压文件到安装目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir -p /home/rabbitmq</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cp -r rabbitmq_server-3.7.14 /home/rabbitmq</span></span><br></pre></td></tr></table></figure>
<p>配置环境变量<code>/etc/profile</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/lib/erlang/bin:/home/rabbitmq/rabbitmq_server-3.7.14/sbin</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">刷新配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">source</span> /etc/profile</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入rabbitmq安装目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/rabbitmq/rabbitmq_server-3.7.14</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动RabbitMQ</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmq-server detached &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看RabbitMQ进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ps aux | grep rabbitmq</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动插件管理</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">添加用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl add_user admin admin</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl set_user_tags admin administrator</span></span><br></pre></td></tr></table></figure>
<p>访问<code>http://[IP]:15672</code>，可以看到RabbitMQ登录页面，至此RabbitMQ单机安装完成</p>
<h2 id="安装RabbitMQ集群"><a href="#安装RabbitMQ集群" class="headerlink" title="安装RabbitMQ集群"></a>安装RabbitMQ集群</h2><p>在另一台主机安装单机RabbitMQ</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">停止RabbitMQ主节点</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl stop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">停止RabbitMQ从节点</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl stop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看两个节点的.erlang.cookie文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cat /root/.erlang.cookie</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">复制主节点的.erlang.cookie文件给从节点，覆盖从节点的.erlang.cookie文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash">scp -r /root/.erlang.cookie root@10.10.10.2:/root/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">在从节点上执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl stop_app</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl reset</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl start_app</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">在主节点执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl stop_app</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl reset</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">把从节点加入主节点,SZX002是主机名</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl join_cluster rabbit@SZ002</span></span><br></pre></td></tr></table></figure>
<p>如果报错误，<code>Error: unable to perform an operation on node &#39;rabbit@SZ002&#39;</code>，修改主节点与从节点的<code>/etc/hosts</code>文件。</p>
<blockquote>
<p>10.10.10.1 SZ001</p>
<p>10.10.10.2 SZ002</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启主从节点网络服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash">/etc/init.d/network restart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">再次执行添加从节点命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl join_cluster rabbit@SZ002</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动RabbitMQ主节点</span></span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看集群状态，可以看到两个节点均处于运行状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl cluster_status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设定镜像集群</span></span><br><span class="line"><span class="meta">$</span><span class="bash">rabbitmqctl set_policy ha-all <span class="string">&quot;&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span> --vhost TestVirtualHost</span></span><br></pre></td></tr></table></figure>
<p>登录RabbitMQ管理页面，创建一个队列发现Feature是ha-all说明已经是高可用镜像集群。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#复制延迟交换机插件到插件目录</span></span><br><span class="line"><span class="variable">$cp</span> -r rabbitmq_delayed_message_exchange-20171201-3.7.x.ez /home/rabbitmq/rabbitmq_server-3.7.14/plugins/</span><br><span class="line"></span><br><span class="line"><span class="comment">#启用延迟交换机插件</span></span><br><span class="line"><span class="variable">$rabbitmq</span>-plugins <span class="built_in">enable</span> rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MQ</tag>
        <tag>RabbitMQ</tag>
        <tag>Suse</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/10/26/QuickSort/</url>
    <content><![CDATA[<p>快速排序（英语：Quicksort），又称分区交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。通常明显比其&gt;他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。</p>
<a id="more"></a>
<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>是一种分治的思想。它将一个数组分成两个子数组，两部分独立的排序。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[5] [8] [9] [7] [1] [3] [9]</span><br></pre></td></tr></table></figure>
<p>假定第一个元素<font color="red">[5]</font>为哨兵，标记哨兵为x，使用临时变量<code>temp</code>存放哨兵的值，则原数据如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[x] [8] [9] [7] [1] [3] [9]</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [5]</span><br><span class="line">left = 1</span><br><span class="line">right = 6</span><br></pre></td></tr></table></figure>
<p>第一步：，从数组尾部开始扫描，如果当前元素<code>c[right]</code>大于哨兵的值，则索引<code>right</code>减1，继续扫描，如果当前元素<code>c[right]</code>小于哨兵的值，则交换哨兵与当前元素的值。因为<font color="red">[3]</font>小于<font color="red">[9]</font>，因此交换<font color="red">[3]</font>和哨兵<font color="red">[x]</font>，得到如下结果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [8] [9] [7] [1] [x] [9]</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [5]</span><br><span class="line">left = 1</span><br><span class="line">right = 5</span><br></pre></td></tr></table></figure>
<p>第二步，从数组头部开始扫描，如果当前元素<code>c[left]</code>小于哨兵的值，则索引<code>left</code>加1，继续扫描，如果当前元素<code>c[left]</code>大于哨兵的值，则交换哨兵与当前元素的值。因为<font color="red">[8]</font>大于<font color="red">[5]</font>，因此交换<font color="red">[8]</font>和哨兵<font color="red">[x]</font>，得到如下结果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [x] [9] [7] [1] [8] [9]</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [9]</span><br><span class="line">left = 1</span><br><span class="line">right = 5</span><br></pre></td></tr></table></figure>
<p>第三步，继续从<code>right-1</code>处继续扫描，重复步骤一，得到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [1] [9] [7] [x] [8] [9]</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [9]</span><br><span class="line">left = 1</span><br><span class="line">right = 4</span><br></pre></td></tr></table></figure>
<p>第四步，继续从<code>left+1</code>处继续扫描，重复步骤二，得到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [1] [x] [7] [9] [8] [9]</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [9]</span><br><span class="line">left = 2</span><br><span class="line">right = 4</span><br></pre></td></tr></table></figure>
<p>一直重复上面的步骤直到，<code>left</code>大于等于<code>right</code>结束扫描，最后把临时变量temp的值存入<font color="red">[x]</font>处，第一轮快速排序结束。可以得到第一轮结果如下，可以很明显看到小于<font color="red">[5]</font>的值全在左边，大于<font color="red">[5]</font>的值全在右边。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [1] [5] [7] [9] [8] [9]</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [9]</span><br><span class="line">left = 2</span><br><span class="line">right = 2</span><br></pre></td></tr></table></figure>
<p>第二轮，把第一轮的结果看成如下两个数组，对每个数组，重复第一轮的排序方法，直到左右数组均有序。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [1]</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [9] [8] [9]</span><br></pre></td></tr></table></figure>
<p>最终可以得到有序数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9] [9]</span><br></pre></td></tr></table></figure>
<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>快速排序是不稳定的排序算法，其时间复杂度计算公式如下，可以看到快速排序最好情况下时间复杂度为<code>O(nlogn)</code>，最坏情况下时间复杂度为<code>2^n</code>，平均时间复杂度为<code>O(nlogn)</code>。</p>
</blockquote>
<script type="math/tex; mode=display">
待补充</script><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>less函数与exch函数参见文章排序算法序言。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    sort(c, <span class="number">0</span>, c.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= start) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = partition(c, start, end);</span><br><span class="line">    sort(c, start, j - <span class="number">1</span>);</span><br><span class="line">    sort(c, j+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = start, j = end + <span class="number">1</span>;</span><br><span class="line">    Comparable v = c[start];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (less(c[++i], v))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == end)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (less(v, c[--j]))&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == start)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(c, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(c, start, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>不稳定排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法引言</title>
    <url>/2020/10/25/SortIntroduction/</url>
    <content><![CDATA[<p>排序算法是最常见的算法之一，常见的排序算法有<code>冒泡排序</code>、<code>插入排序</code>、<code>选择排序</code>、<code>希尔排序</code>、<code>归并排序</code>、<code>堆排序</code>、<code>快速排序</code>。其目的是为了实现&gt;对数组中元素的排序。通常排序分为正序和倒序。</p>
<a id="more"></a>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><blockquote>
<ul>
<li>最好、最坏、平均时间复杂度</li>
<li><code>时间复杂度</code>计算公式</li>
<li>比较次数和交换次数</li>
</ul>
</blockquote>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><blockquote>
<ul>
<li><code>空间复杂度</code>，衡量空间上的内存消耗</li>
<li><code>原地排序</code>，代指空间复杂度为O(1)的排序</li>
</ul>
</blockquote>
<h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><blockquote>
<ul>
<li><code>稳定</code>的算法在排序的过程中不会改变元素彼此的位置的相对次序,反之<code>不稳定</code>的排序算法经常会改变这个次序。以某两个相等元素<code>c[i]</code>和<code>c[j]</code>为例，假如在原始待排序数组中<code>c[i] == c[j]</code>，并且<code>c[i]</code>位置在<code>c[j]</code>之前。那么如果整个排序过程中，<code>c[i]</code>均在<code>c[j]</code>之前，则说明排序算法是稳定的，反之则是不稳定的。</li>
</ul>
</blockquote>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>][<span class="number">4</span>][<span class="number">9</span>] .... [i] ... [j] ...</span><br></pre></td></tr></table></figure>
<h2 id="公共函数"><a href="#公共函数" class="headerlink" title="公共函数"></a>公共函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*比较两个元素大小*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*交换两个元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Comparable t = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>排序算法</tag>
        <tag>稳定与不稳定</tag>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/10/26/SelectionSort/</url>
    <content><![CDATA[<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<a id="more"></a>
<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>每次在未排序的数组中，找到最大或者最小的元素，放到已排序数组的末尾，依次进行，直到数组全部有序。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9] [8] [9] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>
<p>第一步，在原始数组中找到最小元素<font color="red">[1]</font>，起始位置的<font color="red">[9]</font>进行交换，结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [8] [9] [7] [9] [3] [5]</span><br></pre></td></tr></table></figure>
<p>第二步，在剩余未排序数组中找到最小元素<font color="red">[3]</font>与<font color="red">[8]</font>进行交换，结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [9] [7] [9] [8] [5]</span><br></pre></td></tr></table></figure>
<p>第三步，在剩余未排序数组中找到最小元素<font color="red">[5]</font>与索引三处的<font color="red">[9]</font>进行交换，结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [9] [8] [9]</span><br></pre></td></tr></table></figure>
<p>第四步，在剩余未排序数组中找到最小元素<font color="red">[7]</font>，其已经处在正确位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [9] [8] [9]</span><br></pre></td></tr></table></figure>
<p>第五步，在剩余未排序数组中找到最小元素<font color="red">[8]</font>，前面的<font color="red">[9]</font>进行交换，结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9] [9]</span><br></pre></td></tr></table></figure>
<p>第六步，在剩余未排序数组中找到最小元素<font color="red">[9]</font>，其已经处在正确位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9] [9]</span><br></pre></td></tr></table></figure>
<p>排序完毕，数组已经有序。</p>
<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>从第一步就可以明显看出，两个<code>[9]</code>交换了次序，因此插入排序是不稳定的排序算法。其时间复杂度计算公式如下。可以看到选择排序最好的情况下时间复杂度为2^n，最坏的情况下时间复杂度为2^n，空间复杂度为O(1)，平均时间复杂度为2^n。</p>
</blockquote>
<script type="math/tex; mode=display">
(n-1) + (n-2) + ... + 1 = \frac{n * (n-1)}{2}</script><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>less函数与exch函数参见文章排序算法序言。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(c[j], c[j-<span class="number">1</span>]); j--)&#123;</span><br><span class="line">            exch(c, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>不稳定排序</tag>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title>grep命令</title>
    <url>/2022/04/23/grep%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>grep</code>（<code>globally search a regular expression and print</code>，以正则表达式进行全局查找以及打印），在给出文件列表或标准输入后，<code>grep</code>会对匹配一个或多个正则表达式的文本进行搜索，并只输出匹配（或者不匹配）的行或文本。</p>
<a id="more"></a>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">options：参数选项，pattern：规则文本，files：标准输入或者文件列表</span></span><br><span class="line"><span class="meta">$</span><span class="bash">grep [options] pattern [files]</span></span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>本文列出常见参数，如果想要看到所有参数，使用<code>man grep</code>即可查看<code>grep</code>的所有参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c --count : 打印符合规则文本的行数</span><br><span class="line">-d --directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。</span><br><span class="line">-e --regexp=&lt;规则样式&gt; : 指定字符串作为查找文件内容的范本样式。</span><br><span class="line">-h --no-filename : 显示匹配的行，但不显示文件名</span><br><span class="line">-i --ignore-case : 忽略字符串大小写</span><br><span class="line">-l --file-with-matches : 仅仅列出文件名</span><br><span class="line">-n --line-number : 显示匹配的行和行号</span><br><span class="line">-v --revert-match : 反转查找，也即打印不匹配的行</span><br><span class="line">-e exp --regexp=exp : 指定字符串作为查找文件内容的规则表达式</span><br><span class="line">-f file --file=file : 指定正则文件</span><br><span class="line">-E --extended-regexp : 使用扩展正则表达式</span><br><span class="line">-w --word-regexp : 匹配整个单词</span><br><span class="line">-o : 只输出文件中匹配的部分</span><br><span class="line">-A n --after-context=n : 除了显示匹配的那一行之外，并显示该行之后的内容，n是显示的行数</span><br><span class="line">-B n --before-context=n : 除了显示匹配的那一行之外，并显示该行之前的内容，n是显示的行数</span><br><span class="line">-C n --context=n : 除了显示匹配的那一行之外，并显示该行之前和之后的内容，n是显示的行数</span><br><span class="line">-R/-r  --recursive : 此参数的效果和指定“-d recurse”参数相同，递归搜索。</span><br></pre></td></tr></table></figure>
<h2 id="规则表达式"><a href="#规则表达式" class="headerlink" title="规则表达式"></a>规则表达式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^        匹配行的开端    </span><br><span class="line"><span class="meta">$</span><span class="bash">        匹配行的结束</span></span><br><span class="line">.        匹配一个非换行符的字符    </span><br><span class="line">*        匹配零个或多个*号前一个字符 </span><br><span class="line">[]       匹配一个指定范围内的字符，如&#x27;[0-9]&#x27;代表0到9任意一个数字    </span><br><span class="line">[^]      匹配一个不在指定范围内的字符，如：&#x27;[^A-FH-Z]rep&#x27;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。      </span><br><span class="line">\&lt;       匹配单词的开始，如:&#x27;\&lt;leis&#x27;匹配包含以leis开头的单词的行。    </span><br><span class="line">\&gt;       匹配单词的结束，如&#x27;leis\&gt;&#x27;匹配包含以leis结尾的单词的行。    </span><br><span class="line">x\&#123;m\&#125;   重复字符x，m次。    </span><br><span class="line">x\&#123;m,\&#125;  重复字符x,至少m次。    </span><br><span class="line">x\&#123;m,n\&#125; 重复字符x，至少m次，不多于n次。   </span><br><span class="line">\w       匹配文字和数字字符，也就是[A-Za-z0-9]。   </span><br><span class="line">\W       \w的反向选择，匹配一个或多个非单词字符，如逗号等。   </span><br><span class="line">\b       单词锁定符，如: &#x27;\bgrep\b&#x27;只匹配grep。  </span><br></pre></td></tr></table></figure>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="查找多个文件"><a href="#查找多个文件" class="headerlink" title="查找多个文件"></a>查找多个文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">同时在file_1 file_2 file_3 ...搜索match_pattern</span></span><br><span class="line"><span class="meta">$</span><span class="bash">grep <span class="string">&quot;match_pattern&quot;</span> file_1 file_2 file_3 ...</span></span><br></pre></td></tr></table></figure>
<h3 id="标记查找行颜色"><a href="#标记查找行颜色" class="headerlink" title="标记查找行颜色"></a>标记查找行颜色</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">搜索match_pattern并标记颜色</span></span><br><span class="line"><span class="meta">$</span><span class="bash">grep <span class="string">&quot;match_pattern&quot;</span> file_name --color=auto</span></span><br></pre></td></tr></table></figure>
<h3 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用正则搜索</span></span><br><span class="line"><span class="meta">$</span><span class="bash">grep -E <span class="string">&quot;[1-9]+&quot;</span> file_name</span></span><br></pre></td></tr></table></figure>
<h3 id="递归搜索"><a href="#递归搜索" class="headerlink" title="递归搜索"></a>递归搜索</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在当前目录递归搜索text</span></span><br><span class="line"><span class="meta">$</span><span class="bash">grep <span class="string">&quot;text&quot;</span> . -r -n</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>grep</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo样式个性化配置</title>
    <url>/2021/03/31/hexo-preference/</url>
    <content><![CDATA[<p>hexo博客搭建好之后，如何调整样式对于没有前端基础的人来说是一件很困难的事情，下面分享我样式调整过程中的一些经验，由于我使用的是Next主题，所以如果是其它的主题的仅做参考，有可能细节之处不太一样。</p>
<a id="more"></a>
<h2 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blog home dir</span></span><br><span class="line">BLOG_HOME=/Users/lei/workspace/MyBlog</span><br></pre></td></tr></table></figure>
<h2 id="解锁样式定制配置"><a href="#解锁样式定制配置" class="headerlink" title="解锁样式定制配置"></a>解锁样式定制配置</h2><p>（1）打开next主题配置文件。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$&#123;BLOG_HOME&#125;</span>/themes/next/_config.yml</span><br></pre></td></tr></table></figure></p>
<p>（2）搜索<code>custom_file_path</code>可以看到如下配置，把反注释掉<code>style: source/_data/styles.styl</code>配置，记住去掉<code>#</code>号即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
<p>（3）注意上面的<code>source/_data</code>目录指的是博客<code>home</code>目录下的<code>source/_data</code>目录，首先创建<code>_data</code>目录，然后创建<code>styles.style</code>文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create _data directory</span></span><br><span class="line">mkdir -p <span class="variable">$&#123;BLOG_HOME&#125;</span>/<span class="built_in">source</span>/_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># create _data file</span></span><br><span class="line">touch <span class="variable">$&#123;BLOG_HOME&#125;</span>/<span class="built_in">source</span>/_data/styles.styl</span><br></pre></td></tr></table></figure>
<h2 id="自定义样式配置"><a href="#自定义样式配置" class="headerlink" title="自定义样式配置"></a>自定义样式配置</h2><p>下面直接晒出我的配置，自己可以打开<code>Chrome</code>浏览器的检查功能，慢慢对照样式进行调整，其实主要是为了<code>PC</code>端与移动端的适配，保证<code>PC</code>端简洁大方，移动端不至于空白太多。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//背景图片配置</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    background:url(/images/background.jpeg);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed;</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文章部分配置</span></span><br><span class="line"><span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1px</span> <span class="number">3%</span> <span class="number">1px</span> <span class="number">3%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">80%</span>;</span><br><span class="line">    +mobile() &#123;</span><br><span class="line">   	<span class="attribute">padding</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动端自适应</span></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">   +mobile() &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">1%</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动端自适应</span></span><br><span class="line"><span class="selector-class">.use-motion</span> .post-block&#123;</span><br><span class="line">   +mobile() &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动端自适应</span></span><br><span class="line"><span class="selector-class">.comments</span> &#123;</span><br><span class="line">   +mobile() &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">      <span class="attribute">overflow</span>: hidden;   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动端自适应</span></span><br><span class="line"><span class="selector-class">.gt-container</span> <span class="selector-class">.gt-meta</span> &#123;</span><br><span class="line">   +mobile() &#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">1.25em</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内容最上面留白配置</span></span><br><span class="line">.<span class="attribute">content</span>&#123;</span><br><span class="line">   <span class="attribute">padding-top</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超链接配置</span></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">   <span class="attribute">color</span>: <span class="number">#0645AD</span>;</span><br><span class="line">   <span class="attribute">border-bottom</span>: none;</span><br><span class="line">   <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0645AD</span>;</span><br><span class="line">   <span class="selector-pseudo">&amp;:hover</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#0B0080</span>;</span><br><span class="line">      <span class="attribute">border-bottom</span>: none;</span><br><span class="line">      <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0B0080</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//graphviz图片自适应</span></span><br><span class="line"><span class="selector-class">.post-body</span> svg &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多级目录自动展开</span></span><br><span class="line"><span class="selector-class">.post-toc</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo简单使用</title>
    <url>/2021/03/18/hexo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><font color="green"><strong>Hexo</strong></font> 是一个简单，美观，使用起来方便，支持各种二次定制的博客框架。并且支持丰富的<font color="green"><strong>Markdown</strong></font>插件，是程序员不可多得的博客框架。</p>
<a id="more"></a>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>基本<font color="green"><strong>Hexo</strong></font>使用命令介绍。</p>
<h3 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo new <span class="string">&#x27;title&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>创建完博客之后，会自动在<font color="blue"> <strong>source/_posts</strong>/</font>目录下面创建一个同名的md结尾的<font color="green"><strong>Markdown</strong></font>文件，此时只需要使用markdown编辑器打开md文件撰写博客即可，例如Typora或者Atomic等等。</p>
<h3 id="本地预览博客"><a href="#本地预览博客" class="headerlink" title="本地预览博客"></a>本地预览博客</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo s</span></span><br></pre></td></tr></table></figure>
<p>撰写完博客之后，在正式发布到博客网站之后，可以先使用<font color="green"><strong>server</strong></font>命令本地启动博客服务器，预览博客效果，在确认没有问题之后再发布到正式网站上面。</p>
<h3 id="正式发布博客"><a href="#正式发布博客" class="headerlink" title="正式发布博客"></a>正式发布博客</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo clean &amp;&amp; hexo g -d</span></span><br></pre></td></tr></table></figure>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://theme-next.iissnan.com/theme-settings.html" title="Next Theme主题配置">Next Theme</a>     - next theme主题官方配置教程</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka命令</title>
    <url>/2021/03/27/kafka%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>kafka是一款优秀且常见的MQ，具有安装方便，使用方便，应用场景广泛等一系列优点，个人认为是最好用的MQ之一。</p>
<a id="more"></a>
<h2 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kafka version</span></span><br><span class="line">version=kafka_2.12-1.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka topic</span></span><br><span class="line">topic=ChristmasEvent</span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka bootstrap server</span></span><br><span class="line">Kafka_server=19.94.08.13:19092</span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka zookeeper server</span></span><br><span class="line">zk_server=19.14.08.13:21810</span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka consumer group</span></span><br><span class="line">consumer_group=bless-server</span><br></pre></td></tr></table></figure>
<h2 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建Topic</h2><p>创建kafka topic，其中replication-factor代表副本数，partitions代表分区数。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-topics.sh --create --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --replication-factor 1 --partitions 1 --topic <span class="variable">$&#123;topic&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="查看Topic内容（当前开始）"><a href="#查看Topic内容（当前开始）" class="headerlink" title="查看Topic内容（当前开始）"></a>查看Topic内容（当前开始）</h2><p>从当前时刻开始，用于实时查看kafka的消息。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-console-consumer.sh --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span> --topic <span class="variable">$&#123;topic&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="查看Topic内容（从头开始）"><a href="#查看Topic内容（从头开始）" class="headerlink" title="查看Topic内容（从头开始）"></a>查看Topic内容（从头开始）</h2><p>从头开始，用于实时查看kafka消息，仅限开发调测环境使用，当kafka消息过多时可能会导致异常问题。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-console-consumer.sh --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span> --topic <span class="variable">$&#123;topic&#125;</span> --from-beginning</span><br></pre></td></tr></table></figure>
<h2 id="查看消费组（旧版本）"><a href="#查看消费组（旧版本）" class="headerlink" title="查看消费组（旧版本）"></a>查看消费组（旧版本）</h2><p>查看消费者组情况，适用于用于旧版本kafka客户端。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --list --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="查看消费组（新版本）"><a href="#查看消费组（新版本）" class="headerlink" title="查看消费组（新版本）"></a>查看消费组（新版本）</h2><p>查看消费者组情况，适用于用于新版本kafka客户端。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --new-consumer --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span> --list</span><br></pre></td></tr></table></figure>
<h2 id="查看消费组（使用ZK连接而非Java-Api）"><a href="#查看消费组（使用ZK连接而非Java-Api）" class="headerlink" title="查看消费组（使用ZK连接而非Java Api）"></a>查看消费组（使用ZK连接而非Java Api）</h2><p>查看消费者组情况，仅限于使用zk连接的消费者。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --list</span><br></pre></td></tr></table></figure>
<h2 id="查看单个消费组详情（Java-Api）"><a href="#查看单个消费组详情（Java-Api）" class="headerlink" title="查看单个消费组详情（Java Api）"></a>查看单个消费组详情（Java Api）</h2><p>查看单个消费者组情况，使用Java Api连接的消费者。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --new-consumer --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span> --group <span class="variable">$&#123;consumer_group&#125;</span> --describe</span><br></pre></td></tr></table></figure>
<h2 id="查看单个消费组详情（ZK）"><a href="#查看单个消费组详情（ZK）" class="headerlink" title="查看单个消费组详情（ZK）"></a>查看单个消费组详情（ZK）</h2><p>查看单个消费者组情况，使用zk连接的消费者。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --group <span class="variable">$&#123;consumer_group&#125;</span> --describe</span><br></pre></td></tr></table></figure>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>直接在命令行发布一条消息，可以用于开发环境调测，重放消息等。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-console-producer.sh --broker-list <span class="variable">$&#123;kafka_server&#125;</span> --topic <span class="variable">$&#123;topic&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="查看Topic列表"><a href="#查看Topic列表" class="headerlink" title="查看Topic列表"></a>查看Topic列表</h2><p>查看kafka当前Topic列表。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-topics.sh --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --list</span><br></pre></td></tr></table></figure>
<h2 id="查看单个Topic详情"><a href="#查看单个Topic详情" class="headerlink" title="查看单个Topic详情"></a>查看单个Topic详情</h2><p>查看单个Topic详情。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-topics.sh --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --topic <span class="variable">$&#123;topic&#125;</span> --describe</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1011 在 D 天内送达包裹的能力</title>
    <url>/2021/08/28/leetcode-1011/</url>
    <content><![CDATA[<p>题目描述：传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p>
<p>传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minWeight = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = weights.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            maxWeight += weights[i];</span><br><span class="line">            <span class="keyword">if</span> (weights[i] &gt; minWeight) &#123;</span><br><span class="line">                minWeight = weights[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = minWeight;</span><br><span class="line">        <span class="keyword">int</span> right = maxWeight;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> currentDays = calculateDays(weights, mid);</span><br><span class="line">            <span class="keyword">if</span> (currentDays == days) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentDays &lt; days) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentDays &gt; days) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> days = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpWeight = weight;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; weights.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpWeight &gt;= weights[i]) &#123;</span><br><span class="line">                tmpWeight -= weights[i];</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (i == weights.length) &#123;</span><br><span class="line">                    days++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmpWeight = weight;</span><br><span class="line">                days++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
        <tag>难度中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-105 从前序与中序遍历序列构造二叉树</title>
    <url>/2021/08/02/leetcode-105/</url>
    <content><![CDATA[<p>题目描述：给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, inorder, <span class="number">0</span>, inorder.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> rootIdx, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 单个节点直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (start == end - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[start]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 前序第一个节点为二叉树根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[rootIdx]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 寻找根节点在中序序列中的索引值</span></span><br><span class="line">        <span class="keyword">int</span> rootIdxInOrder = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt; end; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[idx] == root.val) &#123;</span><br><span class="line">                rootIdxInOrder = idx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 中序序列中根节点左部分节点构成左子树</span></span><br><span class="line">        TreeNode leftNode = buildTree(preorder, rootIdx + <span class="number">1</span>, inorder, start, rootIdxInOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 中序序列中根节点右部分节点构成右子树</span></span><br><span class="line">        TreeNode rightNode = buildTree(preorder, rootIdx + <span class="number">1</span> + rootIdxInOrder - start, inorder, rootIdxInOrder + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 连接左右子树</span></span><br><span class="line">        root.left = leftNode;</span><br><span class="line">        root.right = rightNode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>前序、中序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-106 从中序与后续遍历序列构造二叉树</title>
    <url>/2021/08/03/leetcode-106/</url>
    <content><![CDATA[<p>题目描述：根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder, <span class="number">0</span>, inorder.length, postorder, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> rootIdx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 单个节点直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (start == end - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[start]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 后续最后一个节点为二叉树根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[rootIdx]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 寻找根节点在中序序列中的索引值</span></span><br><span class="line">        <span class="keyword">int</span> rootIdxInOrder = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt; end; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[idx] == root.val) &#123;</span><br><span class="line">                rootIdxInOrder = idx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 中序序列中根节点左部分节点构成左子树</span></span><br><span class="line">        TreeNode leftNode = buildTree(inorder, start, rootIdxInOrder, postorder, rootIdx - (end - rootIdxInOrder));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 中序序列中根节点右部分节点构成右子树</span></span><br><span class="line">        TreeNode rightNode = buildTree(inorder, rootIdxInOrder + <span class="number">1</span>, end, postorder, rootIdx - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 连接左右子树</span></span><br><span class="line">        root.left = leftNode;</span><br><span class="line">        root.right = rightNode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>中序、后序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-114 二叉树展开为链表</title>
    <url>/2021/07/30/leetcode-114/</url>
    <content><![CDATA[<p>题目描述：给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</li>
<li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li>
</ul>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        convertTree2List(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertTree2List</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 转换左子树</span></span><br><span class="line">        TreeNode leftHeadNode = convertTree2List(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 转换右子树</span></span><br><span class="line">        TreeNode rightHeadNode = convertTree2List(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 找到左子树的叶子节点</span></span><br><span class="line">        TreeNode leftTailNode = leftHeadNode;</span><br><span class="line">        <span class="keyword">while</span> (leftTailNode != <span class="keyword">null</span> &amp;&amp; leftTailNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            leftTailNode = leftTailNode.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 拼接左右子树与根节点</span></span><br><span class="line">        <span class="keyword">if</span> (leftTailNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.right = rightHeadNode;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.right = leftHeadNode;</span><br><span class="line">            leftTailNode.right = rightHeadNode;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1143 最长公共子序列</title>
    <url>/2021/09/18/leetcode-1143/</url>
    <content><![CDATA[<p>题目描述：给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[text1.length() + <span class="number">1</span>][text2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-116 填充每个节点的下一个右侧节点指针</title>
    <url>/2021/07/31/leetcode-116/</url>
    <content><![CDATA[<p>题目描述：给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">  	Node left;</span><br><span class="line">  	Node right;</span><br><span class="line">  	Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理左子树</span></span><br><span class="line">        Node leftNode = connect(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 处理右子树</span></span><br><span class="line">        Node rightNode = connect(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 处理根节点</span></span><br><span class="line">        <span class="keyword">while</span> (leftNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            leftNode.next = rightNode;</span><br><span class="line">            leftNode = leftNode.right;</span><br><span class="line">            rightNode = rightNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-130 被围绕的区域</title>
    <url>/2021/08/19/leetcode-130/</url>
    <content><![CDATA[<p>题目描述：给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="连通图实现"><a href="#连通图实现" class="headerlink" title="连通图实现"></a>连通图实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子树个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录每个节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录每个节点的子树的节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 子树初始节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两颗子树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p 节点p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q 节点q</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = findRoot(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = findRoot(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size[pRoot] &gt; size[qRoot]) &#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            size[pRoot] = size[qRoot] + size[pRoot];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            size[qRoot] = size[pRoot] + size[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个节点是否属于同一颗子树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p 节点p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q 节点q</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否属于同一颗子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = findRoot(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = findRoot(q);</span><br><span class="line">        <span class="keyword">return</span> pRoot == qRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到当前节点的根节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = parent[parent[x]];</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前子树个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 初始化连通图</span></span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(m * n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 假设有个m*n节点，视为非包围O节点的根节点</span></span><br><span class="line">        <span class="keyword">int</span> dummy = m * n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 处理前后两列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                uf.union(i * n, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                uf.union(i * n + n - <span class="number">1</span>, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 处理上下两行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                uf.union(j, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                uf.union((m - <span class="number">1</span>) * n + j, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 处理每个非边缘节点</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> p = i * n + j;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = i + dp[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = j + dp[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> q = x * n + y;</span><br><span class="line">                            uf.union(p, q);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 根据结果处理数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!uf.connected(dummy, i * n + j)) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>矩阵</tag>
        <tag>二维数组</tag>
        <tag>图</tag>
        <tag>连通性</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1373 二叉搜索子树的最大键值和</title>
    <url>/2021/08/09/leetcode-1373/</url>
    <content><![CDATA[<p>题目描述：给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。</p>
<p>二叉搜索树的定义如下：</p>
<ul>
<li>任意节点的左子树中的键值都 小于 此节点的键值。</li>
<li>任意节点的右子树中的键值都 大于 此节点的键值。</li>
<li>任意节点的左子树和右子树都是二叉搜索树。</li>
<li>每棵树有 <code>1</code> 到 <code>40000</code> 个节点。</li>
<li>每个节点的键值在 <code>[-4 * 10^4 , 4 * 10^4]</code> 之间。</li>
</ul>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        postBST(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * int[] 是否是二叉搜索树，左子树最小值，右子树最大值，如果是二叉搜索树则求和</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] postBST(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] left = postBST(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = postBST(root.right);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>]) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = Math.min(root.val, left[<span class="number">1</span>]);</span><br><span class="line">            res[<span class="number">2</span>] = Math.max(root.val, right[<span class="number">2</span>]);</span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">            maxSum = Math.max(res[<span class="number">3</span>], maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉搜索树</tag>
        <tag>难度困难</tag>
        <tag>子树</tag>
        <tag>最大键值和</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-141 环形链表</title>
    <url>/2021/08/30/leetcode-141/</url>
    <content><![CDATA[<p>题目描述：给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode quickPoint = head.next.next;</span><br><span class="line">        ListNode slowPoint = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (quickPoint.next != <span class="keyword">null</span> &amp;&amp; quickPoint.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (quickPoint == slowPoint) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            quickPoint = quickPoint.next.next;</span><br><span class="line">            slowPoint = slowPoint.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>环形链表</tag>
        <tag>难度简单</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-142 环形链表</title>
    <url>/2021/08/21/leetcode-142/</url>
    <content><![CDATA[<p>题目描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<a id="more"></a>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判断是否有环</span></span><br><span class="line">        ListNode fastNode = head;</span><br><span class="line">        ListNode slowNode = head;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != <span class="keyword">null</span> &amp;&amp; fastNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fastNode = fastNode.next.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            <span class="keyword">if</span> (fastNode == slowNode) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 说明没环，直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (fastNode != slowNode || fastNode == <span class="keyword">null</span> || fastNode.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 计算环大小</span></span><br><span class="line">        <span class="keyword">int</span> cycleSize = <span class="number">1</span>;</span><br><span class="line">        fastNode = fastNode.next.next;</span><br><span class="line">        slowNode = slowNode.next;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != slowNode) &#123;</span><br><span class="line">            fastNode = fastNode.next.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            cycleSize++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 快指针先走环大小步，然后和慢指针一起走，会在环开始位置相遇</span></span><br><span class="line">        fastNode = slowNode = head;</span><br><span class="line">        <span class="keyword">while</span> (cycleSize-- != <span class="number">0</span>) &#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != slowNode) &#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>环形链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-146 LRU 缓存机制</title>
    <url>/2021/08/20/leetcode-146/</url>
    <content><![CDATA[<p>题目描述：运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p>
<ul>
<li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li>
<li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有序HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cache.put(key, value);</span><br><span class="line">            makeRecently(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cache.size() &gt;= <span class="keyword">this</span>.cap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.cache.remove(<span class="keyword">this</span>.cache.keySet().iterator().next());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.cache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新key为最近</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="keyword">this</span>.cache.remove(key);</span><br><span class="line">        <span class="keyword">this</span>.cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>LRU算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-167 两数之和 II - 输入有序数组</title>
    <url>/2021/09/03/leetcode-167/</url>
    <content><![CDATA[<p>题目描述：给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p>
<p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> idx = find(numbers, target - numbers[i], i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (idx == -<span class="number">1</span> || idx == i) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[<span class="number">1</span>] = idx + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>有序数组</tag>
        <tag>两数之和</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-19 删除链表的倒数第 N 个结点</title>
    <url>/2021/09/02/leetcode-19/</url>
    <content><![CDATA[<p>题目描述：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode fastNode = head;</span><br><span class="line">        ListNode slowNode = head;</span><br><span class="line">        <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fastNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            slowNode = head.next;</span><br><span class="line">            <span class="keyword">return</span> slowNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fastNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slowNode.next = slowNode.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>链表</tag>
        <tag>删除</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-226 翻转二叉树</title>
    <url>/2021/07/29/leetcode-226/</url>
    <content><![CDATA[<p>题目描述：翻转一棵二叉树。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = invertTree(root.left);</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = node;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>反转</tag>
        <tag>难度简单</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-230 二叉搜索树中第K小的元素</title>
    <url>/2021/08/05/leetcode-230/</url>
    <content><![CDATA[<p>题目描述：给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="中序实现"><a href="#中序实现" class="headerlink" title="中序实现"></a>中序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inorders(root);</span><br><span class="line">        <span class="keyword">return</span> nodes.get(k).val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorders</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.left);</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        inorders(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idxVal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inorders(root, k);</span><br><span class="line">        <span class="keyword">return</span> idxVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorders</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.left, k);</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="keyword">if</span> (idx == k) &#123;</span><br><span class="line">            idxVal = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉搜索树</tag>
        <tag>第K小元素</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-234 回文链表</title>
    <url>/2021/07/28/leetcode-234/</url>
    <content><![CDATA[<p>题目描述：请判断一个链表是否为回文链表。你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 遍历计算链表长度</span></span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 寻找中间节点</span></span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">int</span> subLen = len / <span class="number">2</span> + len % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (subLen-- != <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 反转右半链表区间剩余节点</span></span><br><span class="line">        ListNode subHead2 = reverse(node);</span><br><span class="line">        ListNode subHead1 = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 分别对比左链表区间元素与右链表区间元素</span></span><br><span class="line">        <span class="keyword">while</span> (subHead1 != <span class="keyword">null</span> &amp;&amp; subHead2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (subHead1.val != subHead2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            subHead1 = subHead1.next;</span><br><span class="line">            subHead2 = subHead2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表反转</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 链表头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回反转后的链表头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
        <tag>难度简单</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-236 二叉树的最近公共祖先</title>
    <url>/2021/08/17/leetcode-236/</url>
    <content><![CDATA[<p>题目描述：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 为空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 等于其中一个节点则返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 处理左子树</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="comment">//4. 处理右子树</span></span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//5. 处理结果</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>最近公共祖先节点</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-239 滑动窗口最大值</title>
    <url>/2021/08/25/leetcode-239/</url>
    <content><![CDATA[<p>题目描述：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.getLast() &lt; e) &#123;</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Integer e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.equals(queue.getFirst())) &#123;</span><br><span class="line">            queue.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Window window = <span class="keyword">new</span> Window();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            window.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            window.add(nums[i]);</span><br><span class="line">            res[i - k + <span class="number">1</span>] = window.getMax();</span><br><span class="line">            window.remove(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度困难</tag>
        <tag>最大值</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-25 K个一组翻转链表</title>
    <url>/2021/07/27/leetcode-25/</url>
    <content><![CDATA[<p>题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。你可以设计一个只使用常数额外空间的算法来解决此问题吗？你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<a id="more"></a>
<h2 id="原题介绍"><a href="#原题介绍" class="headerlink" title="原题介绍"></a>原题介绍</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><div><div class="graphviz">digraph leetcode_92_1 {

    bgcolor="#f7f7f7"

    rankdir=LR
    subgraph cluster_name {

        subgraph cluster_1 {
            n0 [label="1" shape=circle,color=blue,fillcolor=lightblue,style=filled]
            n1 [label="2" shape=circle,color=blue,fillcolor=lightblue,style=filled]
            n2 [label="3" shape=circle,color=yellow,fillcolor=lightyellow,style=filled]
            n3 [label="4" shape=circle,color=yellow,fillcolor=lightyellow,style=filled]
            n4 [label="5" shape=circle,color=black,fillcolor=white,style=filled]
            rank=same;
            n0 -> n1 -> n2 -> n3 -> n4 
            style=invis
        }

        subgraph cluster_2 {
            r0 [label="2" shape=circle,color=blue,fillcolor=lightblue,style=filled]
            r1 [label="1" shape=circle,color=blue,fillcolor=lightblue,style=filled]
            r2 [label="4" shape=circle,color=yellow,fillcolor=lightyellow,style=filled]
            r3 [label="3" shape=circle,color=yellow,fillcolor=lightyellow,style=filled]
            r4 [label="5" shape=circle,color=black,fillcolor=white,style=filled]

            rank=same;
            r0 -> r1 -> r2 -> r3 -> r4 
            style=invis
        }    

        n2 -> r2[constraint=false,color="red",pad=30]    

    }

    label=<<B>图 1.1 示例一</B>>
}</div></div>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入：head</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]<span class="string">,</span> <span class="string">k</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">输出：[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode nextNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 遍历计算链表长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 每组k各元素，计算分组数</span></span><br><span class="line">        <span class="keyword">int</span> group = len / k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 分别处理每个组，分别进行反转</span></span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt;= group; idx++) &#123;</span><br><span class="line">            newHead = reverseBetween(head, k * (idx - <span class="number">1</span>) + <span class="number">1</span>, k * idx);</span><br><span class="line">            head = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转链表区间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 链表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 区间左</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 区间右</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新链表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || right == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            head.next = reverseBetween(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverse(head, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转链表前right个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head  链表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 前right个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新链表头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || right == <span class="number">1</span>) &#123;</span><br><span class="line">            nextNode = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverse(head.next, right - <span class="number">1</span>);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = nextNode;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
        <tag>难度困难</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-26 删除有序数组中的重复项</title>
    <url>/2021/09/10/leetcode-26/</url>
    <content><![CDATA[<p>题目描述：给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != nums[left]) &#123;</span><br><span class="line">                nums[++left] = nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>有序数组</tag>
        <tag>重复项</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-27 移除元素</title>
    <url>/2021/09/12/leetcode-27/</url>
    <content><![CDATA[<p>题目描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] != val) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] == val) &#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>重复项</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-283 移动零</title>
    <url>/2021/09/13/leetcode-283/</url>
    <content><![CDATA[<p>题目描述：给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[left++] = nums[right++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            nums[left++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度简单</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-295 数据流的中位数</title>
    <url>/2021/08/18/leetcode-295/</url>
    <content><![CDATA[<p>题目描述：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; small;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; large;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.large = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.small = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.small.size() &gt;= <span class="keyword">this</span>.large.size()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.small.add(num);</span><br><span class="line">            <span class="keyword">this</span>.large.add(<span class="keyword">this</span>.small.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.large.add(num);</span><br><span class="line">            <span class="keyword">this</span>.small.add(<span class="keyword">this</span>.large.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.small.size() &gt; <span class="keyword">this</span>.large.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.small.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.small.size() &lt; <span class="keyword">this</span>.large.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.large.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>.large.peek() + <span class="keyword">this</span>.small.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度困难</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-297 二叉树的序列化与反序列化</title>
    <url>/2021/08/15/leetcode-297/</url>
    <content><![CDATA[<p>题目描述：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 104]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="前序实现"><a href="#前序实现" class="headerlink" title="前序实现"></a>前序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NULL_NODE = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SEPARATOR = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NULL_NODE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(root.val) + SEPARATOR + serialize(root.left) + SEPARATOR + serialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 分离二叉树节点</span></span><br><span class="line">        String[] allNodeVal = data.split(SEPARATOR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 尾插法二叉树节点</span></span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String nodeVal : allNodeVal) &#123;</span><br><span class="line">            nodes.addLast(nodeVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 递归处理二叉树节点</span></span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodes LinkedList&lt;String&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理非空节点</span></span><br><span class="line">        String firstVal = nodes.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (NULL_NODE.equals(firstVal)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(firstVal));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 递归处理左子树</span></span><br><span class="line">        node.left = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 递归处理右子树</span></span><br><span class="line">        node.right = deserialize(nodes);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="后序实现"><a href="#后序实现" class="headerlink" title="后序实现"></a>后序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NULL_NODE = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SEPARATOR = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NULL_NODE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serialize(root.left) + SEPARATOR + serialize(root.right) + SEPARATOR + String.valueOf(root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 分离二叉树节点</span></span><br><span class="line">        String[] nodes = data.split(SEPARATOR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 头插法二叉树节点</span></span><br><span class="line">        LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">            list.addFirst(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 递归处理二叉树节点</span></span><br><span class="line">        <span class="keyword">return</span> deserialize(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodes LinkedList&lt;String&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理非空节点</span></span><br><span class="line">        String firstVal = nodes.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (NULL_NODE.equals(firstVal)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(firstVal));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 递归处理右子树</span></span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 递归处理左子树</span></span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序实现"><a href="#中序实现" class="headerlink" title="中序实现"></a>中序实现</h3><p>中序只能序列化，无法反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NULL_NODE = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SEPARATOR = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NULL_NODE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serialize(root.left) + SEPARATOR + String.valueOf(root.val) + SEPARATOR + serialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序实现"><a href="#层序实现" class="headerlink" title="层序实现"></a>层序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NULL_NODE = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SEPARATOR = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 层序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 序列化字符串</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 层序遍历</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = list.removeFirst();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(NULL_NODE).append(SEPARATOR);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(node.val).append(SEPARATOR);</span><br><span class="line">            list.addLast(node.left);</span><br><span class="line">            list.addLast(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 排除最后一个多余的分隔符</span></span><br><span class="line">        <span class="keyword">return</span> sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理根节点</span></span><br><span class="line">        String[] nodes = data.split(SEPARATOR);</span><br><span class="line">        LinkedList&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 层序遍历</span></span><br><span class="line">        list.addLast(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodes.length; ) &#123;</span><br><span class="line">            TreeNode parent = list.removeFirst();</span><br><span class="line">            <span class="comment">//3.1 处理左节点</span></span><br><span class="line">            String left = nodes[i++];</span><br><span class="line">            <span class="keyword">if</span> (NULL_NODE.equals(left)) &#123;</span><br><span class="line">                parent.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(left));</span><br><span class="line">                list.addLast(parent.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.2 处理右节点</span></span><br><span class="line">            String right = nodes[i++];</span><br><span class="line">            <span class="keyword">if</span> (NULL_NODE.equals(right)) &#123;</span><br><span class="line">                parent.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(right));</span><br><span class="line">                list.addLast(parent.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>序列化与反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-3 无重复字符的最长子串</title>
    <url>/2021/09/07/leetcode-3/</url>
    <content><![CDATA[<p>题目描述：给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, start = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            need.merge(c, <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">            <span class="keyword">while</span> (need.get(c).equals(<span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - <span class="number">1</span> - left &gt; len) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - <span class="number">1</span> - left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                need.compute(l, (k, v) -&gt; --v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left &gt; len ? right - left : len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>字符串</tag>
        <tag>无重复</tag>
        <tag>最长字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-300 最长递增子序列</title>
    <url>/2021/09/15/leetcode-300/</url>
    <content><![CDATA[<p>题目描述：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>递增子序列</tag>
        <tag>最长</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-341 扁平化嵌套列表迭代器</title>
    <url>/2021/08/16/leetcode-341/</url>
    <content><![CDATA[<p>题目描述：给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。</p>
<p>实现扁平迭代器类 NestedIterator ：</p>
<ol>
<li>NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器。</NestedInteger></li>
</ol>
<ul>
<li><p>int next() 返回嵌套列表的下一个整数。</p>
</li>
<li><p>boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。<br>你的代码将会用下述伪代码检测：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">initialize iterator with nestedList</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> iterator.hasNext()</span><br><span class="line">    append iterator.next() to the end of res</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="NestedInteger"><a href="#NestedInteger" class="headerlink" title="NestedInteger"></a>NestedInteger</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;NestedInteger&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedInteger</span><span class="params">(Integer node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedInteger</span><span class="params">(List&lt;NestedInteger&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.node = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.node != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Integer&gt; it;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 扁平化展开嵌套列表</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger nit : nestedList) &#123;</span><br><span class="line">            traverse(nit, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理展开后的列表</span></span><br><span class="line">        <span class="keyword">this</span>.it = list.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.it.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.it.hasNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归展开列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nit  NestedInteger</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list List&lt;Integer&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(NestedInteger nit, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nit.isInteger()) &#123;</span><br><span class="line">            list.add(nit.getInteger());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger childNit : nit.getList()) &#123;</span><br><span class="line">            traverse(childNit, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="惰性实现"><a href="#惰性实现" class="headerlink" title="惰性实现"></a>惰性实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;NestedInteger&gt; it;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.it = <span class="keyword">new</span> LinkedList&lt;&gt;(nestedList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.it.remove(<span class="number">0</span>).getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断下一个原始是否是Integer</span></span><br><span class="line"><span class="comment">     * 如果是Integer则直接返回</span></span><br><span class="line"><span class="comment">     * 如果不是则使用头插法展开</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.it.isEmpty() &amp;&amp; !<span class="keyword">this</span>.it.get(<span class="number">0</span>).isInteger()) &#123;</span><br><span class="line">            List&lt;NestedInteger&gt; nit = <span class="keyword">this</span>.it.remove(<span class="number">0</span>).getList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nit.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">this</span>.it.addFirst(nit.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.it.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>扁平化迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-344 反转字符串</title>
    <url>/2021/09/04/leetcode-344/</url>
    <content><![CDATA[<p>题目描述：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> odd = s.length % <span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> half = s.length / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= half; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            s[i] = s[s.length - <span class="number">1</span> - i];</span><br><span class="line">            s[s.length - <span class="number">1</span> - i] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>反转字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-354 俄罗斯套娃信封问题</title>
    <url>/2021/09/16/leetcode-354/</url>
    <content><![CDATA[<p>题目描述：给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。</p>
<p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(envelopes, (o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> o2[<span class="number">1</span>] - o1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; envelopes.length; i++) &#123;</span><br><span class="line">            nums[i] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lengthOfLIS(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度困难</tag>
        <tag>俄罗斯套娃</tag>
        <tag>信封</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-355 设计推特</title>
    <url>/2021/08/22/leetcode-355/</url>
    <content><![CDATA[<p>题目描述：设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：</p>
<ol>
<li>postTweet(userId, tweetId): 创建一条新的推文</li>
<li>getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。</li>
<li>follow(followerId, followeeId): 关注一个用户</li>
<li>unfollow(followerId, followeeId): 取消关注一个用户</li>
</ol>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tweet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Tweet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer tweetId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(Integer tweetId, Long createTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tweetId = tweetId;</span><br><span class="line">        <span class="keyword">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getTweetId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tweetId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTweetId</span><span class="params">(Integer tweetId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tweetId = tweetId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getCreateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreateTime</span><span class="params">(Long createTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Tweet o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="keyword">this</span>.createTime - o.getCreateTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Tweet&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;tweetId=&quot;</span> + tweetId +</span><br><span class="line">                <span class="string">&quot;, createTime=&quot;</span> + createTime +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; followerIds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; followeeIds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Tweet&gt; tweets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer userId, List&lt;Integer&gt; followerIds, List&lt;Integer&gt; followeeIds, LinkedList&lt;Tweet&gt; tweets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.followerIds = followerIds;</span><br><span class="line">        <span class="keyword">this</span>.followeeIds = followeeIds;</span><br><span class="line">        <span class="keyword">this</span>.tweets = tweets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getFollowerIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> followerIds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFollowerIds</span><span class="params">(List&lt;Integer&gt; followerIds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.followerIds = followerIds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getFolloweeIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> followeeIds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFolloweeIds</span><span class="params">(List&lt;Integer&gt; followeeIds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.followeeIds = followeeIds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LinkedList&lt;Tweet&gt; <span class="title">getTweets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tweets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTweets</span><span class="params">(LinkedList&lt;Tweet&gt; tweets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tweets = tweets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userId=&quot;</span> + userId +</span><br><span class="line">                <span class="string">&quot;, followerIds=&quot;</span> + followerIds +</span><br><span class="line">                <span class="string">&quot;, followeeIds=&quot;</span> + followeeIds +</span><br><span class="line">                <span class="string">&quot;, tweets=&quot;</span> + tweets +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, User&gt; users;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.users = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        Tweet tweet = <span class="keyword">new</span> Tweet(tweetId, System.nanoTime());</span><br><span class="line">        User user = <span class="keyword">this</span>.users.getOrDefault(userId, createUser(userId));</span><br><span class="line">        user.getTweets().addFirst(tweet);</span><br><span class="line">        <span class="keyword">if</span> (user.getTweets().size() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            user.getTweets().subList(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.users.put(userId, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.users.containsKey(userId)) &#123;</span><br><span class="line">            List&lt;Tweet&gt; tweets = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            tweets.addAll(<span class="keyword">this</span>.users.get(userId).getTweets());</span><br><span class="line">            <span class="keyword">this</span>.users.get(userId).getFollowerIds().stream().map(<span class="keyword">this</span>.users::get).map(User::getTweets).forEach(list -&gt; tweets.addAll(list));</span><br><span class="line">            List&lt;Integer&gt; result = tweets.stream().sorted(Comparator.reverseOrder()).distinct().map(Tweet::getTweetId).collect(Collectors.toList());</span><br><span class="line">            <span class="keyword">return</span> result.size() &gt; <span class="number">10</span> ? result.subList(<span class="number">0</span>, <span class="number">10</span>) : result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        User follower = <span class="keyword">this</span>.users.getOrDefault(followerId, createUser(followerId));</span><br><span class="line">        follower.getFollowerIds().add(followeeId);</span><br><span class="line">        <span class="keyword">this</span>.users.put(followerId, follower);</span><br><span class="line">        User followee = <span class="keyword">this</span>.users.getOrDefault(followeeId, createUser(followeeId));</span><br><span class="line">        followee.getFolloweeIds().add(followerId);</span><br><span class="line">        <span class="keyword">this</span>.users.put(followeeId, followee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.users.get(followerId).getFollowerIds().remove((Object) followeeId);</span><br><span class="line">        <span class="keyword">this</span>.users.get(followeeId).getFolloweeIds().remove((Object) followerId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> User <span class="title">createUser</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(userId, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-380  O(1) 时间插入、删除和获取随机元素</title>
    <url>/2021/09/08/leetcode-380/</url>
    <content><![CDATA[<p>题目描述：设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。</p>
<p>insert(val)：当元素 val 不存在时，向集合中插入该项。<br>remove(val)：元素 val 存在时，从集合中移除该项。<br>getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; array;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; valToIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.valToIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.valToIndex.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.array.add(val);</span><br><span class="line">        <span class="keyword">this</span>.valToIndex.put(val, <span class="keyword">this</span>.array.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.valToIndex.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="keyword">this</span>.valToIndex.get(val);</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="keyword">this</span>.array.get(idx);</span><br><span class="line">        <span class="keyword">this</span>.array.set(idx, <span class="keyword">this</span>.array.get(<span class="keyword">this</span>.array.size() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">this</span>.valToIndex.put(<span class="keyword">this</span>.array.get(idx), idx);</span><br><span class="line">        <span class="keyword">this</span>.array.set(<span class="keyword">this</span>.array.size() - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">this</span>.array.remove(<span class="keyword">this</span>.array.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.valToIndex.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> index = random.nextInt(<span class="keyword">this</span>.array.size());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-410 分割数组的最大值</title>
    <url>/2021/08/29/leetcode-410/</url>
    <content><![CDATA[<p>题目描述：给定一个非负整数数组 <code>nums</code> 和一个整数 <code>m</code> ，你需要将这个数组分成 <code>m</code> 个非空的连续子数组。</p>
<p>设计一个算法使得这 <code>m</code> 个子数组各自和的最大值最小。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minSum = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; minSum) &#123;</span><br><span class="line">                minSum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = minSum;</span><br><span class="line">        <span class="keyword">int</span> right = maxSum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> currentM = calculateM(nums, mid);</span><br><span class="line">            <span class="keyword">if</span> (currentM == m) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentM &gt; m) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentM &lt; m) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateM</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpSum = sum;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpSum &gt;= nums[i]) &#123;</span><br><span class="line">                tmpSum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">                    m++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmpSum = sum;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
        <tag>难度中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-438 找到字符串中所有字母异位词</title>
    <url>/2021/09/06/leetcode-438/</url>
    <content><![CDATA[<p>题目描述：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>异位词 指字母相同，但排列不同的字符串。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">            need.merge(p.charAt(i), <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, valid = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(r)) &#123;</span><br><span class="line">                window.merge(r, <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">                <span class="keyword">if</span> (window.get(r).equals(need.get(r))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (right - left == p.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (valid == need.size()) &#123;</span><br><span class="line">                    res.add(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(l)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window.get(l).equals(need.get(l))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window.compute(l, (k, v) -&gt; --v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>字符串</tag>
        <tag>排列</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-450 删除二叉搜索树中的节点</title>
    <url>/2021/08/10/leetcode-450/</url>
    <content><![CDATA[<p>题目描述：给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：</p>
<ul>
<li><p>首先找到需要删除的节点；</p>
</li>
<li><p>如果找到了，删除它。</p>
</li>
</ul>
<p>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode minNode = getMinNode(root.right);</span><br><span class="line">            root.val = minNode.val;</span><br><span class="line">            root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">getMinNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉搜索树</tag>
        <tag>删除节点</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-496 下一个更大元素 I</title>
    <url>/2021/08/23/leetcode-496/</url>
    <content><![CDATA[<p>题目描述：给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p>
<p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; maps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums2.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums2[i]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            Integer nextMaxVal = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            maps.put(nums2[i], nextMaxVal);</span><br><span class="line">            stack.add(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            res[i] = maps.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-503 下一个更大元素 II</title>
    <url>/2021/08/24/leetcode-503/</url>
    <content><![CDATA[<p>题目描述：给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cycle = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length * <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(nums, <span class="number">0</span>, cycle, <span class="number">0</span>, nums.length);</span><br><span class="line">        System.arraycopy(nums, <span class="number">0</span>, cycle, nums.length, nums.length);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[cycle.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cycle.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= cycle[i]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nextMax = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            res[i] = nextMax;</span><br><span class="line">            stack.push(cycle[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-53 最大子序和</title>
    <url>/2021/09/17/leetcode-53/</url>
    <content><![CDATA[<p>题目描述：给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>数组</tag>
        <tag>子数和</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-538 把二叉搜索树转换为累加树</title>
    <url>/2021/08/06/leetcode-538/</url>
    <content><![CDATA[<p>题目描述：给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 小于 节点键的节点。</li>
<li>节点的右子树仅包含键 大于 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="后序实现"><a href="#后序实现" class="headerlink" title="后序实现"></a>后序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inorders(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">            nodes.get(i).val = nodes.get(i - <span class="number">1</span>).val + nodes.get(i).val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorders</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.right);</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        inorders(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inorders(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorders</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        inorders(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉搜索时树</tag>
        <tag>累加树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-567 字符串的排列</title>
    <url>/2021/09/05/leetcode-567/</url>
    <content><![CDATA[<p>题目描述：给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。</p>
<p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            need.merge(s1.charAt(i), <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> r = s2.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(r)) &#123;</span><br><span class="line">                window.merge(r, <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">                <span class="keyword">if</span> (window.get(r).equals(need.get(r))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (right - left == s1.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (valid == need.size()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> l = s2.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(l)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window.get(l).equals(need.get(l))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window.compute(l, (k, v) -&gt; --v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>字符串</tag>
        <tag>排列</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-583 两个字符串的删除操作</title>
    <url>/2021/09/19/leetcode-583/</url>
    <content><![CDATA[<p>题目描述：给定两个单词 <em>word1</em> 和 <em>word2</em>，找到使得 <em>word1</em> 和 <em>word2</em> 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] nums1 = word1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] nums2 = word2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> longestCommon = longestCommonSubsequence(nums1, nums2);</span><br><span class="line">        <span class="keyword">return</span> nums1.length + nums2.length - longestCommon * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="keyword">char</span>[] nums1, <span class="keyword">char</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums1.length][nums2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>字符串</tag>
        <tag>删除</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-652 寻找重复的子树</title>
    <url>/2021/08/04/leetcode-652/</url>
    <content><![CDATA[<p>题目描述：给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p>
<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Integer&gt; subTrees = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; duplicate = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        findDuplicateSubtrees(root);</span><br><span class="line">        <span class="keyword">return</span> duplicate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">postorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String left = postorder(root.left);</span><br><span class="line">        String right = postorder(root.right);</span><br><span class="line">        String subTree = left + <span class="string">&quot;,&quot;</span> + right + <span class="string">&quot;,&quot;</span> + root.val;</span><br><span class="line">        <span class="keyword">int</span> frequency = subTrees.getOrDefault(subTree, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (frequency == <span class="number">1</span>) &#123;</span><br><span class="line">            duplicate.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        subTrees.put(subTree, frequency + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> subTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>重复子树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-654 最大二叉树</title>
    <url>/2021/08/01/leetcode-654/</url>
    <content><![CDATA[<p>题目描述：给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：</p>
<ul>
<li>二叉树的根是数组 nums 中的最大元素。</li>
<li>左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。</li>
<li>右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。</li>
</ul>
<p>返回有给定数组 nums 构建的 最大二叉树 。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> constructMaximumBinaryTree(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 单个元素直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (start == end - <span class="number">1</span>) &#123;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(nums[start]);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 寻找最大元素</span></span><br><span class="line">        <span class="keyword">int</span> maxVal = nums[start];</span><br><span class="line">        <span class="keyword">int</span> maxIdx = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt; end; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] &gt; maxVal) &#123;</span><br><span class="line">                maxVal = nums[idx];</span><br><span class="line">                maxIdx = idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 最大元素为根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(maxVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 最大元素左边为左子树</span></span><br><span class="line">        TreeNode leftNode = constructMaximumBinaryTree(nums, start, maxIdx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 最大元素右边为右子树</span></span><br><span class="line">        TreeNode rightNode = constructMaximumBinaryTree(nums, maxIdx + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 连接左右子树</span></span><br><span class="line">        root.left = leftNode;</span><br><span class="line">        root.right = rightNode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-700 二叉搜索树中的搜索</title>
    <url>/2021/08/12/leetcode-700/</url>
    <content><![CDATA[<p>题目描述：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>提示：</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode searchNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        search(root, val);</span><br><span class="line">        <span class="keyword">return</span> searchNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">            searchNode = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            search(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            search(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉搜索树</tag>
        <tag>难度简单</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-701 二叉搜索树中的插入操作</title>
    <url>/2021/08/11/leetcode-701/</url>
    <content><![CDATA[<p>题目描述：给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<p>提示：</p>
<ul>
<li>给定的树上的节点数介于 0 和 10^4 之间</li>
<li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li>
<li>-10^8 &lt;= val &lt;= 10^8</li>
<li>新值和原始二叉搜索树中的任意节点值都不同</li>
</ul>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉搜索树</tag>
        <tag>插入</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-710 黑名单中的随机数</title>
    <url>/2021/09/09/leetcode-710/</url>
    <content><![CDATA[<p>题目描述：给定一个包含 [0，n) 中不重复整数的黑名单 blacklist ，写一个函数从 [0, n) 中返回一个不在 blacklist 中的随机整数。</p>
<p>对它进行优化使其尽量少调用系统方法 Math.random() 。</p>
<p>提示:</p>
<p>1 &lt;= n &lt;= 1000000000<br>0 &lt;= blacklist.length &lt; min(100000, N)<br>[0, n) 不包含 n ，详细参见 interval notation 。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; blackMapping;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] blacklist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.N = n;</span><br><span class="line">        <span class="keyword">this</span>.blackMapping = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b : blacklist) &#123;</span><br><span class="line">            <span class="keyword">this</span>.blackMapping.put(b, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> whiteSize = <span class="keyword">this</span>.N - blacklist.length;</span><br><span class="line">        <span class="keyword">int</span> left = whiteSize;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b : blacklist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &lt; whiteSize) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">this</span>.blackMapping.containsKey(left)) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.blackMapping.put(b, left++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> idx = random.nextInt(N - <span class="keyword">this</span>.blackMapping.size());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.blackMapping.containsKey(idx)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.blackMapping.get(idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度困难</tag>
        <tag>黑名单</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-712 两个字符串的最小ASCII删除和</title>
    <url>/2021/09/20/leetcode-712/</url>
    <content><![CDATA[<p>题目描述：给定两个字符串<code>s1, s2</code>，找到使两个字符串相等所需删除字符的ASCII值的最小和。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seqLen;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sumAsc;</span><br><span class="line">    <span class="keyword">private</span> String longestSeq;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSeqLen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seqLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeqLen</span><span class="params">(<span class="keyword">int</span> seqLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seqLen = seqLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLongestSeq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longestSeq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLongestSeq</span><span class="params">(String longestSeq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.longestSeq = longestSeq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSumAsc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sumAsc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSumAsc</span><span class="params">(<span class="keyword">int</span> sumAsc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sumAsc = sumAsc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> seqLen, <span class="keyword">int</span> sumAsc, String longestSeq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seqLen = seqLen;</span><br><span class="line">        <span class="keyword">this</span>.sumAsc = sumAsc;</span><br><span class="line">        <span class="keyword">this</span>.longestSeq = longestSeq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        Node maxNode = longestCommonSubsequence(s1.toCharArray(), s2.toCharArray());</span><br><span class="line">        <span class="keyword">int</span> sumS1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            sumS1 += s1.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sumS2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length(); i++) &#123;</span><br><span class="line">            sumS2 += s2.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sumM = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxNode.getLongestSeq().length(); i++) &#123;</span><br><span class="line">            sumM += maxNode.getLongestSeq().charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumS1 + sumS2 - sumM * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">longestCommonSubsequence</span><span class="params">(<span class="keyword">char</span>[] nums1, <span class="keyword">char</span> nums2[])</span> </span>&#123;</span><br><span class="line">        Node[][] dp = <span class="keyword">new</span> Node[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j].setSeqLen(dp[i - <span class="number">1</span>][j - <span class="number">1</span>].getSeqLen() + <span class="number">1</span>);</span><br><span class="line">                    dp[i][j].setLongestSeq(dp[i - <span class="number">1</span>][j - <span class="number">1</span>].getLongestSeq() + nums1[i - <span class="number">1</span>]);</span><br><span class="line">                    dp[i][j].setSumAsc(dp[i - <span class="number">1</span>][j - <span class="number">1</span>].getSumAsc() + nums1[i - <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node rNode = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    Node cNode = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    Node maxNode = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (rNode.getSeqLen() == cNode.getSeqLen()) &#123;</span><br><span class="line">                        maxNode = rNode.getSumAsc() &gt; cNode.getSumAsc() ? rNode : cNode;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rNode.getSeqLen() &lt; cNode.getSeqLen()) &#123;</span><br><span class="line">                        maxNode = cNode;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        maxNode = rNode;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j] = maxNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums1.length][nums2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>字符串</tag>
        <tag>最小ASCII删除和</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-72 编辑距离</title>
    <url>/2021/09/14/leetcode-72/</url>
    <content><![CDATA[<p>题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> dp1, <span class="keyword">int</span> dp2, <span class="keyword">int</span> dp3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(dp1, dp2), dp3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度困难</tag>
        <tag>两个单词</tag>
        <tag>转换</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-76 最小覆盖子串</title>
    <url>/2021/09/05/leetcode-76/</url>
    <content><![CDATA[<p>题目描述：给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need.merge(t.charAt(i), <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, start = <span class="number">0</span>, valid = <span class="number">0</span>, len = s.length() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">                window.merge(c, <span class="number">1</span>, (oldVal, newVal) -&gt; ++oldVal);</span><br><span class="line">                <span class="keyword">if</span> (need.get(c).equals(window.get(c))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (valid == need.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(l)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window.get(l).equals(need.get(l))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window.compute(l, (k, v) -&gt; --v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == s.length() + <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.substring(start, start + len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>字符串</tag>
        <tag>难度困难</tag>
        <tag>子串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-797 所有可能的路径</title>
    <url>/2021/08/14/leetcode-797/</url>
    <content><![CDATA[<p>题目描述：给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。提示：</p>
<ul>
<li>n == graph.length</li>
<li>2 &lt;= n &lt;= 15</li>
<li>0 &lt;= graph[i][j] &lt; n</li>
<li>graph[i][j] != i </li>
<li>保证输入为有向无环图 (GAD)</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; allPaths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        path.add(<span class="number">0</span>);</span><br><span class="line">        allPathsSourceTarget(graph, <span class="number">0</span>, graph.length - <span class="number">1</span>, path);</span><br><span class="line">        <span class="keyword">return</span> allPaths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allPathsSourceTarget</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> k, <span class="keyword">int</span> n, List&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; currentPath = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">        <span class="keyword">if</span> (k == n) &#123;</span><br><span class="line">            allPaths.add(currentPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : graph[k])&#123;</span><br><span class="line">            currentPath.add(i);</span><br><span class="line">            allPathsSourceTarget(graph, i, n, currentPath);</span><br><span class="line">            currentPath.remove(currentPath.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>有向无环图</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-83 删除排序链表中的重复元素</title>
    <url>/2021/09/11/leetcode-83/</url>
    <content><![CDATA[<p>题目描述：存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p>
<p>返回同样按升序排列的结果链表。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode left = head, right = head.next;</span><br><span class="line">        <span class="keyword">while</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">                left.next = right;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>重复项</tag>
        <tag>有序链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-870 优势洗牌</title>
    <url>/2021/08/26/leetcode-870/</url>
    <content><![CDATA[<p>题目描述：给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] &gt; B[i] 的索引 i 的数目来描述。</p>
<p>返回 A 的任意排列，使其相对于 B 的优势最大化。</p>
<a id="more"></a>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Pair</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Pair o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getValue() - o.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair <span class="title">of</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Pair pair = <span class="keyword">new</span> Pair();</span><br><span class="line">        pair.setIndex(index);</span><br><span class="line">        pair.setValue(value);</span><br><span class="line">        <span class="keyword">return</span> pair;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] advantageCount(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums1.length;</span><br><span class="line">        PriorityQueue&lt;Pair&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((p1, p2) -&gt; p2.compareTo(p1));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            queue.add(Pair.of(i, nums2[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        <span class="keyword">int</span> idx1Start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx1End = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Pair maxPair = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (maxPair.getValue() &lt; nums1[idx1End]) &#123;</span><br><span class="line">                res[maxPair.getIndex()] = nums1[idx1End];</span><br><span class="line">                idx1End--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res[maxPair.getIndex()] = nums1[idx1Start];</span><br><span class="line">                idx1Start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>优势洗牌</tag>
        <tag>田忌赛马</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-875 爱吃香蕉的珂珂</title>
    <url>/2021/08/27/leetcode-875/</url>
    <content><![CDATA[<p>题目描述：珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p>
<p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p>
<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>
<p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = piles.length;</span><br><span class="line">        <span class="keyword">int</span> maxSpeed = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (piles[i] &gt; maxSpeed) &#123;</span><br><span class="line">                maxSpeed = piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = maxSpeed + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> hour = calculateHour(piles, mid);</span><br><span class="line">            <span class="keyword">if</span> (hour == h) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hour &lt; h) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hour &gt; h) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateHour</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hours = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; piles.length; i++) &#123;</span><br><span class="line">            hours += (piles[i] / speed + (piles[i] % speed != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hours;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-876 链表的中间结点</title>
    <url>/2021/09/01/leetcode-876/</url>
    <content><![CDATA[<p>题目描述：给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fastNode = head;</span><br><span class="line">        ListNode slowNode = head;</span><br><span class="line">        <span class="keyword">while</span> (fastNode != <span class="keyword">null</span> &amp;&amp; fastNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fastNode = fastNode.next.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度简单</tag>
        <tag>链表</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-895 最大频率栈</title>
    <url>/2021/08/21/leetcode-895/</url>
    <content><![CDATA[<p>题目描述：实现 FreqStack，模拟类似栈的数据结构的操作的一个类。</p>
<p>FreqStack 有两个函数：</p>
<ul>
<li>push(int x)，将整数 x 推入栈中。</li>
<li>pop()，它移除并返回栈中出现最频繁的元素。<br>如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。</li>
</ul>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>```java<br>class FreqStack {<br>    // 记录 FreqStack 中元素的最大频率<br>    private int maxFreq = 0;<br>    // 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表<br>    private HashMap<Integer, integer> valToFreq = new HashMap&lt;&gt;();<br>    // 记录频率 freq 对应的 val 列表，后文就称为 FV 表<br>    private HashMap<Integer, stack<integer>&gt; freqToVals = new HashMap&lt;&gt;();</Integer,></Integer,></p>
<pre><code>public FreqStack() &#123;
&#125;

public void push(int val) &#123;
    //1. 计算每个元素出现的频率
    int frequency = this.valToFreq.getOrDefault(val, 0);
    frequency++;
    this.valToFreq.put(val, frequency);

    //2. 计算最大频率
    maxFreq = maxFreq &gt;= frequency ? maxFreq : frequency;

    //3. 计算频率对应元素栈
    Stack&lt;Integer&gt; valStack = this.freqToVals.getOrDefault(frequency, new Stack&lt;&gt;());
    valStack.add(val);
    this.freqToVals.put(frequency, valStack);
&#125;

public int pop() &#123;
    //1. 取出弹出元素
    int val = this.freqToVals.get(maxFreq).pop();

    //2. 重新计算当前元素频率
    int frequency = this.valToFreq.get(val);
    frequency--;
    this.valToFreq.put(val, frequency);

    //3. 当前频率已经没有元素了，需要重新计算最大频率
    if (this.freqToVals.get(maxFreq).isEmpty()) &#123;
        maxFreq = frequency;
    &#125;
    return val;
&#125;
</code></pre><p>}<br>```</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度困难</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-95 不同的二叉搜索树 II</title>
    <url>/2021/08/08/leetcode-95/</url>
    <content><![CDATA[<p>题目描述：给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; root = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (end &gt; start) &#123;</span><br><span class="line">            root.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt;= end; idx++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftTree = generateTrees(start, idx - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightTree = generateTrees(idx + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span> (TreeNode leftNode : leftTree) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode rightNode : rightTree) &#123;</span><br><span class="line">                    TreeNode rootNode = <span class="keyword">new</span> TreeNode(idx);</span><br><span class="line">                    rootNode.left = leftNode;</span><br><span class="line">                    rootNode.right = rightNode;</span><br><span class="line">                    root.add(rootNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 92 反转链表 II</title>
    <url>/2021/03/28/leetcode-92/</url>
    <content><![CDATA[<p>题目描述：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<a id="more"></a>
<h2 id="原题介绍"><a href="#原题介绍" class="headerlink" title="原题介绍"></a>原题介绍</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><div><div class="graphviz">digraph leetcode_92_1 {

    bgcolor="#f7f7f7"

    rankdir=LR
    subgraph cluster_name {

        subgraph cluster_1 {
            n0 [label="1" shape=circle,color=blue,fillcolor=white,style=filled]
            n1 [label="2" shape=circle,color=blue,fillcolor=lightblue,style=filled]
            n2 [label="3" shape=circle,color=blue,fillcolor=lightblue,style=filled]
            n3 [label="4" shape=circle,color=blue,fillcolor=lightblue,style=filled]
            n4 [label="5" shape=circle,color=blue,fillcolor=white,style=filled]
            rank=same;
            n0 -> n1 -> n2 -> n3 -> n4 
            style=invis
        }

        subgraph cluster_2 {
            r0 [label="1" shape=circle,color=blue,fillcolor=white,style=filled]
            r1 [label="4" shape=circle,color=blue,fillcolor=lightblue,style=filled]
            r2 [label="3" shape=circle,color=blue,fillcolor=lightblue,style=filled]
            r3 [label="2" shape=circle,color=blue,fillcolor=lightblue,style=filled]
            r4 [label="5" shape=circle,color=blue,fillcolor=white,style=filled]

            rank=same;
            r0 -> r1 -> r2 -> r3 -> r4 
            style=invis
        }    

        n2 -> r2[constraint=false,color="red",pad=30]    

    }

    label=<<B>图 1.1 算法示意图</B>>
}</div></div>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入：head</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]<span class="string">,</span> <span class="string">left</span> <span class="string">=</span> <span class="number">2</span><span class="string">,</span> <span class="string">right</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line"><span class="string">输出：[1,4,3,2,5]</span></span><br></pre></td></tr></table></figure>
<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入：head</span> <span class="string">=</span> [<span class="number">5</span>]<span class="string">,</span> <span class="string">left</span> <span class="string">=</span> <span class="number">1</span><span class="string">,</span> <span class="string">right</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="string">输出：[5]</span></span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="遍历拆分链表"><a href="#遍历拆分链表" class="headerlink" title="遍历拆分链表"></a>遍历拆分链表</h3><p>如下图所示，通过遍历以 <code>[left，right]</code>作为分界，把链表分为三个字表。</p>
<div><div class="graphviz">digraph leetcode_92_1 {

    bgcolor="#f7f7f7"

    rankdir=LR
    subgraph cluster_name {
        subgraph cluster_1 {
            n0 [label="1" shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n1 [label="..." shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n2 [label="left-1" shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n3 [label="left" shape=circle,color=red,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
            n4 [label="..." shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
            n5 [label="right" shape=circle,color=red,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
            n6 [label="right+1" shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n7 [label="..." shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n8 [label="n" shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            rank=same;
            n0 -> n1 -> n2
            n2 -> n3[style=dashed,color=red]
            n3 -> n4 -> n5
            n5 -> n6[style=dashed,color=red]
            n6 -> n7 -> n8
            style=invis
        }

    }
    label=<<B>图 2.1 遍历拆分链表</B>>
}</div></div>



<h3 id="分别处理三个子表"><a href="#分别处理三个子表" class="headerlink" title="分别处理三个子表"></a>分别处理三个子表</h3><blockquote>
<ul>
<li>记录左边链表的head与end，记录右边链表的head。</li>
<li>遍历中间链表存入到栈当中，然后依次弹出栈中节点并链接为一个新的链表，根据栈后进先出的特性，新链表必定顺序是反过来的。</li>
<li>然后再依次按照左中右顺序拼接合并三个链表，得到最终结果。</li>
</ul>
</blockquote>
<div><div class="graphviz">digraph leetcode_92_1 {

    bgcolor="#f7f7f7"

    rankdir=LR
    subgraph cluster_name {
        subgraph cluster_1 {
            n0 [label="1" shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n1 [label="..." shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n2 [label="left-1" shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n3 [label="right" shape=circle,color=red,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
            n4 [label="..." shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
            n5 [label="left" shape=circle,color=red,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
            n6 [label="right+1" shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n7 [label="..." shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n8 [label="n" shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            rank=same;
            n0 -> n1 -> n2
            n2 -> n3[style=dashed,color=red]
            n3 -> n4 -> n5
            n5 -> n6[style=dashed,color=red]
            n6 -> n7 -> n8
            style=invis
        }

    }
    label=<<B>图 2.2 最终结果</B>>
}</div></div>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 如果链表为空或者是单节点链表直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 初始化节点栈</span></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 初始化左链表的end节点</span></span><br><span class="line">        ListNode leftLinkedListEnd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 初始化右链表的start节点</span></span><br><span class="line">        ListNode rightLinkedListStart = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 定义链表索引，并初始化为1</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 循环遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (ListNode it = head; it != <span class="keyword">null</span>; it = it.next,idx++)&#123;</span><br><span class="line">            <span class="comment">//6.1 如果是处于[left,right]之间的节点，则存入栈中</span></span><br><span class="line">            <span class="keyword">if</span> ( idx &gt;= left &amp;&amp; idx &lt;= right)&#123;</span><br><span class="line">                stack.push(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6.2 如果是处于[1,left)之间的节点，则记录其end节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (idx &lt; left)&#123;</span><br><span class="line">                leftLinkedListEnd = it;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6.3 如果是处于(right,n]之间的节点，则记录其start节点，并跳出循环结束遍历</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rightLinkedListStart = it;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 依次弹出栈中元素反转中间链表</span></span><br><span class="line">        ListNode midLinkedListHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode midLinkedListEnd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (midLinkedListHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">                midLinkedListHead = stack.pop();</span><br><span class="line">                midLinkedListEnd = midLinkedListHead;</span><br><span class="line">                midLinkedListEnd.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                midLinkedListEnd.next = stack.pop();</span><br><span class="line">                midLinkedListEnd = midLinkedListEnd.next;</span><br><span class="line">                midLinkedListEnd.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8. 合并左链表</span></span><br><span class="line">        <span class="keyword">if</span> (leftLinkedListEnd != <span class="keyword">null</span>)&#123;</span><br><span class="line">            leftLinkedListEnd.next = midLinkedListHead;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            head = midLinkedListHead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9. 合并右链表</span></span><br><span class="line">        <span class="keyword">if</span> (rightLinkedListStart != <span class="keyword">null</span>)&#123;</span><br><span class="line">            midLinkedListEnd.next = rightLinkedListStart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//10. 返回最终链表head节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 临时节点</span></span><br><span class="line">    <span class="keyword">private</span> ListNode node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2. 判空处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 递归处理</span></span><br><span class="line">        <span class="keyword">return</span> reverse(head, left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reverse 前n个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n    前n个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. n==1表示一个元素直接返回，并记录后区节点</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.node = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 递归得到head.next后面的反转</span></span><br><span class="line">        ListNode end = reverse(head.next, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 反转 head 和 end</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 新的尾节点指向保存的后驱节点</span></span><br><span class="line">        head.next = <span class="keyword">this</span>.node;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reverse 中间n个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head  表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 有边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 如果left == 1 递归反转前n个元素</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> reverse(head, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 递归找到待反转起始位置</span></span><br><span class="line">        head.next = reverse(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" title="原题地址">原题地址</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-96 不同的二叉搜索树</title>
    <url>/2021/08/07/leetcode-96/</url>
    <content><![CDATA[<p>题目描述：给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt;= start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt;= end; idx++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftTreeStart = start;</span><br><span class="line">            <span class="keyword">int</span> leftTreeEnd = idx - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightTreeStart = idx + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightTreeEnd = end;</span><br><span class="line">            <span class="keyword">int</span> leftNum = (leftTreeEnd - leftTreeStart &lt; <span class="number">1</span>) ? <span class="number">1</span> : numTrees(leftTreeStart, leftTreeEnd);</span><br><span class="line">            <span class="keyword">int</span> rightNum = (rightTreeEnd - rightTreeStart &lt; <span class="number">1</span>) ? <span class="number">1</span> : numTrees(rightTreeStart, rightTreeEnd);</span><br><span class="line">            sum += leftNum * rightNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-98 验证二叉搜索树</title>
    <url>/2021/08/13/leetcode-98/</url>
    <content><![CDATA[<p>题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>难度中等</tag>
        <tag>oj</tag>
        <tag>二叉树搜索树</tag>
        <tag>验证</tag>
      </tags>
  </entry>
  <entry>
    <title>反转单链表的前n个元素</title>
    <url>/2021/04/01/reverse-linked-list-top-n/</url>
    <content><![CDATA[<p>反转单链表的前n个元素与反转单链表是类似的问题，同理其也会有三种方法去解决。可以增加一个栈来解决，这样相当于只对前n个元素进行压栈处理，同理也可以用遍历的方法解决，由于能用栈解决同样也就可以使用递归的方式解决。</p>
<a id="more"></a>
<h2 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h2><h2 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h2><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>难度中等</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/03/30/reverse-linked-list/</url>
    <content><![CDATA[<p>单链表的反转，我们能想到反转顺序最简单的数据结构就是栈了，如果可以用栈的话，那问题就简单了。顺序遍历单链表，依次入栈直到遍历结束，然后依次出栈重新有前到后连接为一个新的单链表，则自动实现了反转功能。</p>
<a id="more"></a>
<h2 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 遍历链表入栈</span></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 出栈重新建立链表</span></span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode newEnd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (newHead == <span class="keyword">null</span>)&#123;</span><br><span class="line">                newHead = node;</span><br><span class="line">                newEnd = newHead;</span><br><span class="line">                newHead.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                newEnd.next = node;</span><br><span class="line">                newEnd = newEnd.next;</span><br><span class="line">                newEnd.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h2><h3 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h3><div><div class="graphviz">digraph leetcode_92_1 {

    bgcolor="#f7f7f7"

    rankdir=LR
    subgraph cluster_name {
        subgraph cluster_1 {
            n0 [label="newEnd" shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n1 [label="..." shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n2 [label="newHead" shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
            n3 [label="node" shape=circle,color=red,style=dashed,width=0.8,fixedsize=true]
            n4 [label="oldHead" shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
            n5 [label="..." shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
            n6 [label="oldEnd" shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]

            rank=same;
            n0 -> n1 -> n2[dir=back]
            n2 -> n3[style=dashed,color="#f7f7f7"]
            n3 -> n4[style=dashed,color=red]
            n4 -> n5 -> n6
            style=invis
        }

    }
    label=<<B>图 1.1 遍历反转链表</B>>
}</div></div>



<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 设置反转后新链表表头节点</span></span><br><span class="line">        ListNode newLinkedListHead = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 设置反转前旧链表表头节点</span></span><br><span class="line">        ListNode oldLinkedListHead = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 设置临时节点</span></span><br><span class="line">        ListNode tmpNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 遍历旧链表</span></span><br><span class="line">        <span class="keyword">while</span> (oldLinkedListHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//5.1 取出当前节点到临时节点</span></span><br><span class="line">            tmpNode = oldLinkedListHead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.2 重新设置旧链表表头</span></span><br><span class="line">            oldLinkedListHead = oldLinkedListHead.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.3 把取出的临时节点添加到反转后新链表的表头</span></span><br><span class="line">            <span class="keyword">if</span> (newLinkedListHead == <span class="keyword">null</span>)&#123;</span><br><span class="line">                newLinkedListHead = tmpNode;</span><br><span class="line">                newLinkedListHead.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                tmpNode.next = newLinkedListHead;</span><br><span class="line">                newLinkedListHead = tmpNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6. 返回反转后新链表</span></span><br><span class="line">        <span class="keyword">return</span> newLinkedListHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p>递归实现的原理和栈是类似的，因为递归本身就是利用了程序栈进行了压栈处理，因此好好理解一下第一种算法与第三种算法，有助于理解递归的原理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取递归得到的新表头</span></span><br><span class="line">        ListNode newHead = reverse(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 处理当前节点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 处理完之后新的尾节点置空</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 返回新的表头节点</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>难度中等</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>九寨沟旅游攻略</title>
    <url>/2022/10/12/%E4%B9%9D%E5%AF%A8%E6%B2%9F%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<p>想去九寨沟玩，整理旅游攻略。</p>
<a id="more"></a>
<h2 id="自助游"><a href="#自助游" class="headerlink" title="自助游"></a>自助游</h2><h3 id="行程安排"><a href="#行程安排" class="headerlink" title="行程安排"></a>行程安排</h3><center>详细计划</center>

<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/jiuzaigou.jpg" alt="行程安排"></p>
<p>第一天：选择成都东客运站或者茶店子客运站出发，也可以在去哪儿网购买车票，有不同的选择，大概8小时左右到达九寨沟县城，距离九寨沟风景区仍然有46公里左右。此时可以选择住在九寨沟县城，也可以选择坐车去九寨沟沟口（风景区），根据预定的酒店安排即可。</p>
<p>第二天：如果住在九寨沟沟口，直接步行到九寨沟风景区，检票进入，开始游玩即可。如果住在九寨沟县城，注意可以选择乘坐公交，出租，包车到九寨沟风景区。快则半小时，慢则1小时，贵则100，慢则10几块即可到达风景，开始游玩。</p>
<p>第三天：根据情况选择，如果想连续游玩两天，最好选择购买二联票，第二天半价（当前没看到二联票，不知是否因为疫情，官网关闭了二联票入口），选择二联票注意规划号景点以及计划。</p>
<p>第四天：选择从九寨沟返回成都，注意只有早上有车，需要提前购买好车票，暂时只看到去哪儿网可以购买车票。</p>
<p>如果选择游玩三天，门票+往返车票大概800，不包含食宿费。</p>
<p>如果在有二联票的情况下，选择游玩四天，门票+往返车票大概1000左右，不包含食宿费。</p>
<h3 id="酒店住宿攻略"><a href="#酒店住宿攻略" class="headerlink" title="酒店住宿攻略"></a>酒店住宿攻略</h3><p> 建议直接食宿在九寨沟口即可，沟口食宿很多，入住经济型花费200左右即可。一般酒店没有一次性洗漱用品，注意需要自己携带。马蜂窝酒店评价过于老旧，无参考价值，建议在去哪儿或者携程预定即可。</p>
<h3 id="车票预定"><a href="#车票预定" class="headerlink" title="车票预定"></a>车票预定</h3><p><a href="http://bus.qunar.com/route/route/list.html?fromStation=%E4%B9%9D%E5%AF%A8%E6%B2%9F&amp;toStation=%E6%88%90%E9%83%BD&amp;date=2022-10-28">去哪儿往返车票预定</a></p>
<p><a href="https://www.tz12306.com/ticket/search_510100_%E6%88%90%E9%83%BD_1_513225_%E4%B9%9D%E5%AF%A8%E6%B2%9F_1.html?drvTime=2022-10-22">四川汽车票务网</a></p>
<p><a href="https://c.abatour.com/booking/#/ticketBooking?iscenicid=4">九寨沟门票</a></p>
<h2 id="跟团游"><a href="#跟团游" class="headerlink" title="跟团游"></a>跟团游</h2><h2 id="跟团半自助游"><a href="#跟团半自助游" class="headerlink" title="跟团半自助游"></a>跟团半自助游</h2><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><blockquote>
<p><strong>九寨沟沟口</strong>：九寨沟口就是人们常说的沟口，就是九寨沟景区外面的一片地方，为游客提供住宿餐饮和休闲娱乐的地方，基本上到九寨沟玩的人会选择这里住宿吃饭购物。另外这里的地理名字叫做彭丰村，所以大家所提到的彭丰也就是景区外这一片俗称沟口的区域。还有一个叫漳扎镇的地方，当地人说镇上就是指这里了，这里位于彭丰的上游与彭丰相连，也是一个住宿餐饮集中的地方。但距离景区门口较彭丰较远了一点。</p>
<p><strong>九寨沟县城</strong>：九寨沟县是指九寨沟的县城，又叫南坪。离景区还有43公里，是当地人的居住地，没有景点和玩的地方，但旺季住宿紧张的时候那里的宾馆和小餐馆可以替景区分担一些压力。所以提醒坐长途客车来的朋友来九寨沟玩买票的时候千万注意，看准是九寨沟口还是九寨沟县，如果是买到九寨沟县的车票，下车后还要另外找车子走这几十公里的路才可以到大九寨沟景区。</p>
</blockquote>
<h2 id="景区游玩攻略"><a href="#景区游玩攻略" class="headerlink" title="景区游玩攻略"></a>景区游玩攻略</h2><h3 id="九寨沟简介"><a href="#九寨沟简介" class="headerlink" title="九寨沟简介"></a>九寨沟简介</h3><p><strong>布局很简单，呈现的是近似“Y”字型。</strong>如果是我们从地图上按照“上北，下南，左西，右东”去看的话，这个Y型是倒立过来的。不过景区的旅游布局地图都画成正立的Y，因为景区的入口是在Y型底部，这样绘制会比较容易识别。“Y”的三划正好是风景区里的三条“沟沟”，这里我称它们为下沟，左沟，右沟。</p>
<p>根据图上所示，</p>
<blockquote>
<p>下沟是树正沟，<br>左沟是则查洼沟（“查”读“渣，终点的景点是“长海”），<br>右沟是日则沟（终点的景点是“原始森林”）。</p>
</blockquote>
<p>从景色来看，我对它们的惊艳程度排序为右沟 &gt;下沟 &gt;左沟。</p>
<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/jiuzhaigou_fengjingqu.jpeg" alt="九寨沟风景区"></p>
<h3 id="景区道路"><a href="#景区道路" class="headerlink" title="景区道路"></a>景区道路</h3><p>景区内有一般有三种路：</p>
<blockquote>
<p>公路<br>公路栈道（公路紧挨着的栈道）<br>林间栈道（远离公路的栈道）</p>
</blockquote>
<p>公路上会行驶观光车。</p>
<h3 id="游玩原则"><a href="#游玩原则" class="headerlink" title="游玩原则"></a>游玩原则</h3><p>从游玩的原则来看，一般归纳为三句话：</p>
<blockquote>
<p><strong>(1)”下沟”尽量走公路栈道</strong></p>
</blockquote>
<p>不过从景区门刚走进去的那一段路，你会发现只有林间栈道和公路，如果时间充足，可以沿着林间栈道走，到了某个景点看到有一座木道桥通往右方的公路，就迅速从那里走过，到达公路栈道，继续沿着公路栈道走就行。另外，如果从“诺日朗瀑布”下行至“犀牛海”（4千米），尽量不要徒步。</p>
<blockquote>
<p><strong>(2)”左沟”尽量在公路上坐车</strong></p>
</blockquote>
<p>坐车到顶端的景点“长海”，可以向下步行到“<a href="https://www.zhihu.com/search?q=五彩池&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A74461574}">五彩池</a>”，然后就坐车回到诺日朗瀑布。</p>
<blockquote>
<p><strong>(3)”右沟”尽量走林间栈道。</strong></p>
</blockquote>
<p>以下不要徒步：</p>
<p>“箭竹海”下行至“原始森林”（10千米），如果想看这两点景点中间的“天鹅海”，就从原始森林往下走到天鹅海，不过也有3千米。</p>
<p>“镜海”下行至“诺日朗瀑布”</p>
<h3 id="游玩时间"><a href="#游玩时间" class="headerlink" title="游玩时间"></a>游玩时间</h3><p>玩1天的话，尽量坐观光车，到了景点就下来看看，拍拍照，如此而已。<br>尽量把时间留给右沟“<a href="https://www.zhihu.com/search?q=五花海&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A74461574}">五花海</a>（最美的景点）”、“熊猫海（水中有无鳞冷水鱼）”等经典景色。</p>
<p>玩2天的话，就可以悠闲点，这样的旅游团非常少，所以要玩2天一般需要你自助游。<br>这种情况下，第1天，你可以在7点左右就进入景区，趁着旅游团第一波人进来之前，先从下沟走上去，那一段景色还不错（约8千米），到了<a href="https://www.zhihu.com/search?q=树正寨&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A74461574}">树正寨</a>或犀牛海上车点（由下往上开的车，有的会在树正寨这里上客，有的不停，走到犀牛海上车点就肯定有得上车），坐车到诺日朗瀑布换乘去左沟的车（终点为“长海”），然后一路玩下来。第2天，重点玩右边的那条沟，坐车到诺日朗瀑布，换乘去右沟的车（终点为“原始森林”）。</p>
<h2 id="景区吃喝"><a href="#景区吃喝" class="headerlink" title="景区吃喝"></a>景区吃喝</h2><p>景区的开水一般只有“诺日朗中心”那里有，景区内的餐厅也是在“诺日朗中心”那里。</p>
<h2 id="网站导航"><a href="#网站导航" class="headerlink" title="网站导航"></a>网站导航</h2><p><a href="https://www.abatour.com/">阿坝旅游</a></p>
<p><a href="https://www.jiuzhai.com/">九寨沟</a></p>
<p>去哪儿/携程等</p>
<p>九寨沟（微信公众号）</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>九寨沟属于高海拔景区，为了防止发生高反，要多吃蔬菜水果，避免剧烈的运动。</li>
<li>秋季前来昼夜温差大，要带够充足的衣物，白天可以清凉一点，晚上就要穿薄毛衣了。</li>
<li>九寨沟是藏区，藏族人民不吃驴肉、马肉、狗肉、有的地方还不吃鱼肉，去了之后要尊重当地的风情民俗。</li>
<li>沟内是严禁投食喂鱼的，欣赏美景的同时也要注意环保意识。</li>
<li>旅行是一件痛并快乐着的事情，需要长时间的坐车，备好晕车药品、感冒药品、抗高原反应药品。</li>
<li>九寨沟居民平时以藏语为主，但随着旅游业的不断发展，中青年能够用汉语和英语进行交流。不过若是能够学会几句藏语，它可能给你的旅途带来意想不到的乐趣。</li>
<li>九寨沟是高原气候，早晚温差极大，有时下雨，请勿穿皮鞋、高跟鞋，可带雨具。夏季去除了短袖之外还要备一件长袖或外套，秋季穿个抓绒加一件防风的外套就足够了。冬季则需要穿比较厚实的棉袄了。</li>
</ol>
]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>九寨沟</tag>
        <tag>旅游</tag>
        <tag>10月秋季</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2022/05/04/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>所谓的代理者是指一个类别可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、存储器中的大对象、文件或其它昂贵或无法复制的资源。著名的代理模式例子为引用计数（英语：reference counting）指针对象。</p>
<a id="more"></a>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/proxy_uml.png" alt="proxy_uml"></p>
<h2 id="为别人做嫁衣"><a href="#为别人做嫁衣" class="headerlink" title="为别人做嫁衣"></a>为别人做嫁衣</h2><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/proxy_example_uml.png" alt="proxy_example_uml"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="GiveGift"><a href="#GiveGift" class="headerlink" title="GiveGift"></a>GiveGift</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GiveGift</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveDollar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveFlowers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveChocolate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SchoolGirl"><a href="#SchoolGirl" class="headerlink" title="SchoolGirl"></a>SchoolGirl</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchoolGirl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SchoolGirl</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Pursuit"><a href="#Pursuit" class="headerlink" title="Pursuit"></a>Pursuit</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pursuit</span> <span class="keyword">implements</span> <span class="title">GiveGift</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SchoolGirl mm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pursuit</span><span class="params">(SchoolGirl mm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mm = mm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveDollar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Give dollar.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveFlowers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Give flowers.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveChocolate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Give chocolate.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">GiveGift</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pursuit gg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(SchoolGirl mm)</span></span>&#123;</span><br><span class="line">        gg = <span class="keyword">new</span> Pursuit(mm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveDollar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gg.giveDollar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveFlowers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gg.giveFlowers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveChocolate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gg.giveChocolate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2022/05/04/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要直到任何创建的细节。</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>四川省省属事业单位公开招聘工作人员《综合知识》笔试复习大纲</title>
    <url>/2022/02/13/%E5%9B%9B%E5%B7%9D%E7%9C%81%E7%9C%81%E5%B1%9E%E4%BA%8B%E4%B8%9A%E5%8D%95%E4%BD%8D%E5%85%AC%E5%BC%80%E6%8B%9B%E8%81%98%E5%B7%A5%E4%BD%9C%E4%BA%BA%E5%91%98%E3%80%8A%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E3%80%8B%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<p>四川省省属事业单位公开招聘工作人员《综合知识》笔试复习大纲</p>
<a id="more"></a>
<h2 id="大纲内容"><a href="#大纲内容" class="headerlink" title="大纲内容"></a>大纲内容</h2><p>​                                                                    <strong>关于修订发布省属事业单位公共科目考试大纲的公告</strong></p>
<p>​        为适应新形势新情况，我厅对现行省政府序列事业单位公开招聘工作人员公共科目考试大纲进行了修订。现将修订后的公共科目考试大纲——<strong>《四川省省属事业单位公开招聘工作人员〈综合知识〉笔试复习大纲》</strong>予以公告。请报考省政府序列事业单位的<strong>非中小学教师岗位</strong>、<strong>非卫生事业单位卫生专业技术人员岗位</strong>考生按此大纲准备《综合知识》笔试。</p>
<p>​        原四川省人事厅2009年11月12日发布的《四川省省属事业单位公开招聘工作人员〈综合知识〉考试复习大纲》自本公告发布之日起废止。</p>
<p>​        <strong>特别提示：我厅不举办也不委托任何机构举办事业单位公招考试辅导培训班。目前社会上以各种名义举办的辅导(培训)班、辅导(培训)网站均与本厅无关。敬请广大报考者警惕，切勿上当受骗。</strong></p>
<p>​                                                                                                                                                                                    四川省人力资源和社会保障厅</p>
<p>​                                                                                                                                                                                                            2014年9月28日</p>
<p>​                                                                                    <strong>四川省省属事业单位公开招聘工作人员</strong></p>
<p>​                                                                                            <strong>《综合知识》笔试复习大纲</strong></p>
<p>​        本大纲供参加四川省省属事业单位公开招聘非中小学教师岗位、非卫生事业单位卫生专业技术岗位工作人员公共科目考试——《综合知识》笔试的考生复习参考。请考生重点掌握以下知识内容。</p>
<p>​        《综合知识》笔试的题型包括判断题、单项选择题、多项选择题、判断简析题和案例分析(含阅读分析)题五类。</p>
<p>​        <strong>第一部分法律</strong></p>
<p>​        <strong>一、宪法</strong></p>
<p>​        (一)宪法的概念、特征、本质、作用和宪法监督</p>
<p>​        (二)我国的国体和政体，我国的统一战线和政治协商制度(会议)，国家的标志和国家的结构形式，我国的人民代表大会制度及民族区域自治制度和特别行政区制度</p>
<p>​        (三)我国的基本经济制度</p>
<p>​        (四)公民的基本权利与义务基本概念，我国公民的基本权利和自由，我国公民的基本义务，我国公民行使权利的基本原则等</p>
<p>​        (五)我国的国家机关性质、地位、产生、任期、职权等</p>
<p>​        <strong>二、民法</strong></p>
<p>​        (一)民法的概念、基本原则和调整范围</p>
<p>​        (二)民事法律关系的主体</p>
<p>​        (三)民事法律行为的概念、特征、分类、有效要件，无效的民事行为，可变更、可撤销的民事行为和效力未定的民事行为，代理的概念、特征、种类及代理权的行使，无权代理，表见代理</p>
<p>​        (四)物权与所有权的概念、特征和分类，所有权的内容，共有，建筑物区分所有权，善意取得，用益物权和担保物权</p>
<p>​        (五)债的概念、特征及分类，债发生的原因，债的履行和终止，合同的概念、特征，合同的订立，格式合同，合同的效力，违约责任，缔约过失责任以及合同的担保</p>
<p>​        (六)知识产权的概念、内容和特征，著作权的概念、内容及保护，专利权的概念、客体、内容，专利申请原则及期限，商标权的概念、特征、取得、期限和保护</p>
<p>​        (七)人身权的概念、分类和保护方法</p>
<p>​        (八)财产继承权的概念与特征，我国继承制度的基本原则，继承权的取得、丧失和保护，法定继承与遗嘱继承，遗产的处理</p>
<p>​        (九)民事责任的概念、特征，一般侵权责任的构成要件，民事责任的归责原则和民事责任方式，不承担民事责任和减轻责任的情形(不可抗力、正当防卫、紧急避险)，关于责任主体的特殊规定，特殊侵权责任</p>
<p>​        (十)诉讼时效的概念、种类、中止与中断</p>
<p>​        (十一)民事诉讼法的基本概念，民事审判的基本制度，民事案件的管辖，诉讼参加人，民事诉讼证据，法院调解，第一审普通程序相关规定，第二审程序相关规定，审判监督程序</p>
<p>​        <strong>三、刑法</strong></p>
<p>​        (一)犯罪的概念、特征和犯罪构成</p>
<p>​        (二)正当防卫和紧急避险</p>
<p>​        (三)单位犯罪的概念和刑罚</p>
<p>​        (四)刑罚的种类</p>
<p>​        (五)犯罪的种类及贪污罪、挪用公款罪、受贿罪、行贿罪、职务侵占罪、敲诈勒索罪、交通肇事罪、危害公共安全罪</p>
<p>​        <strong>四、劳动法</strong></p>
<p>​        (一)劳动法的概念、调整对象、基本原则、适用范围及劳动者的权利和义务</p>
<p>​        (二)国家和地方各级人民政府促进就业的职责，平等的就业权利和就业的特别规定</p>
<p>​        (三)劳动者的工作时间、休息休假、工资，劳动安全卫生，女职工和未成年工劳动保护，职业培训，社会保险和福利等法定劳动管理保护制度</p>
<p>​        (四)劳动争议的范围、处理原则和方式</p>
<p>​        <strong>五、劳动合同法</strong></p>
<p>​        (一)劳动合同的概念、特征，劳动合同法概述</p>
<p>​        (二)劳动合同的订立原则，订立劳动合同的基本规定，劳动合同的种类、试用期和条款 </p>
<p>​        (三)劳动合同的无效 </p>
<p>​        (四)劳动合同的履行、变更、解除和终止 </p>
<p>​        (五)集体合同、竞业限制、劳务派遣等特别规定</p>
<p>​         (六)事业单位的聘用合同与劳动合同的关系</p>
<p>​        <strong>六、道路交通安全法</strong></p>
<p>​        (一)道交法的立法目的和适用对象</p>
<p>​        (二)车辆和驾驶人(机动车登记制度、机动车安全技术检验、特殊机动车的管理、禁止性行为、非机动车的管理，机动车驾驶人的驾驶证管理、驾驶要求)</p>
<p>​        (三)道路通行条件</p>
<p>​        (四)道路通行规定，机动车、非机动车通行规定，行人和乘车人通行规定，高速公路的特别规定</p>
<p>​        (五)交通事故处理方法，交通事故认定书，交通事故争议的解决，交通事故损害赔付</p>
<p>​        <strong>七、治安管理处罚法</strong></p>
<p>​        (一)治安管理处罚法的概念、基本原则和调整范围</p>
<p>​        (二)治安管理处罚的种类和具体适用</p>
<p>​        (三)扰乱公共秩序、妨害公共安全、侵犯人身权利和财产权利、妨害社会管理等违反治安管理的行为和处罚</p>
<p>​        <strong>第二部分 公民道德建设</strong></p>
<p>​        <strong>一、公民道德建设概述</strong></p>
<p>​        (一)公民道德建设的重要性、紧迫性和长期性</p>
<p>​        (二)公民道德的指导思想和方针、原则</p>
<p>​        (三)公民道德建设的主要内容</p>
<p>​        <strong>二、社会主义公民道德建设规范</strong></p>
<p>​        (一)公民基本道德规范</p>
<p>​        (二)社会公德规范</p>
<p>​        (三)职业道德规范</p>
<p>​        (四)家庭美德规范</p>
<p>​        <strong>第三部分 国情省情</strong></p>
<p>​        <strong>一、国情知识</strong></p>
<p>​        (一)国土与资源概况</p>
<p>​        (二)人口与民族概况、主要民族政策和宗教信仰政策</p>
<p>​        (三)综合国力 经济实力、科技实力、军事实力、软实力</p>
<p>​        (四)阶段特征 社会主义初级阶段的科学含义、我国社会主义初级阶段理论基本内容、建设有中国特色社会主义</p>
<p>​        (五)外交政策</p>
<p>​        <strong>二、省情知识</strong></p>
<p>​        (一)四川社会历史简况 行政区划、人口与民族分布概况，悠久的历史与古蜀文明，主要历史文化与近代上的主要历史事件，科技教育优势与杰出人才</p>
<p>​        (二)四川自然地理概况 地理位置，地形地貌与气候，土地、植物、动物、水利与矿产资源，“天府之国”与长江上游生态屏障，大熊猫故乡，四川的世界自然文化遗产和国家重点风景名胜区，四川战胜了两次特大地震灾害</p>
<p>​        (三)经济发展和人民生活 综合实力、区域经济、民营经济和人民生活概况</p>
<p>​        <strong>第四部分公文写作</strong></p>
<p>​        <strong>一、公文的含义、种类和作用</strong></p>
<p>​        (一)公文的主要分类方法及分类</p>
<p>​        (二)通用公文的类型、用途及特点</p>
<p>​        (三)公文文种的涵义、作用、文种选择的依据，正确区分、选择和使用文种</p>
<p>​        (四)公文的主要作用</p>
<p>​        <strong>二、公文的格式规范</strong></p>
<p>​        (一)公文文面格式的类型，特点和作用</p>
<p>​        (二)公文的组成部分(要素)、排列顺序、标识规则与特定格式</p>
<p>​        <strong>三、公文的撰写</strong></p>
<p>​        (一)公文撰写的基本要求与撰写一篇公文的具体要求</p>
<p>​        (二)通告、通知、通报、报告、请示、批复、函、会议纪要等常用公文的特点、用途、分类以及结构、写作技巧等知识</p>
<p>​        (三)调查报告、简报、公务信息、总结等信息反馈文书的特点、作用、分类、基本结构和写作方法、撰写要求</p>
<p>​        (三)慰问信、表扬信、感谢信、祝贺信、邀请信(请柬)、聘请书、倡议书等日常事务文书的基本结构及写法</p>
<p>​        (四)启事、声明、海报、公示等告启文书的用途、基本结构及写法</p>
<p>​        <strong>第五部分 事业单位基本常识</strong></p>
<p>​        <strong>一、事业单位概述</strong></p>
<p>​        事业单位的概念、内涵、作用</p>
<p>​        <strong>二、事业单位分类改革</strong></p>
<p>​        事业单位分类改革的意义、指导思想、基本原则、总体目标和事业单位类别划分</p>
<p>​        <strong>三、事业单位人事制度改革</strong></p>
<p>​        (一)《事业单位人事管理条例》的内容及基本规定</p>
<p>​        (二)事业单位人事制度改革的指导思想、基本原则、目标任务和主要内容</p>
<p>​        (三)事业单位聘用制度、岗位管理制度、公开招聘制度、竞聘上岗制度、考核奖惩制度</p>
<p>​        <strong>四、事业单位公开招聘制度</strong></p>
<p>​        (一)公开招聘的范围、基本原则、主要方式、基本程序</p>
<p>​        (二)应聘人员应具备的基本条件</p>
<p>​        (三)回避制度和违纪处理</p>
<p>​        <strong>五、事业单位聘用制度</strong></p>
<p>​        (一)聘用制度的基本原则和实施范围</p>
<p>​        (二)聘用合同的主要内容、类型和期限</p>
<p>​        (三)聘用合同的订立、变更、终止、解除和争议处理</p>
<p>​        (四)违反和终止、解除聘用合同的责任</p>
<p>​        <strong>六、事业单位岗位管理制度</strong></p>
<p>​        (一)岗位的概念、特点、类别和设置原则</p>
<p>​        (二)岗位设置管理的单位范围和人员范围</p>
<p>​        (三)可以申请设置特设岗位的情形</p>
<p>​        (四)管理岗位、专业技术岗位和工勤技能岗位的等级及内部结构比例</p>
<p>​        (五)管理岗位、专业技术岗位和工勤技能岗位的基本聘用条件</p>
<p>​        (六)聘用管理岗位的学历条件和年限规定?</p>
<p>​        (七)聘用专业技术岗位的基本条件</p>
<p>​        (八)聘用工勤技能岗位的基本条件</p>
<p>​        (九)岗位设置的基本程序和作用</p>
<p>​        (十)事业单位岗位设置方案变更</p>
<p>​        (十一)岗位聘用的基本要求和规定</p>
<p>​        <strong>七、事业单位人员考核制度</strong></p>
<p>​        (一)考核的原则、对象、种类、档次</p>
<p>​        (二)考核结果的使用</p>
<p>​        <strong>八、事业单位的奖励</strong></p>
<p>​        (一)奖励的原则、情形</p>
<p>​        (二)种类和对象范围</p>
<p>​        <strong>九、事业单位工作人员处分</strong></p>
<p>​        (一)给予处分的行为</p>
<p>​        (二)处分的原则、种类、权限、程序、期限和适用</p>
<p>​        (三)处分的解除及程序</p>
<p>​        <strong>十、人事争议处理</strong></p>
<p>​        (一)人事争议的概念和分类</p>
<p>​        (二)人事争议处理的渠道和基本原则</p>
<p>​        (三)人事争议协商、人事争议调解的概念及特点</p>
<p>​        (四)人事争议仲裁的特点、原则、依据、受案范围、申请条件和时效</p>
<p>​        (五)人事争议诉讼的概念、特点和依据</p>
<p>​        <strong>第六部分 经济、科技、文化常识</strong></p>
<p>​        <strong>一、经济常识</strong></p>
<p>​        (一)社会主义市场经济体制 经济体制与市场经济，社会主义市场经济</p>
<p>​        (二)微观经济常识 经济学的基础知识，市场机制与竞争，收入分配</p>
<p>​        (三)宏观经济常识 宏观经济学概述，宏观调控的目标和内容，宏观经济主要指标，宏观经济政策，扩大内需</p>
<p>​        <strong>二、科学技术及环保常识</strong></p>
<p>​        (一)科技概论 科学与技术，历史上的科学革命，历史上的技术革命，现代科技发展的趋势</p>
<p>​        (二)科学前沿 物质的构成，宇宙的起源，地球的起源，生命的起源，人类的起源， 人的智能，人工智能</p>
<p>​        (三)高新技术 计算机与通信技术，生物技术，能源技术，新材料技术，空间技术， 激光技术，海洋开发技术，水资源利用技术</p>
<p>​        (四)农业农村和农业科技 农业基础知识，社会主义新农村建设，现代农业发展趋势，现代农业技术革命，可持续农业，有机农业，生态农业，精细农业</p>
<p>​        (五)环境保护 生态系统与生态平衡 可持续发展(清洁生产、低碳经济、循环经济)，环境保护与人体健康，大气污染及其防治，水污染及其防治，土壤污染及其防治，物理性污染及其防治，固体废弃物及其处理</p>
<p>​        <strong>三、文化常识</strong></p>
<p>​        (一)社会主义文化建设 文化与文化建设，文化软实力与综合国力，和谐文化，文化体制改革，文化开放与文化安全，非物质文化遗产，社会主义道德建设，“二为”方向和“双百”方针，继承和弘扬中华优秀传统文化，国学经典“经史子集”。</p>
<p>​        (二)社会主义核心价值观和社会主义核心价值体系 社会主义核心价值体系和社会主义核心价值观提出的背景，社会主义核心价值体系的基本内容及其重要意义，社会主义核心价值观的基本内容，社会主义核心价值观与社会主义核心价值体系的关系，培育和践行社会主义核心价值观的重要意义，培育和践行社会主义核心价值观的指导思想和基本原则，如何培育和践行社会主义核心价值观</p>
<p>​        (三)文化事业与文化产业 公共文化服务体系，现代文化市场体系，现代传播体系，优秀传统文化传承体系，文化科技创新，文化产品与文化消费，城市文化，城乡文化一体化</p>
<p>​        <strong>第七部分 职业能力测试部分</strong></p>
<p>​        通过对应考者的常识与基本技能、言语理解与表达、判断推理、数量关系与资料分析的测试，考察应考者的应知应会能力、逻辑推理判断能力、语言理解与表达能力、数据判断与分析能力。</p>
<p>​        <strong>第八部分　时事知识部分</strong></p>
<p>​        通过对一年来国内国际时事知识及国策和四川省策的测试，了解应考者获取新知识与信息的能力。</p>
]]></content>
      <categories>
        <category>公务员</category>
      </categories>
      <tags>
        <tag>公务员</tag>
        <tag>事业单位</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2022/05/04/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p>
<a id="more"></a>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/factory_method_example_uml.png" alt="factory_method_example_uml"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="IFactory"><a href="#IFactory" class="headerlink" title="IFactory"></a>IFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.designpatterns.simplefactory.Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Operation <span class="title">createOperation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AddFactory"><a href="#AddFactory" class="headerlink" title="AddFactory"></a>AddFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.designpatterns.simplefactory.Operation;</span><br><span class="line"><span class="keyword">import</span> com.lei.designpatterns.simplefactory.OperationAdd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">createOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SubFactory"><a href="#SubFactory" class="headerlink" title="SubFactory"></a>SubFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.designpatterns.simplefactory.Operation;</span><br><span class="line"><span class="keyword">import</span> com.lei.designpatterns.simplefactory.OperationSub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">createOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MulFactory"><a href="#MulFactory" class="headerlink" title="MulFactory"></a>MulFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.designpatterns.simplefactory.Operation;</span><br><span class="line"><span class="keyword">import</span> com.lei.designpatterns.simplefactory.OperationMul;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">createOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationMul();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DivFactory"><a href="#DivFactory" class="headerlink" title="DivFactory"></a>DivFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.designpatterns.simplefactory.Operation;</span><br><span class="line"><span class="keyword">import</span> com.lei.designpatterns.simplefactory.OperationDiv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">createOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationDiv();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>依赖<a href="https://www.dleis.com/2022/05/03/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">简单工厂模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title>成都市属事业单位《公共基础知识》考试大纲</title>
    <url>/2022/02/13/%E6%88%90%E9%83%BD%E5%B8%82%E5%B1%9E%E4%BA%8B%E4%B8%9A%E5%8D%95%E4%BD%8D%E3%80%8A%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<p>《公共基础知识》总分100分，考试时间90分钟，全部为客观性试题。题型为单项选择题、多项选择题和是非判断题三种。考试内容主要包括：法律基础、中国特色社会主义理论、马克思主义哲学、应用文写作、经济与管理、公民道德建设、科技基础知识、四川省情、成都市情、时事政治等。</p>
<a id="more"></a>
<h2 id="大纲内容"><a href="#大纲内容" class="headerlink" title="大纲内容"></a>大纲内容</h2><p>​        <strong>第一部分：法律基础。</strong></p>
<p>　　一、法的一般原理、法的制定与实施。</p>
<p>　　二、宪法性法律、行政法、民法、刑法、社会法、经济法等的基本概念和基本原则。</p>
<p>　　三、宪法性法律、行政法、民法、刑法、社会法、经济法等的法律关系、法律行为和适用范围等。</p>
<p>　　四、常见犯罪种类、特点与刑罚种类、裁量。</p>
<p>　　五、合同的订立、生效、履行、变更、终止和解除。</p>
<p>　　<strong>第二部分：中国特色社会主义理论。</strong></p>
<p>　　一、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的主要内容。</p>
<p>　　二、党的十八大以来我国面临的新形势新任务，以及党的建设和国家未来发展的一系列理论和实践。</p>
<p>　　<strong>第三部分：马克思主义哲学。</strong></p>
<p>　　马克思主义哲学的主要内容及基本观点。</p>
<p>　　<strong>第四部分：应用文写作。</strong></p>
<p>　　一、 应用文含义、特点、种类、作用、格式规范。</p>
<p>　　二、 法定公文的分类、构成要素、写作要求以及常用公文的撰写。</p>
<p>　　三、 公文处理的概念、基本任务、基本原则，收文、发文处理的程序和方法，办毕公文的处置。</p>
<p>　　<strong>第五部分：经济与管理。</strong></p>
<p>　　一、经济学的基本常识、基础理论及运用。</p>
<p>　　二、管理学的基本常识、基础理论及运用。</p>
<p>　　<strong>第六部分：公民道德建设。</strong></p>
<p>　　一、公民道德建设的指导思想、方针原则及主要内容。</p>
<p>　　二、社会主义核心价值观的概念、内涵及基本原则。</p>
<p>　　<strong>第七部分：科技基础知识。</strong></p>
<p>　　信息科学、生物技术、能源科学、空间技术、农业高科技等新技术的基本特点、作用及发展趋势。</p>
<p>　　<strong>第八部分：省情市情。</strong></p>
<p>　　四川省和成都市的历史文化、人口与民族、区域经济、地理位置、地形地貌、气候特点。</p>
<p>　　<strong>第九部分：时事政治。</strong></p>
<p>　　一、一年来国际、国内发生的重大事件。</p>
<p>　　二、国家、四川省、成都市近期出台的重大决策的主要内容。</p>
<p>　　<strong>《医学基础知识》</strong></p>
<p>　　《医学基础知识》总分100分，考试时间90分钟，全部为客观性试题，题型为单项选择题、多项选择题和是非判断题三种。考查内容主要包括生物学、人体解剖学、生理学、药理学、病理学和诊断学六个部分。</p>
<p>　　<strong>第一部分：生物学。</strong></p>
<p>　　细胞和生命的遗传、变异以及遗传病发病机理。</p>
<p>　　<strong>第二部分：人体解剖学。</strong></p>
<p>　　运动系统、内脏学总论、消化系统、呼吸系统、泌尿系统、生殖系统、脉管系统、感觉器、神经系统和内分泌系统。</p>
<p>　　<strong>第三部分：生理学。</strong></p>
<p>　　细胞的基本功能、血液、血液循环、呼吸、消化和吸收、能量代谢和体温、尿的生成和排出、感觉器官、神经系统的功能、内分泌及生殖。</p>
<p>　　<strong>第四部分：药理学。</strong></p>
<p>　　药物效应动力学、药物代谢动力学以及常用国家基本药物的药理作用、临床应用、不良反应和禁忌症。</p>
<p>　　<strong>第五部分：病理学。</strong></p>
<p>　　疾病概述、血液循环障碍、炎症、肿瘤、心血管系统疾病、呼吸系统疾病、消化系统疾病、泌尿系统疾病、女性生殖系统及乳腺疾病、传染病和寄生虫病等疾病的概念、病因、发病机制、特征、类型、病理变化。</p>
<p>　　<strong>第六部分：诊断学。</strong></p>
<p>　　发热、疼痛、水肿、呼吸困难等多种常见症状的发生机制、临床表现、体征和鉴别。</p>
<p>　　<strong>《教育公共基础》</strong></p>
<p>　　《教育公共基础》总分100分，考试时间90分钟，全部为客观性试题。题型为单项选择题、多项选择题和是非判断题三种。考试内容主要包括教育学基础、教育心理学、教育法学和教师职业道德四个部分。</p>
<p>　　<strong>第一部分：教育学基础。</strong></p>
<p>　　教育与教育学、教育的功能、教育的目的、教师与学生、课程、课堂教学、学校德育、班级管理与班主任工作的基本理论。</p>
<p>　　<strong>第二部分：教育心理学。</strong></p>
<p>　　心理发展与教育、学习与学习理论、学习的迁移、记忆和遗忘、学习策略与不同类型的学习、影响学习的心理因素、个别差异与教育以及学生心理健康教育。</p>
<p>　　<strong>第三部分：教育法学。</strong></p>
<p>　　法与教育法、教育法律关系、教育法律规范、教育法制过程、教育法律责任、学生的权利及其维护、教师的权利及其维护以及教育法律救济。</p>
<p>　　<strong>第四部分：教师职业道德。</strong></p>
<p>　　教师职业道德概述、教师的职业道德规范以及教师职业道德的养成。</p>
]]></content>
      <categories>
        <category>公务员</category>
      </categories>
      <tags>
        <tag>公务员</tag>
        <tag>事业单位</tag>
      </tags>
  </entry>
  <entry>
    <title>旅途的起点</title>
    <url>/2020/10/24/%E6%97%85%E9%80%94%E7%9A%84%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<p>今天刚把博客网站初步搭建好，从学生时代，到现在工作两年，一直以来都想好好写博客，写一些生活的感悟，以及技术上的文章。<br><a id="more"></a></p>
<h2 id="写博客背景"><a href="#写博客背景" class="headerlink" title="写博客背景"></a>写博客背景</h2><p>之前有在csdn上写博客的经历，但那是大学时候的事情了，后来也没有坚持下来。在快毕业的时候，同学买了一个博客视频，教你如何一步一步搭建自己的博客网站，那时候感觉搭建自己的网站挺新鲜的，然后尝试了之后，依然是半途而废。毕业之后，从事互联网工作，在国内某盛名996厂，不过有些名不符实，996没有，995到时不少。平时时间并不宽裕，因此也没有太多时间写博客。可能有人要问了，那为什么在工作两年之后，突然想到开始写博客了呢？原因之一是因为这一直以来是我自己非常想做的一件事情吧。事实证明，自己想了很久而没做的事情，即使过了很久，但是只要契机到了，你依然回去做。那么我这次开始写博客的契机又是什么呢？因为工作快二年半了，工作部门最近似乎也有些变动，有些不安吧。希望能在这大半年的时间里，好好整理一下所学习的知识，为可能的改变做准备吧。</p>
<h2 id="写博客的目的"><a href="#写博客的目的" class="headerlink" title="写博客的目的"></a>写博客的目的</h2><p>写博客主要为了记录生活的点滴，人生感悟以及作为一个技术宅的所学吧，算是对自己人生的一个整理吧。古有三十而立，想想我也是一个快而立之年的人了，总归要好好思考未来的人生道路该怎么走。平时工作忙的时候倒没觉得，但是一旦放假闲下来的时候，时常想一些奇奇怪怪的事情。人生想想还挺短暂的，也许未来还有四十年可活，也只有1万多天，如果每天能写一篇博客的话，余生还能写一万多篇博客。这未尝不是一件有趣的事情。人生嘛，说短不过几十载，说长嘛，还挺长的，总归要做一些有趣的事情，为单调重复的生活增添一些味道。博客能够帮助我们记录平凡的点滴，以及多彩的瞬间。此时正是英雄联盟S10之际，青春慢慢远去，我们的人生不能像英雄联盟一样可以随时重启，引用英雄联盟中的一句台词，我想对自己说，没有撤退可言。<br></p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2022/05/03/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>策略模式是指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。</p>
<a id="more"></a>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/strategy_uml.png" alt="strategy_uml"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="Strategy类"><a href="#Strategy类" class="headerlink" title="Strategy类"></a>Strategy类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算法方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StrategyA类"><a href="#StrategyA类" class="headerlink" title="StrategyA类"></a>StrategyA类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">extends</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Algorithm a.&quot;</span>)  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StrategyB类"><a href="#StrategyB类" class="headerlink" title="StrategyB类"></a>StrategyB类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">extends</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Algorithm b.&quot;</span>)  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StrategyC类"><a href="#StrategyC类" class="headerlink" title="StrategyC类"></a>StrategyC类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyC</span> <span class="keyword">extends</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Algorithm c.&quot;</span>)  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Context类"><a href="#Context类" class="headerlink" title="Context类"></a>Context类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算法策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy.algorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="商场促销"><a href="#商场促销" class="headerlink" title="商场促销"></a>商场促销</h2><p>营业员在收银台，需要根据所购买商品的单价与数量，向客户收费。并且需要考虑在不同的场景下，会有不同的打折情况，比如8折或者满减。</p>
<h2 id="简单工厂实现"><a href="#简单工厂实现" class="headerlink" title="简单工厂实现"></a>简单工厂实现</h2><h3 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/strategy_simple_factory_uml.png" alt="strategy_simple_factory_uml"></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="CashSuper类"><a href="#CashSuper类" class="headerlink" title="CashSuper类"></a>CashSuper类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回实收现金</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 原价</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CashNormal类"><a href="#CashNormal类" class="headerlink" title="CashNormal类"></a>CashNormal类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">package</span> com.lei.designpatterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashNormal</span> <span class="keyword">extends</span> <span class="title">CashSuper</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CashRebate类"><a href="#CashRebate类" class="headerlink" title="CashRebate类"></a>CashRebate类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashRebate</span> <span class="keyword">extends</span> <span class="title">CashSuper</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 折扣率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> cashRebate = <span class="number">1d</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashRebate</span><span class="params">(String moneyRebate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cashRebate = Double.parseDouble(moneyRebate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cashRebate * money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CashReturn类"><a href="#CashReturn类" class="headerlink" title="CashReturn类"></a>CashReturn类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashReturn</span> <span class="keyword">extends</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返现条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> moneyCondition = <span class="number">0.0d</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返现金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> moneyReturn = <span class="number">0.0d</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashReturn</span><span class="params">(String moneyCondition, String moneyReturn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.moneyCondition = Double.parseDouble(moneyCondition);</span><br><span class="line">        <span class="keyword">this</span>.moneyReturn = Double.parseDouble(moneyReturn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acceptCash</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = money;</span><br><span class="line">        <span class="keyword">if</span> (money &gt; <span class="keyword">this</span>.moneyCondition)&#123;</span><br><span class="line">            result = money - Math.floor(money / <span class="keyword">this</span>.moneyCondition) * <span class="keyword">this</span>.moneyReturn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CashFactory类"><a href="#CashFactory类" class="headerlink" title="CashFactory类"></a>CashFactory类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.strategy.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CashSuper <span class="title">createCashFactory</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        CashSuper cs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Normal&quot;</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> CashNormal();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Rebate&quot;</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> CashRebate(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Return&quot;</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> CashReturn(<span class="string">&quot;300&quot;</span>,<span class="string">&quot;100&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(<span class="string">&quot;Not support type.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="策略实现"><a href="#策略实现" class="headerlink" title="策略实现"></a>策略实现</h2><h3 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/strategy_example_uml.png" alt="strategy_example_uml"></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="CashContext类"><a href="#CashContext类" class="headerlink" title="CashContext类"></a>CashContext类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.strategy.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.designpatterns.strategy.CashSuper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CashSuper cs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashContext</span><span class="params">(CashSuper cs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cs = cs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cs.acceptCash(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="策略与工厂结合"><a href="#策略与工厂结合" class="headerlink" title="策略与工厂结合"></a>策略与工厂结合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CashSuper cs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashContext</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Normal&quot;</span>:</span><br><span class="line">                <span class="keyword">this</span>.cs = <span class="keyword">new</span> CashNormal();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Rebate&quot;</span>:</span><br><span class="line">                <span class="keyword">this</span>.cs = <span class="keyword">new</span> CashRebate(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Return&quot;</span>:</span><br><span class="line">                <span class="keyword">this</span>.cs = <span class="keyword">new</span> CashReturn(<span class="string">&quot;300&quot;</span>,<span class="string">&quot;100&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(<span class="string">&quot;Not support type.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cs.acceptCash(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>行为型模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2022/05/03/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>普通的工厂方法模式通常伴随着对象的具体类型与工厂具体类型的一一对应，客户端代码根据需要选择合适的具体类型工厂使用。然而，这种选择可能包含复杂的逻辑。这时，可以创建一个单一的工厂类，用以包含这种选择逻辑，根据参数的不同选择实现不同的具体对象。</p>
<a id="more"></a>
<h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>实现一个具有加、减、乘、除的计算器。</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/simple_factory_uml.png" alt="simple_factory_uml"></p>
<h2 id="代码样例"><a href="#代码样例" class="headerlink" title="代码样例"></a>代码样例</h2><h3 id="Operation类"><a href="#Operation类" class="headerlink" title="Operation类"></a>Operation类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> numA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> numB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getNumA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumA</span><span class="params">(<span class="keyword">double</span> numA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numA = numA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getNumB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumB</span><span class="params">(<span class="keyword">double</span> numB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numB = numB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OperationAdd类"><a href="#OperationAdd类" class="headerlink" title="OperationAdd类"></a>OperationAdd类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.numA + <span class="keyword">this</span>.numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OperationSub类"><a href="#OperationSub类" class="headerlink" title="OperationSub类"></a>OperationSub类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSub</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.numA - <span class="keyword">this</span>.numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OperationMul类"><a href="#OperationMul类" class="headerlink" title="OperationMul类"></a>OperationMul类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMul</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.numA * <span class="keyword">this</span>.numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OperationDiv类"><a href="#OperationDiv类" class="headerlink" title="OperationDiv类"></a>OperationDiv类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationDiv</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.numB &lt; <span class="number">0.000001</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">&quot;Divide by zero.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.numA / <span class="keyword">this</span>.numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OperationFactory类"><a href="#OperationFactory类" class="headerlink" title="OperationFactory类"></a>OperationFactory类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperation</span><span class="params">(String operate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (operate == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Operate is empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (operate)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OperationMul();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OperationDiv();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(<span class="string">&quot;Not support operate.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>算法序言</title>
    <url>/2021/03/21/%E7%AE%97%E6%B3%95%E5%BA%8F%E8%A8%80/</url>
    <content><![CDATA[<p>有一种观点认为，程序等于数据结构加算法，但是懂得了数据结构与算法并不一定能写出好的程序。本文主要介绍后面文章会用到的一些基本数据结构。</p>
<a id="more"></a>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>后面统一使用如下异常类，处理抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgorithmException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlgorithmException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlgorithmException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误码定义类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorCode4Algorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ErrorCode4Algorithm</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 越界异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INDEX_OUT_OF_RANGE = <span class="string">&quot;INDEX_OUT_OF_RANGE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未重写异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NOT_IMPLEMENT_EXCEPTION = <span class="string">&quot;NOT_IMPLEMENT_EXCEPTION&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一维节点定义"><a href="#一维节点定义" class="headerlink" title="一维节点定义"></a>一维节点定义</h2><p>所有一维单链表统一如下节点进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.SuperBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向下一个节点的指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>序言</tag>
      </tags>
  </entry>
  <entry>
    <title>考公指南</title>
    <url>/2022/02/13/%E8%80%83%E5%85%AC%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>记录考公学习过程。</p>
<a id="more"></a>
<h2 id="公务员与事业单位"><a href="#公务员与事业单位" class="headerlink" title="公务员与事业单位"></a>公务员与事业单位</h2><p><strong>公务员</strong>是指依法履行公职、纳入国家行政编制、由国家财政负担工资福利的工作人员，包括法官，检察官，政协工作人员等非国家行政机关的公职人员。</p>
<p><strong>事业单位</strong>是指国家为了社会公益目的，由国家机关举办或者其他组织利用国有资产举办的，从事教育、科研、文化、卫生、体育、新闻出版、广播电视、社会福利、救助减灾、统计调查、技术推广与实验、公用设施管理、物资仓储、监测、勘探与勘察、测绘、检验检测与鉴定、法律服务、资源管理事务、质量技术监督事务、经济监督事务、知识产权事务、公证与认证、信息与咨询、人才交流、就业服务、机关后勤服务等活动的社会服务组织。</p>
<h3 id="编制差别"><a href="#编制差别" class="headerlink" title="编制差别"></a>编制差别</h3><p><strong>公务员编制属于行政编</strong>，工资全部是财政全额拨款。多为一些各级地方人民政府，以及国务院各职能部门、地方人民政府各职能管理机构等等。</p>
<p><strong>事业单位编制大多是服务性质的单位</strong>，一般分为三种：全额事业编制、差额事业编制和自筹自支事业编制三种。</p>
<blockquote>
<p><strong>全额编制又叫全额财政拨款事业编制</strong>，完全靠财政拨款的单位，多指一些公益性事业单位和部分具有行政执法职能的事业单位，如：公办义务教育学校、交通局下属交通稽查队等等;<br><strong>差额事业编制</strong>，由财政进行差额拨款，如：公立医院、公立大学等等;</p>
<p><strong>自筹自支事业编制</strong>，多为一些服务型事业单位，如政府招待所、从事应用性研究和开发的科研单位等等。</p>
</blockquote>
<p>另外介于公务员和事业单位之间的有一个参公单位，平时在报考公务员的时候，也会看到参公的岗位，虽然不属于行政编制，但是与公务员是同岗同酬的。</p>
<h3 id="晋升空间"><a href="#晋升空间" class="headerlink" title="晋升空间"></a>晋升空间</h3><p><strong>公务员走的是职务与职级并行路线的</strong>，也就是说即使当不了领导，也能根据工作年限、资历等，享受到相关的待遇。而且领导职位一旦空出，就会有人员补充，也有一定的晋升机会。</p>
<p><strong>事业单位人员晋升基本走的是职称</strong>。事业单位分为管理岗和技术岗，晋升途径一般是分以下情况：专技岗位分为1到13级，通过职称评聘来增加工资;工勤岗位分为1到5级，通过鉴定职业资格水平来增加工资。管理岗最低为十级，专业技术岗最低为十三级，虽然专技岗说的是走职称，但是想评上中级职称还是挺难的，事业单位管理岗更不用说了，因为事业单位基本都是行政机关下面的二级单位，晋升机会非常有限。县级单位基本上管理八级就是天花板了，专技岗的小伙伴能评上中级职称基本上就是天花板了。</p>
<h3 id="福利待遇"><a href="#福利待遇" class="headerlink" title="福利待遇"></a>福利待遇</h3><p>公务员比事业单位多一个车补。一般来说，公务员享受的福利待遇比事业单位的人员要好一些。不过现在事业单位人员的工资也在不断的提升。公务员享受的保险福利是按照《国家公务员管理条例》的规定执行;事业单位人员享受的保险福利是按照国家有关的社会保障规定执行，一般要逐步实行社会化。不过事业单位和公务员岗还是要看具体的环境和岗位，一些发达地区的事业单位并不比三四线小城的公务员差。就同一地区而言，能考公务员呢，还是努力的考公务员，不管是福利待遇还是未来的发展空间，都比事业单位要大一些。</p>
<h3 id="考试差别"><a href="#考试差别" class="headerlink" title="考试差别"></a>考试差别</h3><p><strong>公务员考试</strong>一般是指国家公务员考试和地方公务员考试。国考一般是在每年的下半年举行的，一年只有一次。地方性公务员考试一般就是指省考了。</p>
<p><strong>事业单位</strong>一般是指各事业单位招聘工作人员的考试。一般是各级各单位自行组织。有国家各部委各单位的事业单位，有地方各级的事业单位。</p>
<p>考试时间也不统一，主要是集中在每年的上半年。事业单位考试的考试科目各地不同，以《公共基础知识》为主，有特殊要求的会附加各个专业的专业测试或者写作。</p>
<p>在考试内容上，公务员分别考察两个板块——<strong>行测和申论</strong>。国考的<strong>《行测》</strong>通常是130-135道题，满分是100分、<strong>《申论》</strong>通常是4-5道大题，满分100分；省考的<strong>《行测》</strong>则是120道题，满分150分、<strong>《申论》</strong>通常是4-5道大题，满分150分；而事业单位考察的是<strong>《职业能力倾向测验》</strong>和<strong>《综合应用能力》</strong>满分都是150分；</p>
<p><strong>公务员考试的题型广，题目难度更深，题量更大</strong>，与事业单位考试相比公务员考试更难一点。而且考试的机会有的时候一年只有一两次，竞争力也是非常大的。而事业单位考察的综合性的知识比较多，考试的机会相对比较多，上岸机会也更大一些。</p>
<h3 id="招录差别"><a href="#招录差别" class="headerlink" title="招录差别"></a>招录差别</h3><p><strong>国考主要招录单位</strong>是税务系统、消防系统、海关、铁路公安、海事局、银保监会、入境边防检查总站、统计局、气象局、水利工程、外交部、证监会等。</p>
<p><strong>各省省考及市考</strong>主要招录单位为公安、税务、统计、法院、检察院等系统以及市级、县级、镇级各局单位。公务员岗位大多数为社会人文科学类专业可报，基层岗位居多。</p>
<p><strong>事业单位</strong>一般是指各事业单位招聘工作人员的考试。一般是各级各单位自行组织。有国家各部委各单位的事业单位，有地方各级的事业单位。考试时间也不统一，主要是集中在每年的上半年。事业单位考试的考试科目各地不同，以《公共基础知识》为主，有特殊要求的会附加各个专业的专业测试或者写作。</p>
<h2 id="四川事业单位"><a href="#四川事业单位" class="headerlink" title="四川事业单位"></a>四川事业单位</h2><h3 id="考试时间"><a href="#考试时间" class="headerlink" title="考试时间"></a>考试时间</h3><p>四川省事业单位招聘考试每年两次，分别为上半年4月和下半年10-12月左右。2020余2021年由于疫情原因，上半年考试时间略有延迟，2022年若无疫情意外预计考试时间会在4月份。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>年份</th>
<th>公告时间一</th>
<th>考试时间一</th>
<th>公告时间二</th>
<th>考试时间二</th>
</tr>
</thead>
<tbody>
<tr>
<td>2018</td>
<td>2018.03.09</td>
<td>2018.04.15</td>
<td>2018.10.16</td>
<td>2018.12.09</td>
</tr>
<tr>
<td>2019</td>
<td>2019.03.12</td>
<td>2019.04.27</td>
<td>2019.10.16</td>
<td>2019.12.07</td>
</tr>
<tr>
<td>2020</td>
<td>2020.05.07</td>
<td>2020.07.18</td>
<td>2020.10.23</td>
<td>2020.12.05</td>
</tr>
<tr>
<td>2021</td>
<td>2021.03.31</td>
<td>2021.05.15</td>
<td>2021.10.25</td>
<td>2021.12.04</td>
</tr>
<tr>
<td>2022</td>
<td>预计三月份</td>
<td>预计四月份</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="考试内容"><a href="#考试内容" class="headerlink" title="考试内容"></a>考试内容</h3><div class="table-container">
<table>
<thead>
<tr>
<th><span style="white-space:nowrap;">考试内容</span></th>
<th>综合知识</th>
<th>公共基础知识</th>
</tr>
</thead>
<tbody>
<tr>
<td>考试大纲</td>
<td><strong><a href="https://www.dleis.com/2022/02/13/%E5%9B%9B%E5%B7%9D%E7%9C%81%E7%9C%81%E5%B1%9E%E4%BA%8B%E4%B8%9A%E5%8D%95%E4%BD%8D%E5%85%AC%E5%BC%80%E6%8B%9B%E8%81%98%E5%B7%A5%E4%BD%9C%E4%BA%BA%E5%91%98%E3%80%8A%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E3%80%8B%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/">四川省省属事业单位公开招聘工作人员《综合知识》笔试复习大纲</a></strong></td>
<td><strong><a href="https://www.dleis.com/2022/02/13/%E6%88%90%E9%83%BD%E5%B8%82%E5%B1%9E%E4%BA%8B%E4%B8%9A%E5%8D%95%E4%BD%8D%E3%80%8A%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%8B%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/">成都市属事业单位《公共基础知识》考试大纲</a></strong></td>
</tr>
<tr>
<td><span style="white-space:nowrap;">考试题型</span></td>
<td>有判断题、单项选择题、多项选择题、判断简析题和案例分析(含阅读分析)</td>
<td>题型为单项选择题、单向选择题、多向选择题和是非判断题</td>
</tr>
<tr>
<td><span style="white-space:nowrap;">考试内容</span></td>
<td>大概可分为法律和非法律两个部分法律部分主要有：宪法、民法、刑法、民事诉讼法、劳动法及劳动合同法、道路交通安全法、治安管理处罚法等。非法律部分部分有：公民道德建设、国情省情、公文写作、事业单位常识、经济科技文化常识、时事政治。</td>
<td>法律基础、中国特色社会主义理论、马克思主义哲学、应用文写作、经济与管理、公民道德建设、科技基础知识、四川省情、成都市情、时事政治等。</td>
</tr>
<tr>
<td><span style="white-space:nowrap;">考试时间</span></td>
<td>120分钟</td>
<td>90分钟</td>
</tr>
<tr>
<td>考试分数</td>
<td>100分</td>
<td>100分</td>
</tr>
<tr>
<td>考试题量</td>
<td>90-120</td>
<td>90-120</td>
</tr>
</tbody>
</table>
</div>
<h3 id="考试科目"><a href="#考试科目" class="headerlink" title="考试科目"></a>考试科目</h3><div class="table-container">
<table>
<thead>
<tr>
<th>考试项目</th>
<th>考试科目</th>
</tr>
</thead>
<tbody>
<tr>
<td>成都市属事业单位</td>
<td>《综合能力素质》+《职业能力倾向测验》</td>
</tr>
<tr>
<td>成都区县事业单位</td>
<td>《综合能力素质》+《职业能力倾向测验》</td>
</tr>
<tr>
<td>省直属事业单位</td>
<td>《综合知识》</td>
</tr>
</tbody>
</table>
</div>
<h3 id="考试网站"><a href="#考试网站" class="headerlink" title="考试网站"></a>考试网站</h3><p>发布招考公告：个地级市陆续发布招考公告，分别发布在个地级市人事考试网或人力资源和社会保障厅网站</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常用网站</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://cdpta.cdhrss.chengdu.gov.cn:8443/netpage/index.do">成都人事考试网</a></td>
<td>成都人事考试网</td>
</tr>
<tr>
<td><a href="http://cdhrss.chengdu.gov.cn/cdrsj/index.shtml">成都人力资源和社会保障局</a></td>
<td>成都人力资源和社会保障局</td>
</tr>
<tr>
<td><a href="http://www.chinagwy.org/html/gdzk/index.html">公考资讯网</a></td>
<td>公考资讯网</td>
</tr>
</tbody>
</table>
</div>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="综合知识"><a href="#综合知识" class="headerlink" title="综合知识"></a>综合知识</h3><p>​    </p>
]]></content>
      <categories>
        <category>公务员</category>
      </categories>
      <tags>
        <tag>公务员</tag>
        <tag>事业单位</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/2022/05/04/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>通过使用修饰模式，可以在运行时扩充一个类别的功能。原理是：增加一个修饰类包裹原来的类别，包裹的方式是在修饰类的构造函数中将原来的类以参数的形式传入。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类别中的方法。修饰类必须和原来的类别有相同的接口。</p>
<a id="more"></a>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/decorator_uml.png" alt="decorator_uml"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="Component类"><a href="#Component类" class="headerlink" title="Component类"></a>Component类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ConcreteComponent类"><a href="#ConcreteComponent类" class="headerlink" title="ConcreteComponent类"></a>ConcreteComponent类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Concrete component.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Decorator类"><a href="#Decorator类" class="headerlink" title="Decorator类"></a>Decorator类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComponent</span><span class="params">(Component component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.component != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.component.operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ConcreteDecoratorA类"><a href="#ConcreteDecoratorA类" class="headerlink" title="ConcreteDecoratorA类"></a>ConcreteDecoratorA类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String addedState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        <span class="keyword">this</span>.addedState = <span class="string">&quot;New state.&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;New Operation a.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ConcreteDecoratorB"><a href="#ConcreteDecoratorB" class="headerlink" title="ConcreteDecoratorB"></a>ConcreteDecoratorB</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedBehavior();</span><br><span class="line">        System.out.println(<span class="string">&quot;New Operation b.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addedBehavior</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰器样例"><a href="#装饰器样例" class="headerlink" title="装饰器样例"></a>装饰器样例</h2><h3 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/decorator_example_uml.png" alt="decorator_example_uml"></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="Person类"><a href="#Person类" class="headerlink" title="Person类"></a>Person类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Show.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Finery类"><a href="#Finery类" class="headerlink" title="Finery类"></a>Finery类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Finery</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Decorate</span><span class="params">(Person component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.component != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.component.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TShirts类"><a href="#TShirts类" class="headerlink" title="TShirts类"></a>TShirts类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TShirts</span> <span class="keyword">extends</span> <span class="title">Finery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;T shirts.&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BigTrouser类"><a href="#BigTrouser类" class="headerlink" title="BigTrouser类"></a>BigTrouser类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigTrouser</span> <span class="keyword">extends</span> <span class="title">Finery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Big trouser.&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BrokenSneaker类"><a href="#BrokenSneaker类" class="headerlink" title="BrokenSneaker类"></a>BrokenSneaker类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokenSneaker</span> <span class="keyword">extends</span> <span class="title">Finery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Broken sneaker.&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Suite类"><a href="#Suite类" class="headerlink" title="Suite类"></a>Suite类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Suite</span> <span class="keyword">extends</span> <span class="title">Finery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Suite.&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Tie类"><a href="#Tie类" class="headerlink" title="Tie类"></a>Tie类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tie</span> <span class="keyword">extends</span> <span class="title">Finery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tie.&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LeatherShoes类"><a href="#LeatherShoes类" class="headerlink" title="LeatherShoes类"></a>LeatherShoes类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.designpatterns.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeatherShoes</span> <span class="keyword">extends</span> <span class="title">Finery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Leather shoes.&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title>队列与栈一</title>
    <url>/2021/03/22/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E4%B8%80/</url>
    <content><![CDATA[<p>线性表是最基本的数据结构之一，其最终的物理结构不外乎两种，顺序表与链表。队列与栈都是线性表，只是其外在的逻辑表现形式不同而已。</p>
<a id="more"></a>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>顺序表是一种在物理上连续存储的结构，也即顺序表的元素在内存空间里是物理上连续的。</p>
<div><div class="graphviz">digraph array_list{

    bgcolor="#f7f7f7"

    subgraph cluster_array {


        node [shape=record, fontcolor=black,width=4.75, fixedsize=true];
        pointers[] [label="<p0> A+0 | <p1> A+1 | <p2> A+2 | <p3> A+3 | <p4> A+4 | <p5> A+5 | <p6> A+6 | <p7> A+7", color=blue];
        values [label="<v0> A[0] | <v1> A[1] | <v2> A[2] | <v3> A[3] | <v4> A[4] | <v5> A[5] | <v6> A[6] | <v7> A[7]", color=blue, fillcolor=lightblue, style=filled];
        indices [label="0 | 1 | 2 | 3| 4 | 5 | 6 | 7", color="#f7f7f7"];

        node [shape=plaintext, fontcolor="black",width=1 fontsize=18,fixedsize=true];
        "Pointers:" -> "Values:" -> "Indices:"[color="#f7f7f7"];

        { rank=same; "Pointers:"; pointers }
        { rank=same; "Values:"; values }
        { rank=same; "Indices:"; indices }   
    }

    label = <<B>图 1.1 顺序表</B>>
}</v7></v6></v5></v4></v3></v2></v1></v0></p7></p6></p5></p4></p3></p2></p1></p0></div></div>




<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种在逻辑空间上连续，但是物理空间上离散的线性表。链表前后节点使用指针相连，因此与线性表相比，链表需要更多的存储空间，但是却能更有效的利用空间，因为顺序表对存储要求必须是物理上一整块的空间。</p>
<div><div class="graphviz">digraph list_linked {

    bgcolor="#f7f7f7"

    rankdir=LR
    subgraph cluster_name {
        n0 [label="{<data>A[0]|<next>}" shape=record,color=blue,fillcolor=lightblue,style=filled]
        n1 [label="{<data>A[1]|<next>}" shape=record,color=blue,fillcolor=lightblue,style=filled]
        n2 [label="{<data>A[2]|<next>}" shape=record,color=blue,fillcolor=lightblue,style=filled]
        n3 [label="{<data>A[3]|<next>}" shape=record,color=blue,fillcolor=lightblue,style=filled]
        n4 [label="{<data>A[4]|<next>nil}" shape=record,color=blue,fillcolor=lightblue,style=filled]

        n0:next:0 -> n1:data [tailclip=false,solid=true]
        n1:next:0 -> n2:data [tailclip=false,solid=true]
        n2:next:0 -> n3:data [tailclip=false,solid=true]
        n3:next:0 -> n4:data [tailclip=false,solid=true]
    }

    label=<<B>图 2.1 链表</B>>
}</next></data></next></data></next></data></next></data></next></data></div></div>



<h2 id="线性表接口"><a href="#线性表接口" class="headerlink" title="线性表接口"></a>线性表接口</h2><p>线性表的基本接口，主要定义常见的几种方法，弹出元素、添加元素、线性表大小、获取线性表第一个元素、获取线性表最后一个元素以及对线性表进行判空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线性表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 弹出元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回线性表大小</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线性表大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 第一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">fist</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回最后一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是空线性表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否是空线性表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AlgorithmException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象实现类"><a href="#抽象实现类" class="headerlink" title="抽象实现类"></a>抽象实现类</h2><p>统一处理异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.queue.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>栈</tag>
        <tag>线性表</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>队列与栈三</title>
    <url>/2021/03/27/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E4%B8%89/</url>
    <content><![CDATA[<p>栈也是一种常见的数据结构，栈的特点就是后进先出。</p>
<a id="more"></a>
<h2 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.statck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.AbstractList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_STACK_SIZE = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ArrayStack&lt;T&gt;(DEFAULT_STACK_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) stack[<span class="keyword">this</span>.size--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.length == <span class="keyword">this</span>.size) &#123;</span><br><span class="line">            resize(<span class="keyword">this</span>.stack, <span class="keyword">this</span>.size + DEFAULT_STACK_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stack[<span class="keyword">this</span>.size++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>.stack[<span class="keyword">this</span>.size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>.stack[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resize stack</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldStack old stack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newSize  new size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(Object[] oldStack, <span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        Object[] newStack = <span class="keyword">new</span> Object[newSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            newStack[i] = oldStack[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stack = newStack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈的链表实现"><a href="#栈的链表实现" class="headerlink" title="栈的链表实现"></a>栈的链表实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.statck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.AbstractList;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.node.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListNode&lt;T&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈底</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListNode&lt;T&gt; end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init stack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">this</span>.head.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.setVal(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode&lt;T&gt; currentNode = <span class="keyword">this</span>.end;</span><br><span class="line">        <span class="keyword">while</span> (currentNode.getNext() != <span class="keyword">this</span>.head) &#123;</span><br><span class="line">            currentNode = currentNode.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        T t = <span class="keyword">this</span>.head.getVal();</span><br><span class="line">        <span class="keyword">this</span>.head = currentNode;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        ListNode&lt;T&gt; newNode = <span class="keyword">new</span> ListNode&lt;T&gt;();</span><br><span class="line">        newNode.setVal(t);</span><br><span class="line">        newNode.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.setNext(newNode);</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.getNext();</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.end.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head == <span class="keyword">this</span>.end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>栈</tag>
        <tag>线性表</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>队列与栈二</title>
    <url>/2021/03/27/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E4%BA%8C/</url>
    <content><![CDATA[<p>队列是一种常见的数据结构，在生活中有很多应用场景，例如排队系统，常见的各种MQ基本上都算队列，队列的一个原则就是先进先出，保证了公平性。</p>
<a id="more"></a>
<h2 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h2><p>队列的数组实现方式如下，数组实现的有点在于每次出队都要进行大量元素的腾挪操作，非常耗时。并且当进行入队操作时，初始分配的队列长度不够的时候，需要申请一块更大的空间来腾挪旧的元素，再插入新元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.AbstractList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_QUEUE_SIZE = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ArrayQueue&lt;T&gt;(DEFAULT_QUEUE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        T t = (T) <span class="keyword">this</span>.queue[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue[i - <span class="number">1</span>] = <span class="keyword">this</span>.queue[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="keyword">this</span>.queue.length) &#123;</span><br><span class="line">            resize(<span class="keyword">this</span>.queue, <span class="keyword">this</span>.size + <span class="keyword">this</span>.DEFAULT_QUEUE_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue[<span class="keyword">this</span>.size++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>.queue[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>.queue[<span class="keyword">this</span>.size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resize array</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldQueue old queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newSize  new size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(Object[] oldQueue, <span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        Object[] newQueue = <span class="keyword">new</span> Object[newSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            newQueue[i] = oldQueue[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue = newQueue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列的链式实现"><a href="#队列的链式实现" class="headerlink" title="队列的链式实现"></a>队列的链式实现</h2><p>队列的链式实现如下，链式队列适合进行频繁的插入删除操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.AbstractList;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.node.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListNode&lt;T&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListNode&lt;T&gt; end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        T t = <span class="keyword">this</span>.head.getVal();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.getNext();</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.end.setVal(t);</span><br><span class="line">        ListNode&lt;T&gt; newEnd = <span class="keyword">new</span> ListNode&lt;T&gt;();</span><br><span class="line">        <span class="keyword">this</span>.end.setNext(newEnd);</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">this</span>.end.getNext();</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">this</span>.head.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.setVal(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span> || <span class="keyword">this</span>.head == <span class="keyword">this</span>.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.end.getVal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>栈</tag>
        <tag>线性表</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象设计五大原则</title>
    <url>/2022/05/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>在程序设计领域， <strong>SOLID</strong>（<strong>单一职责、开闭原则、里氏替换、接口隔离</strong>以及<strong>依赖反转</strong>）是由罗伯特·C·马丁在21世纪早期引入的，指代了面向对象编程和面向对象设计的五个基本原则。</p>
<a id="more"></a>
<h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><p>单一职责原则（Single responsibility principle，简称SRP），规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则（Open closed principle，简称OCP）,规定软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。</p>
<h2 id="里氏替换"><a href="#里氏替换" class="headerlink" title="里氏替换"></a>里氏替换</h2><p>里氏替换原则（Liskov substitution principle，简称LSP），描述的是派生类（子类）对象可以在程序中代替其基类（超类）对象。</p>
<blockquote>
<p>它由芭芭拉·利斯科夫（Barbara Liskov）在1987年在一次会议上名为“数据的抽象与层次”的演说中首先提出，原文为：Let q(x) be a property provable about objects x of type T. Then q(y) should be true for objects y of type S where S is a subtype of T.</p>
</blockquote>
<h2 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h2><p>接口隔离原则（Interface segregation principle， 简称ISP），指的是客户只需要知道他们感兴趣的方法，不应被迫使用对其而言无用的方法或功能。</p>
<h2 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h2><p>依赖反转原则（Dependency inversion principle，简称DIP），高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口，抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识整理（一）</title>
    <url>/2022/10/09/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>最近准备面试资料，针对常见的Java基础知识做出整理与复习。</p>
<a id="more"></a>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p><code>synchronized</code>是<code>java</code>提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为<strong>监视器锁</strong>，使用<code>synchronized</code>之后，会在编译之后在同步的代码块前后加上<code>monitorenter</code>和<code>monitorexit</code>字节码指令，他依赖操作系统底层互斥锁实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。</p>
<p>执行<code>monitorenter</code>指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器<code>+1</code>。此时其他竞争锁的线程则会进入等待队列中。</p>
<p>执行<code>monitorexit</code>指令时则会把计数器<code>-1</code>，当计数器值为<code>0</code>时，则锁释放，处于等待队列中的线程再继续竞争锁。</p>
<p><code>synchronized</code>是排它锁，当一个线程获得锁之后，其他线程必须等待该线程释放锁后才能获得锁，而且由于Java中的线程和操作系统原生线程是一一对应的，线程被阻塞或者唤醒时时会从用户态切换到内核态，这种转换非常消耗性能。</p>
<p>从内存语义来说，加锁的过程会清除工作内存中的共享变量，再从主内存读取，而释放锁的过程则是将工作内存中的共享变量写回主内存。</p>
<h2 id="理解ReentrantLock原理"><a href="#理解ReentrantLock原理" class="headerlink" title="理解ReentrantLock原理"></a>理解ReentrantLock原理</h2><p>相比于<code>synchronized</code>，<code>ReentrantLock</code>需要显式的获取锁和释放锁。</p>
<blockquote>
<ol>
<li>等待可中断，当持有锁的线程长时间不释放锁的时候，等待中的线程可以选择放弃等待，转而处理其他的任务。</li>
<li>公平锁：<code>synchronized</code>和<code>ReentrantLock</code>默认都是非公平锁，但是<code>ReentrantLock</code>可以通过构造函数传参改变。只不过使用公平锁的话会导致性能急剧下降。</li>
<li>绑定多个条件：<code>ReentrantLock</code>可以同时绑定多个<code>Condition</code>条件对象。</li>
</ol>
</blockquote>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>使用<code>volatile</code>声明的变量，可以确保值被更新的时候对其他线程立刻可见。<code>volatile</code>使用内存屏障来保证不会发生指令重排，解决了内存可见性的问题。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal可以理解为线程本地变量，他会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离，相比于synchronized的做法是用空间来换时间。</p>
<h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a>Happens-Before</h2><center>示例一</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">//x的值是多少呢？</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设线程<code>A</code>执行<code>writer()</code>方法，按照<code>volatile</code>会将<code>v=true</code>写入内存；线程<code>B</code>执行<code>reader()</code>方法，按照<code>volatile</code>，线程<code>B</code>会从内存中读取变量<code>v</code>，如果线程<code>B</code>读取到的变量<code>v</code>为<code>true</code>，那么，此时的变量<code>x</code>的值是多少呢？</p>
<p>这个示例程序给人的直觉就是<code>x</code>的值为<code>42</code>，其实，<code>x</code>的值具体是多少和<code>JDK</code>的版本有关，如果使用的<code>JDK</code>版本低于<code>1.5</code>，则x的值可能为<code>42</code>，也可能为<code>0</code>。如果使用<code>1.5</code>及<code>1.5</code>以上版本的<code>JDK</code>，则<code>x</code>的值就是<code>42</code>。</p>
<p>看到这个，就会有人提出问题了？这是为什么呢？其实，答案就是在<code>JDK1.5</code>版本中的<code>Java</code>内存模型中引入了<code>Happens-Before</code>原则。</p>
<center>示例二</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> initX&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123; <span class="comment">//自动加锁</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.x &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.x = <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//自动释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center>示例三</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在线程A中初始化线程B</span></span><br><span class="line">Thread threadB = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//此处的变量x的值是多少呢？答案是100</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线程A在启动线程B之前将共享变量x的值修改为100</span></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//启动线程B</span></span><br><span class="line">threadB.start();</span><br></pre></td></tr></table></figure>
<center>示例四</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread threadB = <span class="keyword">new</span> Thread(()-&#123;</span><br><span class="line">    <span class="comment">//在线程B中，将共享变量x的值修改为100</span></span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//在线程A中启动线程B</span></span><br><span class="line">threadB.start();</span><br><span class="line"><span class="comment">//在线程A中等待线程B执行完成</span></span><br><span class="line">threadB.join();</span><br><span class="line"><span class="comment">//此处访问共享变量x的值为100</span></span><br></pre></td></tr></table></figure>
<center>示例五</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在线程A中将x变量的值初始化为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在线程A中初始化线程B</span></span><br><span class="line">    Thread threadB = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//线程B检测自己是否被中断</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            <span class="comment">//如果线程B被中断，则此时X的值为100</span></span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//在线程A中启动线程B</span></span><br><span class="line">    threadB.start();</span><br><span class="line">    <span class="comment">//在线程A中将共享变量X的值修改为100</span></span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//在线程A中中断线程B</span></span><br><span class="line">    threadB.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center>示例六</center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TestThread();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【原则一】程序次序规则"><a href="#【原则一】程序次序规则" class="headerlink" title="【原则一】程序次序规则"></a>【原则一】程序次序规则</h3><p><strong>在一个线程中，按照代码的顺序，前面的操作<code>Happens-Before</code>于后面的任意操作。</strong></p>
<p>同一个线程中，程序在前面对某个变量的修改一定是对后续操作可见的。例如【示例一】中的程序<code>x=42</code>会在<code>v=true</code>之前执行。</p>
<h3 id="【原则二】volatile变量规则"><a href="#【原则二】volatile变量规则" class="headerlink" title="【原则二】volatile变量规则"></a>【原则二】<code>volatile</code>变量规则</h3><p><strong>对一个<code>volatile</code>变量的写操作，<code>Happens-Before</code>于后续对这个变量的读操作。</strong></p>
<p>对一个使用了<code>volatile</code>变量的写操作，先行发生于后面对这个变量的读操作。</p>
<h3 id="【原则三】传递规则"><a href="#【原则三】传递规则" class="headerlink" title="【原则三】传递规则"></a>【原则三】传递规则</h3><p><strong>如果<code>A Happens-Before B</code>，并且<code>B Happens-Before C</code>，则<code>A Happens-Before C</code>。</strong></p>
<p>合【原则一】、【原则二】和【原则三】再来看【示例一】程序，此时，我们可以得出如下结论：</p>
<p>（1）<code>x = 42 Happens-Before</code> 写变量<code>v = true</code>，符合【原则一】程序次序规则。</p>
<p>（2）写变量<code>v = true Happens-Before</code> 读变量<code>v = true</code>，符合【原则二】<code>volatile</code>变量规则。</p>
<p>再根据【原则三】传递规则，我们可以得出结论：<code>x = 42 Happens-Before</code> 读变量<code>v=true</code>。</p>
<h3 id="【原则四】锁定规则"><a href="#【原则四】锁定规则" class="headerlink" title="【原则四】锁定规则"></a>【原则四】锁定规则</h3><p><strong>对一个锁的解锁操作 <code>Happens-Before</code>于后续对这个锁的加锁操作。</strong></p>
<p>【示例二】，假设变量<code>x</code>的值为<code>10</code>，线程<code>A</code>执行完<code>synchronized</code>代码块之后将x变量的值修改为10，并释放<code>synchronized</code>锁。当线程<code>B</code>进入<code>synchronized</code>代码块时，能够获取到线程<code>A</code>对<code>x</code>变量的写操作，也就是说，线程<code>B</code>访问到的<code>x</code>变量的值为<code>10</code>。</p>
<h3 id="【原则五】线程启动规则"><a href="#【原则五】线程启动规则" class="headerlink" title="【原则五】线程启动规则"></a>【原则五】线程启动规则</h3><p><strong>如果线程A调用线程B的start()方法来启动线程B，则start()操作Happens-Before于线程B中的任意操作。</strong></p>
<p>线程A启动线程B之后，线程B能够看到线程A在启动线程B之前的操作。</p>
<p>【示例三】线程A启动线程B之后，线程B能够看到线程A在启动线程B之前的操作，在线程B中访问到的x变量的值为100。</p>
<h3 id="【原则六】线程终结规则"><a href="#【原则六】线程终结规则" class="headerlink" title="【原则六】线程终结规则"></a>【原则六】线程终结规则</h3><p><strong>线程<code>A</code>等待线程<code>B</code>完成（在线程A中调用线程<code>B</code>的<code>join()</code>方法实现），当线程<code>B</code>完成后（线程<code>A</code>调用线程<code>B</code>的<code>join()</code>方法返回），则线程<code>A</code>能够访问到线程<code>B</code>对共享变量的操作。</strong></p>
<p>参见【示例四】。</p>
<h3 id="【原则七】线程中断规则"><a href="#【原则七】线程中断规则" class="headerlink" title="【原则七】线程中断规则"></a>【原则七】线程中断规则</h3><p><strong>对线程interrupt()方法的调用Happens-Before于被中断线程的代码检测到中断事件的发生。</strong></p>
<p>【示例五】，在线程A中中断线程B之前，将共享变量x的值修改为100，则当线程B检测到中断事件时，访问到的x变量的值为100。</p>
<h3 id="【原则八】对象终结规则"><a href="#【原则八】对象终结规则" class="headerlink" title="【原则八】对象终结规则"></a>【原则八】对象终结规则</h3><p><strong>一个对象的初始化完成Happens-Before于它的finalize()方法的开始。</strong></p>
<p>运行结果如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">构造方法</span><br><span class="line">对象销毁</span><br></pre></td></tr></table></figure>
<h2 id="理解run-start方法"><a href="#理解run-start方法" class="headerlink" title="理解run/start方法"></a>理解<code>run/start</code>方法</h2><h3 id="start方法"><a href="#start方法" class="headerlink" title="start方法"></a><code>start</code>方法</h3><ul>
<li>用来启动线程的方法，属于<code>Thread</code>类。</li>
<li>调用<code>start</code>方法之后，无需等待<code>run</code>方法体代码执行完毕，直接继续执行主线程下面的代码。</li>
<li>调用<code>start</code>方法启动一个线程，此时线程会处于就绪状态，并没有运行，一旦得到<code>cpu</code>时间片，就会开始执行线程的<code>run</code>方法，这里的<code>run</code>方法被称为线程体，它包含了要执行的线程的内容，<code>run</code>方法运行结束，线程随即终止。</li>
</ul>
<h3 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a><code>run</code>方法</h3><ul>
<li><code>run</code>方法是类的一个普通方法。</li>
<li>直接调用<code>run</code>方法，程序依旧在主线程中运行，并不会启动线程。</li>
<li><code>run</code>方法必须是<code>public</code>访问权限，返回值为<code>void</code>的普通方法。</li>
</ul>
<h2 id="理解sleep-wait-notify-notifyall-countdownlatch"><a href="#理解sleep-wait-notify-notifyall-countdownlatch" class="headerlink" title="理解sleep/wait/notify/notifyall/countdownlatch"></a>理解<code>sleep/wait/notify/notifyall/countdownlatch</code></h2><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a><code>sleep</code>方法</h3><ul>
<li><code>sleep</code>方法属于<code>Thread</code>类的静态本地方法，调用方式为<code>Thread.sleep(long millis)</code>。</li>
<li><code>sleep</code>方法用于当前线程休眠，并且时间到了之后，当前线程会继续执行，并且<code>sleep</code>只能自动醒来，不能被唤醒。</li>
<li><code>sleep</code>方法一般用于当前线程的暂停或者休眠。</li>
<li><code>sleep</code>方法不会释放锁。</li>
<li><code>sleep</code>会让出<code>cpu</code>执行时间，强制上下文切换。</li>
</ul>
<h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a><code>wait</code>方法</h3><ul>
<li>wait方法属于Object类的本地方法，调用方式为<code>xxx.wait(long millis)</code>。</li>
<li>wait方法必须在synchronized块中使用（解决lost wake up问题），也即wait应该在同步代码块中使用。</li>
<li>wait一般用于多线程之间的通信。</li>
<li>wait方法会释放锁。</li>
</ul>
<h3 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h3><ul>
<li><p>notify方法属于Object类的本地方法，调用方式为<code>xxx.notify()</code>。</p>
</li>
<li><p>notify方法随机唤醒一个处于wait的线程。</p>
</li>
<li>notify方法并不会立马释放锁，必须等到synchronized方法或者代码块执行完毕之后，才会真正释放锁。</li>
</ul>
<h3 id="notifyall方法"><a href="#notifyall方法" class="headerlink" title="notifyall方法"></a>notifyall方法</h3><ul>
<li>notifyall方法属于Object类的本地方法，调用方式为<code>xxx.notifyall()</code>。</li>
<li>notifyall方法会唤醒所有处于wait的线程，共同竞争锁，只有真正获取到锁对象的线程才能继续执行。</li>
<li>notifyall方法并不会立马释放锁，必须等到synchronized方法或者代码块执行完毕之后，才会真正释放锁。</li>
</ul>
<h3 id="countdownlatch方法"><a href="#countdownlatch方法" class="headerlink" title="countdownlatch方法"></a>countdownlatch方法</h3><ul>
<li>countdownlatch方法用于多线程之间的同步。</li>
<li>主要有两个方法await()与countDown()。</li>
<li>await()方法使调用线程处于等待状态，并且可以有多个线程调用await()方法，多个线程均处于等待状态，以共享模式使用同一把锁。</li>
<li>countDown()方法用于使计数器减一，并且允许同一个线程多次调用该方法。</li>
<li>当计数器减为0时，所有处于等待状态的线程，均被唤醒，继续执行。</li>
</ul>
<h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><ul>
<li>属于Thread类的方法。</li>
<li>join方法主要用于线程同步，可以让线程执行从串行变为并行。</li>
<li>join(10)表示A线程会等待B线程执行10毫秒，join(0)等同于join()表示A线程会等待B线程执行完。</li>
</ul>
<h2 id="理解Java锁机制"><a href="#理解Java锁机制" class="headerlink" title="理解Java锁机制"></a>理解Java锁机制</h2><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p><strong>乐观锁</strong>：乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。<code>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</code></p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p><strong>悲观锁</strong>：对于数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</p>
</li>
<li><p>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p>
</li>
</ul>
<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/pessimistic_locking_and_optimistic_locking.png" alt="悲观锁与乐观锁"></p>
<h3 id="自旋锁与适应性自旋锁"><a href="#自旋锁与适应性自旋锁" class="headerlink" title="自旋锁与适应性自旋锁"></a>自旋锁与适应性自旋锁</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p><strong>自旋锁</strong>：阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成（有可能涉及用户态与内核态的切换），这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/spin_lock.png" alt="自旋锁"></p>
<h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p><strong>自适应自旋锁</strong>：自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<h3 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p>
<p>首先为什么Synchronized能实现线程同步？在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p>
<h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Class Pointer（类型指针）。</p>
<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/java_object_header.jpg" alt="java对象头"></p>
<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p><strong>公平锁</strong>：公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/fair_lock.png" alt="公平锁"></p>
<p><strong>非公平锁</strong>：非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/unfair_lock.png" alt="非公平锁"></p>
<h3 id="可重入锁与不可重入锁"><a href="#可重入锁与不可重入锁" class="headerlink" title="可重入锁与不可重入锁"></a>可重入锁与不可重入锁</h3><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p><strong>可重入锁</strong>：可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>
<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/reentrant_lock.png" alt="可重入锁"></p>
<h4 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h4><p><strong>不可重入锁</strong>：不可重入锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会再次获取锁，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>
<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/unreentrant_lock.png" alt="不可重入锁"></p>
<h3 id="互斥锁与共享锁"><a href="#互斥锁与共享锁" class="headerlink" title="互斥锁与共享锁"></a>互斥锁与共享锁</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p><strong>互斥锁</strong>：是指该锁一次只能被一个线程所持有。如果线程获得临界资源的互斥锁之后，其它线程则不能再对临界资源加锁。获得互斥锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p>
<h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p><strong>共享锁</strong>：共享锁是指该锁可被多个线程所持有。如果线程对临界资源加上共享锁后，则其他线程可以继续对临界资源加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="Java集合的继承关系"><a href="#Java集合的继承关系" class="headerlink" title="Java集合的继承关系"></a>Java集合的继承关系</h3><center>collection继承关系图</center>

<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/collection_1.jpg" alt="集合继承关系图"></p>
<center>map继承关系图</center>

<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/collection_2.jpg" alt="map继承关系图"></p>
<h3 id="Array与Linked"><a href="#Array与Linked" class="headerlink" title="Array与Linked"></a>Array与Linked</h3><p>形式为ArrayXXX与LinkedXXX，例如ArrayList/LinkedList，ArrayBlockingQueue/LinkedBlockingQueue，其中Array开头的为顺序结构，Linked开头的为链式结构。</p>
<h3 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h3><p>随机访问类，继承此类的集合支持随机访问，一般底层结果为数组，也即顺序存储，因此支持随机访问。</p>
<h3 id="Queue与Deque"><a href="#Queue与Deque" class="headerlink" title="Queue与Deque"></a>Queue与Deque</h3><p>队列与双端队列，普通队列，先进先出，队尾入队，对首出队，双端队列，两端均可入队与出队。</p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>阻塞队列，常用于多线程环境，如果入队时队列已满或者出队时队列已空，则会阻塞线程，类似生产者与消费者模型。</p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>延迟队列，继承了BlockingQueue，只有延迟时间到了之后，才能从队列中获取元素，并且DelayQueue没有大小限制，因此生产者不会阻塞，但是消费者会阻塞。</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>无缓冲等待队列，没有容量，是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。</p>
<h3 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h3><p>PriorityXXX，例如PriorityQueue与PriorityBlockingQueue，相对正常的队列，Priority队列的元素会带有优先级，出队时会根据元素优先级决定出队顺序。PriorityQueue底层是使用二叉堆实现的，根据需要可以是小根堆或者大根堆。</p>
<h3 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h3><p>ConcurrentXXX，例如ConcurrentHashMap等，是Java后来引入的并发包中的集合，多用于多线程场景，解决线程安全问题。</p>
<h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><p>CopyOnWriteXXX，例如CopyOnWriteArrayList与CopyOnWriteArraySet等等，主题思想是写入时复制，当有多个调用者同时去请求一个资源时，当其中一个调用者要对资源进行修改，系统会copy一个副本给该调用者，让其进行修改；而其他调用者所拥有资源并不会由于该调用者对资源的改动而发生改变。简单的理解，就是当我们往CopyOnWrite容器中添加元素时，不直接操作当前容器，而是先将容器进行Copy，然后对Copy出的新容器进行修改，修改后，再将原容器的引用指向新的容器，即完成了整个修改操作。</p>
<h3 id="Sorted"><a href="#Sorted" class="headerlink" title="Sorted"></a>Sorted</h3><p>SortedXXX，例如SortedSet与SortedMap等等，这些一般属于排序接口或者抽象类，继承这些对象的集合一般附带顺序。</p>
<h3 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h3><p>在比较Key时，HashMap一般会使用equal比较而IdentityHashMap使用==比较，也即HashMap比较的是值是否相等，而IdentityHashMap比较的是引用是否相等。并且IdentityHashMap解决哈希冲突的方法不同于HashMap的链地址法，而是线性探测法。</p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>与HashMap类似，区别在于使用弱引用关联map中存储的数据，通过该类实现缓存，在内存紧张的情况下，可以避免强引用占用大量内存。</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>内存屏障，也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，它使得CPU 或编译器在对内存进行操作的时候, 严格按照一定的顺序来执行, 也就是说在memory barrier 之前的指令和memory barrier之后的指令不会由于系统优化等原因而导致乱序。<br>大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。<br>语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">美团Java锁博客</a></p>
<p>​    </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo添加algolia搜索</title>
    <url>/2022/10/15/hexo%E6%B7%BB%E5%8A%A0algolia%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p><font color="green"><strong>Hexo</strong></font> 默认本地搜索不够美观，功能单一，而Algolia搜索功能强大。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-algoliasearch --save</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在hexo博客的<code>_config.yml</code>配置文件中添加如下配置，其中appId，appKey，adminApiKey与indexName要根据实际情况填写。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">algolia:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">&quot;Z7A3XW4R2I&quot;</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="string">&quot;12db1ad54372045549ef465881c17e743&quot;</span></span><br><span class="line">  <span class="attr">adminApiKey:</span> <span class="string">&quot;40321c7c207e7f73b63a19aa24c4761b&quot;</span></span><br><span class="line">  <span class="attr">chunkSize:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">indexName:</span> <span class="string">&quot;my-hexo-blog&quot;</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">content:strip:truncate,0,500</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">excerpt:strip</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gallery</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">permalink</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">photos</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">slug</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tags</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">title</span></span><br></pre></td></tr></table></figure>
<p>其中appId, appKey, adminApiKey来源于algolia网站自动生成的配置</p>
<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/algolia_api_key.jpg" alt="algolia_api_key"></p>
<p>indexName是自己创建的index名称</p>
<p><img src="https://lei-my-hexo-blog.oss-cn-beijing.aliyuncs.com/my-hexo-blog/2022/algolia_index_name.jpg" alt="algolia_index_name"></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo algolia</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Algolia</tag>
      </tags>
  </entry>
</search>
