<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/10/25/BubbleSort/</url>
    <content><![CDATA[<p>冒泡排序（英语：Bubble Sort）又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误&gt;就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”&gt;到数列的顶端。</p>
<a id="more"></a>


<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>依次比较两个相邻的元素，如果它们顺序错误，则交换，最终大数会沉向尾部。重复上面的步骤知道数组有序，下面以正序为例进行详细说明整个过程。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[9] [8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>第一步：比较<font color="red">[9]</font>和<font color="red">[8]</font>，由于<font color="red">[9]</font>大于<font color="red">[8]</font>，按照正序逻辑<font color="red">[9]</font>在后面，因此需要交换它们的位置，得到新的数组如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[8] [9] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>第二步：比较比较<font color="red">[9]</font>和<font color="red">[7]</font>，同理需要交换它们的位置，得到新的数组如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[8] [7] [9] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>依次比较原理同上，直到最后一组元素相邻元素比较之后，我们可以得到第一轮冒泡之后的结果，如下所示，可以很明显看到元素<font color="red">[9]</font>最终沉到了尾部，因为它是正序里面最大的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[8] [7] [1] [3] [5] [9]</span><br></pre></td></tr></table></figure>

<p>同理我们进行第二轮冒泡，会将<font color="red">[8]</font>沉到元素尾部，得到如下结果，这里需要注意，由于第一轮冒泡，已经把最大的元素<font color="red">[9]</font>放到了最后一个位置，第二轮冒泡则无需和<font color="red">[9]</font>进行比较，就可以把<font color="red">[8]</font>放到倒数第二的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[7] [1] [3] [5] [8] [9]</span><br></pre></td></tr></table></figure>

<p>最终在经过了n-1轮冒泡之后（n为元素个数），我们可以最终得到一个有序的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9]</span><br></pre></td></tr></table></figure>



<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>冒泡排序是稳定的排序算法，其时间复杂度计算公式如下。可以看到冒泡排序，最好的情况与最坏的情况下，时间复杂度均为2^n，空间复杂度为1，平均时间复杂度为2^n。</p>
</blockquote>
<p>$$<br>(n-1) + (n-2) + (n-3) + … + 1 = ((n-1) + 1) * (n-1) / 2 = \frac{n * (n-1)}{2}<br>$$</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>less函数与exch函数参见文章排序算法序言。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(less(c[j+<span class="number">1</span>], c[j]))&#123;</span><br><span class="line">                exch(c, j, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>冒泡排序</tag>
        <tag>数据结构与算法</tag>
        <tag>稳定排序</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/10/28/HillSort/</url>
    <content><![CDATA[<p>希尔排序（Shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。根据设计者希尔（Donald Shell）的名字命名，该算法由1959年公布。</p>
<a id="more"></a>


<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>假定步长为h，则把数组分为h组，从前往后间隔h的元素为一组。先在组内进行插入排序，保证每个组内是有序的，再按照步长为1进行一次全面插入排序，从而得到有序数组。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9] [8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>第一步，假设h为<code>3</code>，则根据规则原数组分为如下三组</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9] [1]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[8] [3]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [5]</span><br></pre></td></tr></table></figure>

<p>第二步，在三个小组内，分别进行插入排序，得到三个有序子数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [8]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[5] [7]</span><br></pre></td></tr></table></figure>

<p>第三步，三个子数组按照原来的位置存放，得到第一轮排序后的数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [9] [8] [7]</span><br></pre></td></tr></table></figure>

<p>第四步，按照步长为<code>[1]</code>进行一次插入排序，即可得到有序数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9]</span><br></pre></td></tr></table></figure>



<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>希尔排序是一个不稳定的排序算法，其最好情况下时间复杂度为<code>O(n)</code>，最坏情况下时间复杂度为<code>2^n</code>，平均时间复杂度为<code>2^n</code>，空间复杂度为<code>O(!)</code>。时间复杂度计算公式如下。</p>
</blockquote>
<p>$$<br>待补充<br>$$</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Shell</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &lt; N / <span class="number">3</span>)&#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(c[j], c[j-h]); j -= h)&#123;</span><br><span class="line">                exch(c, j, j-h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>希尔排序</tag>
        <tag>不稳定排序</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2020/10/25/InsertSort/</url>
    <content><![CDATA[<p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐&gt;步向后挪位，为最新元素提供插入空间。</p>
<a id="more"></a>

<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>每次从剩余的未排序的元素中选取一个元素插入到前面已排序的元素中，使整体有序。下面以正序为例说明整个过程。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[9] [8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>第一步：选择<font color="red">[9]</font>插入到前面已排序的元素中，由于是第一个元素，已经排序好了。可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9] [8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>未排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[8] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>已排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9]</span><br></pre></td></tr></table></figure>

<p>第二步：选择<font color="red">[8]</font>插入到前面已排序的元素中，<font color="red">[8]</font>比<font color="red">[9]</font>小，因此在<font color="red">[9]</font>前面，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[8] [9] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>未排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>已排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[8] [9]</span><br></pre></td></tr></table></figure>

<p>第三步：选择<font color="red">[7]</font>插入到前面已排序的元素中，<font color="red">[7]</font>比<font color="red">[8]</font>小，因此在<font color="red">[8]</font>前面，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [8] [9] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>未排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>已排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [8] [9]</span><br></pre></td></tr></table></figure>

<p>第四步：选择<font color="red">[1]</font>插入到前面已排序的元素中，<font color="red">[1]</font>比<font color="red">[7]</font>小，因此在<font color="red">[7]</font>前面，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [7] [8] [9] [3] [5]</span><br></pre></td></tr></table></figure>

<p>未排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [5]</span><br></pre></td></tr></table></figure>

<p>已排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [7] [8] [9]</span><br></pre></td></tr></table></figure>

<p>第五步：选择<font color="red">[3]</font>插入到前面已排序的元素中，<font color="red">[3]</font>小于<font color="red">[7]</font>大于<font color="red">[1]</font>，因此<font color="red">[3]</font>在<font color="red">[1]</font>和<font color="red">[7]</font>之间，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [7] [8] [9] [5]</span><br></pre></td></tr></table></figure>

<p>未排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[5]</span><br></pre></td></tr></table></figure>

<p>已排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [7] [8] [9]</span><br></pre></td></tr></table></figure>

<p>第六步：同理插入<font color="red">[5]</font>，可以看到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9]</span><br></pre></td></tr></table></figure>

<p>未排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>已排序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9]</span><br></pre></td></tr></table></figure>

<p>最终得到一个正序数组。</p>
<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>插入排序是稳定的排序算法，其时间复杂度计算公式如下。可以看到插入排序最好的情况时间复杂度为n，最坏的情况下时间复杂度均为2^n，空间复杂度为O(1)，平均时间复杂度为2^n。</p>
</blockquote>
<p>$$<br>k1 + k2 + k3 + k4 + … kn = \sum_{k=1}^{n}{k_n} (1 &lt;= k1,k2,…,kn &lt;= n-1)<br>$$</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(c[j], c[j-<span class="number">1</span>]); j--)&#123;</span><br><span class="line">            exch(c, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>稳定排序</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/10/26/SelectionSort/</url>
    <content><![CDATA[<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<a id="more"></a>


<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>每次在未排序的数组中，找到最大或者最小的元素，放到已排序数组的末尾，依次进行，直到数组全部有序。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[9] [8] [9] [7] [1] [3] [5]</span><br></pre></td></tr></table></figure>

<p>第一步，在原始数组中找到最小元素<font color="red">[1]</font>，起始位置的<font color="red">[9]</font>进行交换，结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [8] [9] [7] [9] [3] [5]</span><br></pre></td></tr></table></figure>

<p>第二步，在剩余未排序数组中找到最小元素<font color="red">[3]</font>与<font color="red">[8]</font>进行交换，结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [9] [7] [9] [8] [5]</span><br></pre></td></tr></table></figure>

<p>第三步，在剩余未排序数组中找到最小元素<font color="red">[5]</font>与索引三处的<font color="red">[9]</font>进行交换，结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [9] [8] [9]</span><br></pre></td></tr></table></figure>

<p>第四步，在剩余未排序数组中找到最小元素<font color="red">[7]</font>，其已经处在正确位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [9] [8] [9]</span><br></pre></td></tr></table></figure>

<p>第五步，在剩余未排序数组中找到最小元素<font color="red">[8]</font>，前面的<font color="red">[9]</font>进行交换，结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9] [9]</span><br></pre></td></tr></table></figure>

<p>第六步，在剩余未排序数组中找到最小元素<font color="red">[9]</font>，其已经处在正确位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9] [9]</span><br></pre></td></tr></table></figure>

<p>排序完毕，数组已经有序。</p>
<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>从第一步就可以明显看出，两个<code>[9]</code>交换了次序，因此插入排序是不稳定的排序算法。其时间复杂度计算公式如下。可以看到选择排序最好的情况下时间复杂度为2^n，最坏的情况下时间复杂度为2^n，空间复杂度为O(1)，平均时间复杂度为2^n。</p>
</blockquote>
<p>$$<br>(n-1) + (n-2) + … + 1 = \frac{n * (n-1)}{2}<br>$$</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>less函数与exch函数参见文章排序算法序言。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(c[j], c[j-<span class="number">1</span>]); j--)&#123;</span><br><span class="line">            exch(c, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>不稳定排序</tag>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/10/26/QuickSort/</url>
    <content><![CDATA[<p>快速排序（英语：Quicksort），又称分区交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。通常明显比其&gt;他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。</p>
<a id="more"></a>


<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote>
<p>是一种分治的思想。它将一个数组分成两个子数组，两部分独立的排序。</p>
</blockquote>
<p>原数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[5] [8] [9] [7] [1] [3] [9]</span><br></pre></td></tr></table></figure>

<p>假定第一个元素<font color="red">[5]</font>为哨兵，标记哨兵为x，使用临时变量<code>temp</code>存放哨兵的值，则原数据如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[x] [8] [9] [7] [1] [3] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [5]</span><br><span class="line">left = 1</span><br><span class="line">right = 6</span><br></pre></td></tr></table></figure>

<p>第一步：，从数组尾部开始扫描，如果当前元素<code>c[right]</code>大于哨兵的值，则索引<code>right</code>减1，继续扫描，如果当前元素<code>c[right]</code>小于哨兵的值，则交换哨兵与当前元素的值。因为<font color="red">[3]</font>小于<font color="red">[9]</font>，因此交换<font color="red">[3]</font>和哨兵<font color="red">[x]</font>，得到如下结果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [8] [9] [7] [1] [x] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [5]</span><br><span class="line">left = 1</span><br><span class="line">right = 5</span><br></pre></td></tr></table></figure>

<p>第二步，从数组头部开始扫描，如果当前元素<code>c[left]</code>小于哨兵的值，则索引<code>left</code>加1，继续扫描，如果当前元素<code>c[left]</code>大于哨兵的值，则交换哨兵与当前元素的值。因为<font color="red">[8]</font>大于<font color="red">[5]</font>，因此交换<font color="red">[8]</font>和哨兵<font color="red">[x]</font>，得到如下结果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [x] [9] [7] [1] [8] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [9]</span><br><span class="line">left = 1</span><br><span class="line">right = 5</span><br></pre></td></tr></table></figure>

<p>第三步，继续从<code>right-1</code>处继续扫描，重复步骤一，得到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [1] [9] [7] [x] [8] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [9]</span><br><span class="line">left = 1</span><br><span class="line">right = 4</span><br></pre></td></tr></table></figure>

<p>第四步，继续从<code>left+1</code>处继续扫描，重复步骤二，得到结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [1] [x] [7] [9] [8] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [9]</span><br><span class="line">left = 2</span><br><span class="line">right = 4</span><br></pre></td></tr></table></figure>

<p>一直重复上面的步骤直到，<code>left</code>大于等于<code>right</code>结束扫描，最后把临时变量temp的值存入<font color="red">[x]</font>处，第一轮快速排序结束。可以得到第一轮结果如下，可以很明显看到小于<font color="red">[5]</font>的值全在左边，大于<font color="red">[5]</font>的值全在右边。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [1] [5] [7] [9] [8] [9]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">temp = [9]</span><br><span class="line">left = 2</span><br><span class="line">right = 2</span><br></pre></td></tr></table></figure>


<p>第二轮，把第一轮的结果看成如下两个数组，对每个数组，重复第一轮的排序方法，直到左右数组均有序。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[3] [1]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[7] [9] [8] [9]</span><br></pre></td></tr></table></figure>

<p>最终可以得到有序数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1] [3] [5] [7] [8] [9] [9]</span><br></pre></td></tr></table></figure>



<h2 id="时间与空间复杂度"><a href="#时间与空间复杂度" class="headerlink" title="时间与空间复杂度"></a>时间与空间复杂度</h2><blockquote>
<p>快速排序是不稳定的排序算法，其时间复杂度计算公式如下，可以看到快速排序最好情况下时间复杂度为<code>O(nlogn)</code>，最坏情况下时间复杂度为<code>2^n</code>，平均时间复杂度为<code>O(nlogn)</code>。</p>
</blockquote>
<p>$$<br>待补充<br>$$</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>less函数与exch函数参见文章排序算法序言。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(Comparable[] c)</span></span>&#123;</span><br><span class="line">    sort(c, <span class="number">0</span>, c.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= start) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = partition(c, start, end);</span><br><span class="line">    sort(c, start, j - <span class="number">1</span>);</span><br><span class="line">    sort(c, j+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = start, j = end + <span class="number">1</span>;</span><br><span class="line">    Comparable v = c[start];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (less(c[++i], v))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == end)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (less(v, c[--j]))&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == start)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(c, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(c, start, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>不稳定排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法引言</title>
    <url>/2020/10/25/SortIntroduction/</url>
    <content><![CDATA[<p>排序算法是最常见的算法之一，常见的排序算法有<code>冒泡排序</code>、<code>插入排序</code>、<code>选择排序</code>、<code>希尔排序</code>、<code>归并排序</code>、<code>堆排序</code>、<code>快速排序</code>。其目的是为了实现&gt;对数组中元素的排序。通常排序分为正序和倒序。</p>
<a id="more"></a>


<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><blockquote>
<ul>
<li>最好、最坏、平均时间复杂度</li>
<li><code>时间复杂度</code>计算公式</li>
<li>比较次数和交换次数</li>
</ul>
</blockquote>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><blockquote>
<ul>
<li><code>空间复杂度</code>，衡量空间上的内存消耗</li>
<li><code>原地排序</code>，代指空间复杂度为O(1)的排序</li>
</ul>
</blockquote>
<h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><blockquote>
<ul>
<li><code>稳定</code>的算法在排序的过程中不会改变元素彼此的位置的相对次序,反之<code>不稳定</code>的排序算法经常会改变这个次序。以某两个相等元素<code>c[i]</code>和<code>c[j]</code>为例，假如在原始待排序数组中<code>c[i] == c[j]</code>，并且<code>c[i]</code>位置在<code>c[j]</code>之前。那么如果整个排序过程中，<code>c[i]</code>均在<code>c[j]</code>之前，则说明排序算法是稳定的，反之则是不稳定的。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3][4][9] .... [i] ... [j] ...</span><br></pre></td></tr></table></figure>



<h2 id="公共函数"><a href="#公共函数" class="headerlink" title="公共函数"></a>公共函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*比较两个元素大小*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*交换两个元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Comparable t = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>排序算法</tag>
        <tag>稳定与不稳定</tag>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo样式个性化配置</title>
    <url>/2021/03/31/hexo-preference/</url>
    <content><![CDATA[<p>hexo博客搭建好之后，如何调整样式对于没有前端基础的人来说是一件很困难的事情，下面分享我样式调整过程中的一些经验，由于我使用的是Next主题，所以如果是其它的主题的仅做参考，有可能细节之处不太一样。</p>
<a id="more"></a>



<h2 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blog home dir</span></span><br><span class="line">BLOG_HOME=/Users/lei/workspace/MyBlog</span><br></pre></td></tr></table></figure>



<h2 id="解锁样式定制配置"><a href="#解锁样式定制配置" class="headerlink" title="解锁样式定制配置"></a>解锁样式定制配置</h2><p>（1）打开next主题配置文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$&#123;BLOG_HOME&#125;</span>/themes/next/_config.yml</span><br></pre></td></tr></table></figure>



<p>（2）搜索<code>custom_file_path</code>可以看到如下配置，把反注释掉<code>style: source/_data/styles.styl</code>配置，记住去掉<code>#</code>号即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>



<p>（3）注意上面的<code>source/_data</code>目录指的是博客<code>home</code>目录下的<code>source/_data</code>目录，首先创建<code>_data</code>目录，然后创建<code>styles.style</code>文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create _data directory</span></span><br><span class="line">mkdir -p <span class="variable">$&#123;BLOG_HOME&#125;</span>/<span class="built_in">source</span>/_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># create _data file</span></span><br><span class="line">touch <span class="variable">$&#123;BLOG_HOME&#125;</span>/<span class="built_in">source</span>/_data/styles.styl</span><br></pre></td></tr></table></figure>



<h2 id="自定义样式配置"><a href="#自定义样式配置" class="headerlink" title="自定义样式配置"></a>自定义样式配置</h2><p>下面直接晒出我的配置，自己可以打开<code>Chrome</code>浏览器的检查功能，慢慢对照样式进行调整，其实主要是为了<code>PC</code>端与移动端的适配，保证<code>PC</code>端简洁大方，移动端不至于空白太多。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//背景图片配置</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    background:url(/images/background.jpeg);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed;</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文章部分配置</span></span><br><span class="line"><span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1px</span> <span class="number">3%</span> <span class="number">1px</span> <span class="number">3%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">80%</span>;</span><br><span class="line">    +mobile() &#123;</span><br><span class="line">   	<span class="attribute">padding</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动端自适应</span></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">   +mobile() &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">1%</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动端自适应</span></span><br><span class="line"><span class="selector-class">.use-motion</span> .post-block&#123;</span><br><span class="line">   +mobile() &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动端自适应</span></span><br><span class="line"><span class="selector-class">.comments</span> &#123;</span><br><span class="line">   +mobile() &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">      <span class="attribute">overflow</span>: hidden;   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动端自适应</span></span><br><span class="line"><span class="selector-class">.gt-container</span> <span class="selector-class">.gt-meta</span> &#123;</span><br><span class="line">   +mobile() &#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">1.25em</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内容最上面留白配置</span></span><br><span class="line">.<span class="attribute">content</span>&#123;</span><br><span class="line">   <span class="attribute">padding-top</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超链接配置</span></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">   <span class="attribute">color</span>: <span class="number">#0645AD</span>;</span><br><span class="line">   <span class="attribute">border-bottom</span>: none;</span><br><span class="line">   <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0645AD</span>;</span><br><span class="line">   &amp;:hover &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#0B0080</span>;</span><br><span class="line">      <span class="attribute">border-bottom</span>: none;</span><br><span class="line">      <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0B0080</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//graphviz图片自适应</span></span><br><span class="line"><span class="selector-class">.post-body</span> svg &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多级目录自动展开</span></span><br><span class="line"><span class="selector-class">.post-toc</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo简单使用</title>
    <url>/2021/03/18/hexo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><font color=green><strong>Hexo</strong></font> 是一个简单，美观，使用起来方便，支持各种二次定制的博客框架。并且支持丰富的<font color=green><strong>Markdown</strong></font>插件，是程序员不可多得的博客框架。</p>
<a id="more"></a>


<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>基本<font color=green><strong>Hexo</strong></font>使用命令介绍。</p>
<h3 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo new <span class="string">&#x27;title&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>创建完博客之后，会自动在<font color=blue> <strong>source/_posts</strong>/</font>目录下面创建一个同名的md结尾的<font color=green><strong>Markdown</strong></font>文件，此时只需要使用markdown编辑器打开md文件撰写博客即可，例如Typora或者Atomic等等。</p>
<h3 id="本地预览博客"><a href="#本地预览博客" class="headerlink" title="本地预览博客"></a>本地预览博客</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo s</span></span><br></pre></td></tr></table></figure>

<p>撰写完博客之后，在正式发布到博客网站之后，可以先使用<font color=green><strong>server</strong></font>命令本地启动博客服务器，预览博客效果，在确认没有问题之后再发布到正式网站上面。</p>
<h3 id="正式发布博客"><a href="#正式发布博客" class="headerlink" title="正式发布博客"></a>正式发布博客</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo clean &amp;&amp; hexo g -d</span></span><br></pre></td></tr></table></figure>

<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://theme-next.iissnan.com/theme-settings.html" title="Next Theme主题配置">Next Theme</a>     - next theme主题官方配置教程</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-105 从前序与中序遍历序列构造二叉树</title>
    <url>/2021/08/02/leetcode-105/</url>
    <content><![CDATA[<p>题目描述：给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, inorder, <span class="number">0</span>, inorder.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> rootIdx, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 单个节点直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (start == end - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[start]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 前序第一个节点为二叉树根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[rootIdx]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 寻找根节点在中序序列中的索引值</span></span><br><span class="line">        <span class="keyword">int</span> rootIdxInOrder = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt; end; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[idx] == root.val) &#123;</span><br><span class="line">                rootIdxInOrder = idx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 中序序列中根节点左部分节点构成左子树</span></span><br><span class="line">        TreeNode leftNode = buildTree(preorder, rootIdx + <span class="number">1</span>, inorder, start, rootIdxInOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 中序序列中根节点右部分节点构成右子树</span></span><br><span class="line">        TreeNode rightNode = buildTree(preorder, rootIdx + <span class="number">1</span> + rootIdxInOrder - start, inorder, rootIdxInOrder + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 连接左右子树</span></span><br><span class="line">        root.left = leftNode;</span><br><span class="line">        root.right = rightNode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>前序、中序</tag>
        <tag>难度中等</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka命令</title>
    <url>/2021/03/27/kafka%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>kafka是一款优秀且常见的MQ，具有安装方便，使用方便，应用场景广泛等一系列优点，个人认为是最好用的MQ之一。</p>
<a id="more"></a>

<h2 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kafka version</span></span><br><span class="line">version=kafka_2.12-1.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka topic</span></span><br><span class="line">topic=ChristmasEvent</span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka bootstrap server</span></span><br><span class="line">Kafka_server=19.94.08.13:19092</span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka zookeeper server</span></span><br><span class="line">zk_server=19.14.08.13:21810</span><br><span class="line"></span><br><span class="line"><span class="comment"># kafka consumer group</span></span><br><span class="line">consumer_group=bless-server</span><br></pre></td></tr></table></figure>



<h2 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建Topic</h2><p>创建kafka topic，其中replication-factor代表副本数，partitions代表分区数。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-topics.sh --create --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --replication-factor 1 --partitions 1 --topic <span class="variable">$&#123;topic&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="查看Topic内容（当前开始）"><a href="#查看Topic内容（当前开始）" class="headerlink" title="查看Topic内容（当前开始）"></a>查看Topic内容（当前开始）</h2><p>从当前时刻开始，用于实时查看kafka的消息。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-console-consumer.sh --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span> --topic <span class="variable">$&#123;topic&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="查看Topic内容（从头开始）"><a href="#查看Topic内容（从头开始）" class="headerlink" title="查看Topic内容（从头开始）"></a>查看Topic内容（从头开始）</h2><p>从头开始，用于实时查看kafka消息，仅限开发调测环境使用，当kafka消息过多时可能会导致异常问题。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-console-consumer.sh --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span> --topic <span class="variable">$&#123;topic&#125;</span> --from-beginning</span><br></pre></td></tr></table></figure>



<h2 id="查看消费组（旧版本）"><a href="#查看消费组（旧版本）" class="headerlink" title="查看消费组（旧版本）"></a>查看消费组（旧版本）</h2><p>查看消费者组情况，适用于用于旧版本kafka客户端。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --list --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="查看消费组（新版本）"><a href="#查看消费组（新版本）" class="headerlink" title="查看消费组（新版本）"></a>查看消费组（新版本）</h2><p>查看消费者组情况，适用于用于新版本kafka客户端。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --new-consumer --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span> --list</span><br></pre></td></tr></table></figure>



<h2 id="查看消费组（使用ZK连接而非Java-Api）"><a href="#查看消费组（使用ZK连接而非Java-Api）" class="headerlink" title="查看消费组（使用ZK连接而非Java Api）"></a>查看消费组（使用ZK连接而非Java Api）</h2><p>查看消费者组情况，仅限于使用zk连接的消费者。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --list</span><br></pre></td></tr></table></figure>



<h2 id="查看单个消费组详情（Java-Api）"><a href="#查看单个消费组详情（Java-Api）" class="headerlink" title="查看单个消费组详情（Java Api）"></a>查看单个消费组详情（Java Api）</h2><p>查看单个消费者组情况，使用Java Api连接的消费者。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --new-consumer --bootstrap-server <span class="variable">$&#123;kafka_server&#125;</span> --group <span class="variable">$&#123;consumer_group&#125;</span> --describe</span><br></pre></td></tr></table></figure>



<h2 id="查看单个消费组详情（ZK）"><a href="#查看单个消费组详情（ZK）" class="headerlink" title="查看单个消费组详情（ZK）"></a>查看单个消费组详情（ZK）</h2><p>查看单个消费者组情况，使用zk连接的消费者。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-consumer-groups.sh --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --group <span class="variable">$&#123;consumer_group&#125;</span> --describe</span><br></pre></td></tr></table></figure>



<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>直接在命令行发布一条消息，可以用于开发环境调测，重放消息等。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-console-producer.sh --broker-list <span class="variable">$&#123;kafka_server&#125;</span> --topic <span class="variable">$&#123;topic&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="查看Topic列表"><a href="#查看Topic列表" class="headerlink" title="查看Topic列表"></a>查看Topic列表</h2><p>查看kafka当前Topic列表。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-topics.sh --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --list</span><br></pre></td></tr></table></figure>



<h2 id="查看单个Topic详情"><a href="#查看单个Topic详情" class="headerlink" title="查看单个Topic详情"></a>查看单个Topic详情</h2><p>查看单个Topic详情。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/bin/kafka-topics.sh --zookeeper <span class="variable">$&#123;zk_server&#125;</span> --topic <span class="variable">$&#123;topic&#125;</span> --describe</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-106 从中序与后续遍历序列构造二叉树</title>
    <url>/2021/08/03/leetcode-106/</url>
    <content><![CDATA[<p>题目描述：根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder, <span class="number">0</span>, inorder.length, postorder, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> rootIdx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 单个节点直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (start == end - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[start]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 后续最后一个节点为二叉树根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[rootIdx]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 寻找根节点在中序序列中的索引值</span></span><br><span class="line">        <span class="keyword">int</span> rootIdxInOrder = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt; end; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[idx] == root.val) &#123;</span><br><span class="line">                rootIdxInOrder = idx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 中序序列中根节点左部分节点构成左子树</span></span><br><span class="line">        TreeNode leftNode = buildTree(inorder, start, rootIdxInOrder, postorder, rootIdx - (end - rootIdxInOrder));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 中序序列中根节点右部分节点构成右子树</span></span><br><span class="line">        TreeNode rightNode = buildTree(inorder, rootIdxInOrder + <span class="number">1</span>, end, postorder, rootIdx - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 连接左右子树</span></span><br><span class="line">        root.left = leftNode;</span><br><span class="line">        root.right = rightNode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>难度中等</tag>
        <tag>中序、后序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-114 二叉树展开为链表</title>
    <url>/2021/07/30/leetcode-114/</url>
    <content><![CDATA[<p>题目描述：给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</li>
<li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        convertTree2List(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertTree2List</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 转换左子树</span></span><br><span class="line">        TreeNode leftHeadNode = convertTree2List(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 转换右子树</span></span><br><span class="line">        TreeNode rightHeadNode = convertTree2List(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 找到左子树的叶子节点</span></span><br><span class="line">        TreeNode leftTailNode = leftHeadNode;</span><br><span class="line">        <span class="keyword">while</span> (leftTailNode != <span class="keyword">null</span> &amp;&amp; leftTailNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            leftTailNode = leftTailNode.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 拼接左右子树与根节点</span></span><br><span class="line">        <span class="keyword">if</span> (leftTailNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.right = rightHeadNode;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.right = leftHeadNode;</span><br><span class="line">            leftTailNode.right = rightHeadNode;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>难度中等</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-116 填充每个节点的下一个右侧节点指针</title>
    <url>/2021/07/31/leetcode-116/</url>
    <content><![CDATA[<p>题目描述：给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">  	Node left;</span><br><span class="line">  	Node right;</span><br><span class="line">  	Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理左子树</span></span><br><span class="line">        Node leftNode = connect(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 处理右子树</span></span><br><span class="line">        Node rightNode = connect(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 处理根节点</span></span><br><span class="line">        <span class="keyword">while</span> (leftNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            leftNode.next = rightNode;</span><br><span class="line">            leftNode = leftNode.right;</span><br><span class="line">            rightNode = rightNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>难度中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1373 二叉搜索子树的最大键值和</title>
    <url>/2021/08/09/leetcode-1373/</url>
    <content><![CDATA[<p>题目描述：给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。</p>
<p>二叉搜索树的定义如下：</p>
<ul>
<li>任意节点的左子树中的键值都 小于 此节点的键值。</li>
<li>任意节点的右子树中的键值都 大于 此节点的键值。</li>
<li>任意节点的左子树和右子树都是二叉搜索树。</li>
<li>每棵树有 <code>1</code> 到 <code>40000</code> 个节点。</li>
<li>每个节点的键值在 <code>[-4 * 10^4 , 4 * 10^4]</code> 之间。</li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        postBST(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * int[] 是否是二叉搜索树，左子树最小值，右子树最大值，如果是二叉搜索树则求和</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] postBST(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] left = postBST(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = postBST(root.right);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>]) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = Math.min(root.val, left[<span class="number">1</span>]);</span><br><span class="line">            res[<span class="number">2</span>] = Math.max(root.val, right[<span class="number">2</span>]);</span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">            maxSum = Math.max(res[<span class="number">3</span>], maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉搜索树</tag>
        <tag>难度困难</tag>
        <tag>子树</tag>
        <tag>最大键值和</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-226 翻转二叉树</title>
    <url>/2021/07/29/leetcode-226/</url>
    <content><![CDATA[<p>题目描述：翻转一棵二叉树。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = invertTree(root.left);</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = node;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>反转</tag>
        <tag>难度简单</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-230 二叉搜索树中第K小的元素</title>
    <url>/2021/08/05/leetcode-230/</url>
    <content><![CDATA[<p>题目描述：给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="中序实现"><a href="#中序实现" class="headerlink" title="中序实现"></a>中序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inorders(root);</span><br><span class="line">        <span class="keyword">return</span> nodes.get(k).val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorders</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.left);</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        inorders(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idxVal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inorders(root, k);</span><br><span class="line">        <span class="keyword">return</span> idxVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorders</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.left, k);</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="keyword">if</span> (idx == k) &#123;</span><br><span class="line">            idxVal = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度中等</tag>
        <tag>二叉搜索树</tag>
        <tag>第K小元素</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-234 回文链表</title>
    <url>/2021/07/28/leetcode-234/</url>
    <content><![CDATA[<p>题目描述：请判断一个链表是否为回文链表。你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 遍历计算链表长度</span></span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 寻找中间节点</span></span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">int</span> subLen = len / <span class="number">2</span> + len % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (subLen-- != <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 反转右半链表区间剩余节点</span></span><br><span class="line">        ListNode subHead2 = reverse(node);</span><br><span class="line">        ListNode subHead1 = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 分别对比左链表区间元素与右链表区间元素</span></span><br><span class="line">        <span class="keyword">while</span> (subHead1 != <span class="keyword">null</span> &amp;&amp; subHead2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (subHead1.val != subHead2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            subHead1 = subHead1.next;</span><br><span class="line">            subHead2 = subHead2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表反转</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 链表头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回反转后的链表头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
        <tag>难度简单</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-25 K个一组翻转链表</title>
    <url>/2021/07/27/leetcode-25/</url>
    <content><![CDATA[<p>题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。你可以设计一个只使用常数额外空间的算法来解决此问题吗？你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<a id="more"></a>



<h2 id="原题介绍"><a href="#原题介绍" class="headerlink" title="原题介绍"></a>原题介绍</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><div><div class="graphviz">digraph leetcode_92_1 {
    
    bgcolor="#f7f7f7"

<pre><code>rankdir=LR
subgraph cluster_name &#123;
    
    subgraph cluster_1 &#123;
        n0 [label=&quot;1&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        n1 [label=&quot;2&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        n2 [label=&quot;3&quot; shape=circle,color=yellow,fillcolor=lightyellow,style=filled]
        n3 [label=&quot;4&quot; shape=circle,color=yellow,fillcolor=lightyellow,style=filled]
        n4 [label=&quot;5&quot; shape=circle,color=black,fillcolor=white,style=filled]
        rank=same;
        n0 -&gt; n1 -&gt; n2 -&gt; n3 -&gt; n4 
        style=invis
    &#125;

    subgraph cluster_2 &#123;
        r0 [label=&quot;2&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        r1 [label=&quot;1&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        r2 [label=&quot;4&quot; shape=circle,color=yellow,fillcolor=lightyellow,style=filled]
        r3 [label=&quot;3&quot; shape=circle,color=yellow,fillcolor=lightyellow,style=filled]
        r4 [label=&quot;5&quot; shape=circle,color=black,fillcolor=white,style=filled]

        rank=same;
        r0 -&gt; r1 -&gt; r2 -&gt; r3 -&gt; r4 
        style=invis
    &#125;    

    n2 -&gt; r2[constraint=false,color=&quot;red&quot;,pad=30]    

&#125;

label=&lt;&lt;B&gt;图 1.1 示例一&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入：head</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]<span class="string">,</span> <span class="string">k</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">输出：[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure>



<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode nextNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 遍历计算链表长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 每组k各元素，计算分组数</span></span><br><span class="line">        <span class="keyword">int</span> group = len / k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 分别处理每个组，分别进行反转</span></span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt;= group; idx++) &#123;</span><br><span class="line">            newHead = reverseBetween(head, k * (idx - <span class="number">1</span>) + <span class="number">1</span>, k * idx);</span><br><span class="line">            head = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转链表区间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 链表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 区间左</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 区间右</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新链表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || right == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            head.next = reverseBetween(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverse(head, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转链表前right个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head  链表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 前right个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新链表头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || right == <span class="number">1</span>) &#123;</span><br><span class="line">            nextNode = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverse(head.next, right - <span class="number">1</span>);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = nextNode;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
        <tag>难度困难</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-450 删除二叉搜索树中的节点</title>
    <url>/2021/08/10/leetcode-450/</url>
    <content><![CDATA[<p>题目描述：给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：</p>
<ul>
<li><p>首先找到需要删除的节点；</p>
</li>
<li><p>如果找到了，删除它。</p>
</li>
</ul>
<p>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode minNode = getMinNode(root.right);</span><br><span class="line">            root.val = minNode.val;</span><br><span class="line">            root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">getMinNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度中等</tag>
        <tag>二叉搜索树</tag>
        <tag>删除节点</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-538 把二叉搜索树转换为累加树</title>
    <url>/2021/08/06/leetcode-538/</url>
    <content><![CDATA[<p>题目描述：给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 小于 节点键的节点。</li>
<li>节点的右子树仅包含键 大于 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="后序实现"><a href="#后序实现" class="headerlink" title="后序实现"></a>后序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inorders(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">            nodes.get(i).val = nodes.get(i - <span class="number">1</span>).val + nodes.get(i).val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorders</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.right);</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        inorders(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inorders(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorders</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorders(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        inorders(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度中等</tag>
        <tag>二叉搜索时树</tag>
        <tag>累加树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-652 寻找重复的子树</title>
    <url>/2021/08/04/leetcode-652/</url>
    <content><![CDATA[<p>题目描述：给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p>
<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Integer&gt; subTrees = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; duplicate = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        findDuplicateSubtrees(root);</span><br><span class="line">        <span class="keyword">return</span> duplicate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">postorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String left = postorder(root.left);</span><br><span class="line">        String right = postorder(root.right);</span><br><span class="line">        String subTree = left + <span class="string">&quot;,&quot;</span> + right + <span class="string">&quot;,&quot;</span> + root.val;</span><br><span class="line">        <span class="keyword">int</span> frequency = subTrees.getOrDefault(subTree, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (frequency == <span class="number">1</span>) &#123;</span><br><span class="line">            duplicate.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        subTrees.put(subTree, frequency + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> subTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>难度中等</tag>
        <tag>重复子树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-654 最大二叉树</title>
    <url>/2021/08/01/leetcode-654/</url>
    <content><![CDATA[<p>题目描述：给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：</p>
<ul>
<li>二叉树的根是数组 nums 中的最大元素。</li>
<li>左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。</li>
<li>右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。</li>
</ul>
<p>返回有给定数组 nums 构建的 最大二叉树 。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> constructMaximumBinaryTree(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 单个元素直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (start == end - <span class="number">1</span>) &#123;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(nums[start]);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 寻找最大元素</span></span><br><span class="line">        <span class="keyword">int</span> maxVal = nums[start];</span><br><span class="line">        <span class="keyword">int</span> maxIdx = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt; end; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] &gt; maxVal) &#123;</span><br><span class="line">                maxVal = nums[idx];</span><br><span class="line">                maxIdx = idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 最大元素为根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(maxVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 最大元素左边为左子树</span></span><br><span class="line">        TreeNode leftNode = constructMaximumBinaryTree(nums, start, maxIdx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 最大元素右边为右子树</span></span><br><span class="line">        TreeNode rightNode = constructMaximumBinaryTree(nums, maxIdx + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 连接左右子树</span></span><br><span class="line">        root.left = leftNode;</span><br><span class="line">        root.right = rightNode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>难度中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-700 二叉搜索树中的搜索</title>
    <url>/2021/08/12/leetcode-700/</url>
    <content><![CDATA[<p>题目描述：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>提示：</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode searchNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        search(root, val);</span><br><span class="line">        <span class="keyword">return</span> searchNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">            searchNode = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            search(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            search(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉搜索树</tag>
        <tag>难度简单</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-701 二叉搜索树中的插入操作</title>
    <url>/2021/08/11/leetcode-701/</url>
    <content><![CDATA[<p>题目描述：给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<p>提示：</p>
<ul>
<li>给定的树上的节点数介于 0 和 10^4 之间</li>
<li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li>
<li>-10^8 &lt;= val &lt;= 10^8</li>
<li>新值和原始二叉搜索树中的任意节点值都不同</li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度中等</tag>
        <tag>二叉搜索树</tag>
        <tag>插入</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 92 反转链表 II</title>
    <url>/2021/03/28/leetcode-92/</url>
    <content><![CDATA[<p>题目描述：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<a id="more"></a>



<h2 id="原题介绍"><a href="#原题介绍" class="headerlink" title="原题介绍"></a>原题介绍</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><div><div class="graphviz">digraph leetcode_92_1 {
    
    bgcolor="#f7f7f7"

<pre><code>rankdir=LR
subgraph cluster_name &#123;
    
    subgraph cluster_1 &#123;
        n0 [label=&quot;1&quot; shape=circle,color=blue,fillcolor=white,style=filled]
        n1 [label=&quot;2&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        n2 [label=&quot;3&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        n3 [label=&quot;4&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        n4 [label=&quot;5&quot; shape=circle,color=blue,fillcolor=white,style=filled]
        rank=same;
        n0 -&gt; n1 -&gt; n2 -&gt; n3 -&gt; n4 
        style=invis
    &#125;

    subgraph cluster_2 &#123;
        r0 [label=&quot;1&quot; shape=circle,color=blue,fillcolor=white,style=filled]
        r1 [label=&quot;4&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        r2 [label=&quot;3&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        r3 [label=&quot;2&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled]
        r4 [label=&quot;5&quot; shape=circle,color=blue,fillcolor=white,style=filled]

        rank=same;
        r0 -&gt; r1 -&gt; r2 -&gt; r3 -&gt; r4 
        style=invis
    &#125;    

    n2 -&gt; r2[constraint=false,color=&quot;red&quot;,pad=30]    

&#125;

label=&lt;&lt;B&gt;图 1.1 算法示意图&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入：head</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]<span class="string">,</span> <span class="string">left</span> <span class="string">=</span> <span class="number">2</span><span class="string">,</span> <span class="string">right</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line"><span class="string">输出：[1,4,3,2,5]</span></span><br></pre></td></tr></table></figure>



<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">输入：head</span> <span class="string">=</span> [<span class="number">5</span>]<span class="string">,</span> <span class="string">left</span> <span class="string">=</span> <span class="number">1</span><span class="string">,</span> <span class="string">right</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="string">输出：[5]</span></span><br></pre></td></tr></table></figure>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="遍历拆分链表"><a href="#遍历拆分链表" class="headerlink" title="遍历拆分链表"></a>遍历拆分链表</h3><p>如下图所示，通过遍历以 <code>[left，right]</code>作为分界，把链表分为三个字表。</p>
<div><div class="graphviz">digraph leetcode_92_1 {
    
    bgcolor="#f7f7f7"

<pre><code>rankdir=LR
subgraph cluster_name &#123;
    subgraph cluster_1 &#123;
        n0 [label=&quot;1&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n1 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n2 [label=&quot;left-1&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n3 [label=&quot;left&quot; shape=circle,color=red,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n4 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n5 [label=&quot;right&quot; shape=circle,color=red,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n6 [label=&quot;right+1&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n7 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n8 [label=&quot;n&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        rank=same;
        n0 -&gt; n1 -&gt; n2
        n2 -&gt; n3[style=dashed,color=red]
        n3 -&gt; n4 -&gt; n5
        n5 -&gt; n6[style=dashed,color=red]
        n6 -&gt; n7 -&gt; n8
        style=invis
    &#125;

&#125;
label=&lt;&lt;B&gt;图 2.1 遍历拆分链表&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<h3 id="分别处理三个子表"><a href="#分别处理三个子表" class="headerlink" title="分别处理三个子表"></a>分别处理三个子表</h3><blockquote>
<ul>
<li>记录左边链表的head与end，记录右边链表的head。</li>
<li>遍历中间链表存入到栈当中，然后依次弹出栈中节点并链接为一个新的链表，根据栈后进先出的特性，新链表必定顺序是反过来的。</li>
<li>然后再依次按照左中右顺序拼接合并三个链表，得到最终结果。</li>
</ul>
</blockquote>
<div><div class="graphviz">digraph leetcode_92_1 {
    
    bgcolor="#f7f7f7"

<pre><code>rankdir=LR
subgraph cluster_name &#123;
    subgraph cluster_1 &#123;
        n0 [label=&quot;1&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n1 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n2 [label=&quot;left-1&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n3 [label=&quot;right&quot; shape=circle,color=red,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n4 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n5 [label=&quot;left&quot; shape=circle,color=red,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n6 [label=&quot;right+1&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n7 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n8 [label=&quot;n&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        rank=same;
        n0 -&gt; n1 -&gt; n2
        n2 -&gt; n3[style=dashed,color=red]
        n3 -&gt; n4 -&gt; n5
        n5 -&gt; n6[style=dashed,color=red]
        n6 -&gt; n7 -&gt; n8
        style=invis
    &#125;

&#125;
label=&lt;&lt;B&gt;图 2.2 最终结果&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 如果链表为空或者是单节点链表直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 初始化节点栈</span></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 初始化左链表的end节点</span></span><br><span class="line">        ListNode leftLinkedListEnd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 初始化右链表的start节点</span></span><br><span class="line">        ListNode rightLinkedListStart = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 定义链表索引，并初始化为1</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 循环遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (ListNode it = head; it != <span class="keyword">null</span>; it = it.next,idx++)&#123;</span><br><span class="line">            <span class="comment">//6.1 如果是处于[left,right]之间的节点，则存入栈中</span></span><br><span class="line">            <span class="keyword">if</span> ( idx &gt;= left &amp;&amp; idx &lt;= right)&#123;</span><br><span class="line">                stack.push(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6.2 如果是处于[1,left)之间的节点，则记录其end节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (idx &lt; left)&#123;</span><br><span class="line">                leftLinkedListEnd = it;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6.3 如果是处于(right,n]之间的节点，则记录其start节点，并跳出循环结束遍历</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rightLinkedListStart = it;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 依次弹出栈中元素反转中间链表</span></span><br><span class="line">        ListNode midLinkedListHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode midLinkedListEnd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (midLinkedListHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">                midLinkedListHead = stack.pop();</span><br><span class="line">                midLinkedListEnd = midLinkedListHead;</span><br><span class="line">                midLinkedListEnd.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                midLinkedListEnd.next = stack.pop();</span><br><span class="line">                midLinkedListEnd = midLinkedListEnd.next;</span><br><span class="line">                midLinkedListEnd.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8. 合并左链表</span></span><br><span class="line">        <span class="keyword">if</span> (leftLinkedListEnd != <span class="keyword">null</span>)&#123;</span><br><span class="line">            leftLinkedListEnd.next = midLinkedListHead;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            head = midLinkedListHead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9. 合并右链表</span></span><br><span class="line">        <span class="keyword">if</span> (rightLinkedListStart != <span class="keyword">null</span>)&#123;</span><br><span class="line">            midLinkedListEnd.next = rightLinkedListStart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//10. 返回最终链表head节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 临时节点</span></span><br><span class="line">    <span class="keyword">private</span> ListNode node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2. 判空处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 递归处理</span></span><br><span class="line">        <span class="keyword">return</span> reverse(head, left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reverse 前n个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n    前n个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. n==1表示一个元素直接返回，并记录后区节点</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.node = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 递归得到head.next后面的反转</span></span><br><span class="line">        ListNode end = reverse(head.next, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 反转 head 和 end</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 新的尾节点指向保存的后驱节点</span></span><br><span class="line">        head.next = <span class="keyword">this</span>.node;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reverse 中间n个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head  表头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 有边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 如果left == 1 递归反转前n个元素</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> reverse(head, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 递归找到待反转起始位置</span></span><br><span class="line">        head.next = reverse(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" title="原题地址">原题地址</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度中等</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-95 不同的二叉搜索树 II</title>
    <url>/2021/08/08/leetcode-95/</url>
    <content><![CDATA[<p>题目描述：给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; root = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (end &gt; start) &#123;</span><br><span class="line">            root.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt;= end; idx++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftTree = generateTrees(start, idx - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightTree = generateTrees(idx + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span> (TreeNode leftNode : leftTree) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode rightNode : rightTree) &#123;</span><br><span class="line">                    TreeNode rootNode = <span class="keyword">new</span> TreeNode(idx);</span><br><span class="line">                    rootNode.left = leftNode;</span><br><span class="line">                    rootNode.right = rightNode;</span><br><span class="line">                    root.add(rootNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度中等</tag>
        <tag>二叉树搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-96 不同的二叉搜索树</title>
    <url>/2021/08/07/leetcode-96/</url>
    <content><![CDATA[<p>题目描述：给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt;= start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = start; idx &lt;= end; idx++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftTreeStart = start;</span><br><span class="line">            <span class="keyword">int</span> leftTreeEnd = idx - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightTreeStart = idx + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightTreeEnd = end;</span><br><span class="line">            <span class="keyword">int</span> leftNum = (leftTreeEnd - leftTreeStart &lt; <span class="number">1</span>) ? <span class="number">1</span> : numTrees(leftTreeStart, leftTreeEnd);</span><br><span class="line">            <span class="keyword">int</span> rightNum = (rightTreeEnd - rightTreeStart &lt; <span class="number">1</span>) ? <span class="number">1</span> : numTrees(rightTreeStart, rightTreeEnd);</span><br><span class="line">            sum += leftNum * rightNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度中等</tag>
        <tag>二叉树搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-98 验证二叉搜索树</title>
    <url>/2021/08/13/leetcode-98/</url>
    <content><![CDATA[<p>题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度中等</tag>
        <tag>二叉树搜索树</tag>
        <tag>验证</tag>
      </tags>
  </entry>
  <entry>
    <title>反转单链表的前n个元素</title>
    <url>/2021/04/01/reverse-linked-list-top-n/</url>
    <content><![CDATA[<p>反转单链表的前n个元素与反转单链表是类似的问题，同理其也会有三种方法去解决。可以增加一个栈来解决，这样相当于只对前n个元素进行压栈处理，同理也可以用遍历的方法解决，由于能用栈解决同样也就可以使用递归的方式解决。</p>
<a id="more"></a>

<h2 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h2><h2 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h2><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>难度中等</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/03/30/reverse-linked-list/</url>
    <content><![CDATA[<p>单链表的反转，我们能想到反转顺序最简单的数据结构就是栈了，如果可以用栈的话，那问题就简单了。顺序遍历单链表，依次入栈直到遍历结束，然后依次出栈重新有前到后连接为一个新的单链表，则自动实现了反转功能。</p>
<a id="more"></a>

<h2 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 遍历链表入栈</span></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 出栈重新建立链表</span></span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode newEnd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (newHead == <span class="keyword">null</span>)&#123;</span><br><span class="line">                newHead = node;</span><br><span class="line">                newEnd = newHead;</span><br><span class="line">                newHead.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                newEnd.next = node;</span><br><span class="line">                newEnd = newEnd.next;</span><br><span class="line">                newEnd.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h2><h3 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h3><div><div class="graphviz">digraph leetcode_92_1 {
    
    bgcolor="#f7f7f7"

<pre><code>rankdir=LR
subgraph cluster_name &#123;
    subgraph cluster_1 &#123;
        n0 [label=&quot;newEnd&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n1 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n2 [label=&quot;newHead&quot; shape=circle,color=blue,fillcolor=white,style=filled,width=0.8,fixedsize=true]
        n3 [label=&quot;node&quot; shape=circle,color=red,style=dashed,width=0.8,fixedsize=true]
        n4 [label=&quot;oldHead&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n5 [label=&quot;...&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        n6 [label=&quot;oldEnd&quot; shape=circle,color=blue,fillcolor=lightblue,style=filled,width=0.8,fixedsize=true]
        
        rank=same;
        n0 -&gt; n1 -&gt; n2[dir=back]
        n2 -&gt; n3[style=dashed,color=&quot;#f7f7f7&quot;]
        n3 -&gt; n4[style=dashed,color=red]
        n4 -&gt; n5 -&gt; n6
        style=invis
    &#125;

&#125;
label=&lt;&lt;B&gt;图 1.1 遍历反转链表&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 设置反转后新链表表头节点</span></span><br><span class="line">        ListNode newLinkedListHead = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 设置反转前旧链表表头节点</span></span><br><span class="line">        ListNode oldLinkedListHead = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 设置临时节点</span></span><br><span class="line">        ListNode tmpNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 遍历旧链表</span></span><br><span class="line">        <span class="keyword">while</span> (oldLinkedListHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//5.1 取出当前节点到临时节点</span></span><br><span class="line">            tmpNode = oldLinkedListHead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.2 重新设置旧链表表头</span></span><br><span class="line">            oldLinkedListHead = oldLinkedListHead.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.3 把取出的临时节点添加到反转后新链表的表头</span></span><br><span class="line">            <span class="keyword">if</span> (newLinkedListHead == <span class="keyword">null</span>)&#123;</span><br><span class="line">                newLinkedListHead = tmpNode;</span><br><span class="line">                newLinkedListHead.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                tmpNode.next = newLinkedListHead;</span><br><span class="line">                newLinkedListHead = tmpNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6. 返回反转后新链表</span></span><br><span class="line">        <span class="keyword">return</span> newLinkedListHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p>递归实现的原理和栈是类似的，因为递归本身就是利用了程序栈进行了压栈处理，因此好好理解一下第一种算法与第三种算法，有助于理解递归的原理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取递归得到的新表头</span></span><br><span class="line">        ListNode newHead = reverse(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 处理当前节点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 处理完之后新的尾节点置空</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 返回新的表头节点</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>难度中等</tag>
        <tag>单链表</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>旅途的起点</title>
    <url>/2020/10/24/%E6%97%85%E9%80%94%E7%9A%84%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<p>今天刚把博客网站初步搭建好，从学生时代，到现在工作两年，一直以来都想好好写博客，写一些生活的感悟，以及技术上的文章。</p>
<a id="more"></a>


<h2 id="写博客背景"><a href="#写博客背景" class="headerlink" title="写博客背景"></a>写博客背景</h2><p>之前有在csdn上写博客的经历，但那是大学时候的事情了，后来也没有坚持下来。在快毕业的时候，同学买了一个博客视频，教你如何一步一步搭建自己的博客网站，那时候感觉搭建自己的网站挺新鲜的，然后尝试了之后，依然是半途而废。毕业之后，从事互联网工作，在国内某盛名996厂，不过有些名不符实，996没有，995到时不少。平时时间并不宽裕，因此也没有太多时间写博客。可能有人要问了，那为什么在工作两年之后，突然想到开始写博客了呢？原因之一是因为这一直以来是我自己非常想做的一件事情吧。事实证明，自己想了很久而没做的事情，即使过了很久，但是只要契机到了，你依然回去做。那么我这次开始写博客的契机又是什么呢？因为工作快二年半了，工作部门最近似乎也有些变动，有些不安吧。希望能在这大半年的时间里，好好整理一下所学习的知识，为可能的改变做准备吧。</p>
<h2 id="写博客的目的"><a href="#写博客的目的" class="headerlink" title="写博客的目的"></a>写博客的目的</h2><p>写博客主要为了记录生活的点滴，人生感悟以及作为一个技术宅的所学吧，算是对自己人生的一个整理吧。古有三十而立，想想我也是一个快而立之年的人了，总归要好好思考未来的人生道路该怎么走。平时工作忙的时候倒没觉得，但是一旦放假闲下来的时候，时常想一些奇奇怪怪的事情。人生想想还挺短暂的，也许未来还有四十年可活，也只有1万多天，如果每天能写一篇博客的话，余生还能写一万多篇博客。这未尝不是一件有趣的事情。人生嘛，说短不过几十载，说长嘛，还挺长的，总归要做一些有趣的事情，为单调重复的生活增添一些味道。博客能够帮助我们记录平凡的点滴，以及多彩的瞬间。此时正是英雄联盟S10之际，青春慢慢远去，我们的人生不能像英雄联盟一样可以随时重启，引用英雄联盟中的一句台词，我想对自己说，没有撤退可言。</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法序言</title>
    <url>/2021/03/21/%E7%AE%97%E6%B3%95%E5%BA%8F%E8%A8%80/</url>
    <content><![CDATA[<p>有一种观点认为，程序等于数据结构加算法，但是懂得了数据结构与算法并不一定能写出好的程序。本文主要介绍后面文章会用到的一些基本数据结构。</p>
<a id="more"></a>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>后面统一使用如下异常类，处理抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgorithmException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlgorithmException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlgorithmException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误码定义类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorCode4Algorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ErrorCode4Algorithm</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 越界异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INDEX_OUT_OF_RANGE = <span class="string">&quot;INDEX_OUT_OF_RANGE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未重写异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NOT_IMPLEMENT_EXCEPTION = <span class="string">&quot;NOT_IMPLEMENT_EXCEPTION&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="一维节点定义"><a href="#一维节点定义" class="headerlink" title="一维节点定义"></a>一维节点定义</h2><p>所有一维单链表统一如下节点进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.SuperBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向下一个节点的指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>序言</tag>
      </tags>
  </entry>
  <entry>
    <title>队列与栈一</title>
    <url>/2021/03/22/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E4%B8%80/</url>
    <content><![CDATA[<p>线性表是最基本的数据结构之一，其最终的物理结构不外乎两种，顺序表与链表。队列与栈都是线性表，只是其外在的逻辑表现形式不同而已。</p>
<a id="more"></a>

<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>顺序表是一种在物理上连续存储的结构，也即顺序表的元素在内存空间里是物理上连续的。</p>
<div><div class="graphviz">digraph array_list{

<pre><code>bgcolor=&quot;#f7f7f7&quot;

subgraph cluster_array &#123;


    node [shape=record, fontcolor=black,width=4.75, fixedsize=true];
    pointers[] [label=&quot;&lt;p0&gt; A+0 | &lt;p1&gt; A+1 | &lt;p2&gt; A+2 | &lt;p3&gt; A+3 | &lt;p4&gt; A+4 | &lt;p5&gt; A+5 | &lt;p6&gt; A+6 | &lt;p7&gt; A+7&quot;, color=blue];
    values [label=&quot;&lt;v0&gt; A[0] | &lt;v1&gt; A[1] | &lt;v2&gt; A[2] | &lt;v3&gt; A[3] | &lt;v4&gt; A[4] | &lt;v5&gt; A[5] | &lt;v6&gt; A[6] | &lt;v7&gt; A[7]&quot;, color=blue, fillcolor=lightblue, style=filled];
    indices [label=&quot;0 | 1 | 2 | 3| 4 | 5 | 6 | 7&quot;, color=&quot;#f7f7f7&quot;];

    node [shape=plaintext, fontcolor=&quot;black&quot;,width=1 fontsize=18,fixedsize=true];
    &quot;Pointers:&quot; -&gt; &quot;Values:&quot; -&gt; &quot;Indices:&quot;[color=&quot;#f7f7f7&quot;];

    &#123; rank=same; &quot;Pointers:&quot;; pointers &#125;
    &#123; rank=same; &quot;Values:&quot;; values &#125;
    &#123; rank=same; &quot;Indices:&quot;; indices &#125;   
&#125;

label = &lt;&lt;B&gt;图 1.1 顺序表&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种在逻辑空间上连续，但是物理空间上离散的线性表。链表前后节点使用指针相连，因此与线性表相比，链表需要更多的存储空间，但是却能更有效的利用空间，因为顺序表对存储要求必须是物理上一整块的空间。</p>
<div><div class="graphviz">digraph list_linked {
    
    bgcolor="#f7f7f7"

<pre><code>rankdir=LR
subgraph cluster_name &#123;
    n0 [label=&quot;&#123;&lt;data&gt;A[0]|&lt;next&gt;&#125;&quot; shape=record,color=blue,fillcolor=lightblue,style=filled]
    n1 [label=&quot;&#123;&lt;data&gt;A[1]|&lt;next&gt;&#125;&quot; shape=record,color=blue,fillcolor=lightblue,style=filled]
    n2 [label=&quot;&#123;&lt;data&gt;A[2]|&lt;next&gt;&#125;&quot; shape=record,color=blue,fillcolor=lightblue,style=filled]
    n3 [label=&quot;&#123;&lt;data&gt;A[3]|&lt;next&gt;&#125;&quot; shape=record,color=blue,fillcolor=lightblue,style=filled]
    n4 [label=&quot;&#123;&lt;data&gt;A[4]|&lt;next&gt;nil&#125;&quot; shape=record,color=blue,fillcolor=lightblue,style=filled]
 
    n0:next:0 -&gt; n1:data [tailclip=false,solid=true]
    n1:next:0 -&gt; n2:data [tailclip=false,solid=true]
    n2:next:0 -&gt; n3:data [tailclip=false,solid=true]
    n3:next:0 -&gt; n4:data [tailclip=false,solid=true]
&#125;

label=&lt;&lt;B&gt;图 2.1 链表&lt;/B&gt;&gt;
</code></pre>
<p>}</div></div></p>
<h2 id="线性表接口"><a href="#线性表接口" class="headerlink" title="线性表接口"></a>线性表接口</h2><p>线性表的基本接口，主要定义常见的几种方法，弹出元素、添加元素、线性表大小、获取线性表第一个元素、获取线性表最后一个元素以及对线性表进行判空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线性表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 弹出元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回线性表大小</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线性表大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 第一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">fist</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回最后一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是空线性表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否是空线性表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AlgorithmException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="抽象实现类"><a href="#抽象实现类" class="headerlink" title="抽象实现类"></a>抽象实现类</h2><p>统一处理异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.queue.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.NOT_IMPLEMENT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>线性表</tag>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>队列与栈三</title>
    <url>/2021/03/27/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E4%B8%89/</url>
    <content><![CDATA[<p>栈也是一种常见的数据结构，栈的特点就是后进先出。</p>
<a id="more"></a>

<h2 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.statck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.AbstractList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_STACK_SIZE = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ArrayStack&lt;T&gt;(DEFAULT_STACK_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) stack[<span class="keyword">this</span>.size--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.length == <span class="keyword">this</span>.size) &#123;</span><br><span class="line">            resize(<span class="keyword">this</span>.stack, <span class="keyword">this</span>.size + DEFAULT_STACK_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stack[<span class="keyword">this</span>.size++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>.stack[<span class="keyword">this</span>.size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>.stack[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resize stack</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldStack old stack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newSize  new size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(Object[] oldStack, <span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        Object[] newStack = <span class="keyword">new</span> Object[newSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            newStack[i] = oldStack[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stack = newStack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="栈的链表实现"><a href="#栈的链表实现" class="headerlink" title="栈的链表实现"></a>栈的链表实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.statck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.AbstractList;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.node.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListNode&lt;T&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈底</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListNode&lt;T&gt; end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init stack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">this</span>.head.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.setVal(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode&lt;T&gt; currentNode = <span class="keyword">this</span>.end;</span><br><span class="line">        <span class="keyword">while</span> (currentNode.getNext() != <span class="keyword">this</span>.head) &#123;</span><br><span class="line">            currentNode = currentNode.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        T t = <span class="keyword">this</span>.head.getVal();</span><br><span class="line">        <span class="keyword">this</span>.head = currentNode;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        ListNode&lt;T&gt; newNode = <span class="keyword">new</span> ListNode&lt;T&gt;();</span><br><span class="line">        newNode.setVal(t);</span><br><span class="line">        newNode.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.setNext(newNode);</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.getNext();</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.end.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> AlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head == <span class="keyword">this</span>.end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>线性表</tag>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>队列与栈二</title>
    <url>/2021/03/27/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E4%BA%8C/</url>
    <content><![CDATA[<p>队列是一种常见的数据结构，在生活中有很多应用场景，例如排队系统，常见的各种MQ基本上都算队列，队列的一个原则就是先进先出，保证了公平性。</p>
<a id="more"></a>



<h2 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h2><p>队列的数组实现方式如下，数组实现的有点在于每次出队都要进行大量元素的腾挪操作，非常耗时。并且当进行入队操作时，初始分配的队列长度不够的时候，需要申请一块更大的空间来腾挪旧的元素，再插入新元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.AbstractList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_QUEUE_SIZE = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ArrayQueue&lt;T&gt;(DEFAULT_QUEUE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        T t = (T) <span class="keyword">this</span>.queue[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue[i - <span class="number">1</span>] = <span class="keyword">this</span>.queue[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="keyword">this</span>.queue.length) &#123;</span><br><span class="line">            resize(<span class="keyword">this</span>.queue, <span class="keyword">this</span>.size + <span class="keyword">this</span>.DEFAULT_QUEUE_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue[<span class="keyword">this</span>.size++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>.queue[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">this</span>.queue[<span class="keyword">this</span>.size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resize array</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldQueue old queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newSize  new size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(Object[] oldQueue, <span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        Object[] newQueue = <span class="keyword">new</span> Object[newSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            newQueue[i] = oldQueue[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue = newQueue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="队列的链式实现"><a href="#队列的链式实现" class="headerlink" title="队列的链式实现"></a>队列的链式实现</h2><p>队列的链式实现如下，链式队列适合进行频繁的插入删除操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lei.payment.java.base.algorithm.list.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.AlgorithmException;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.exception.ErrorCode4Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.list.AbstractList;</span><br><span class="line"><span class="keyword">import</span> com.lei.payment.java.base.algorithm.node.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListNode&lt;T&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListNode&lt;T&gt; end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        T t = <span class="keyword">this</span>.head.getVal();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.getNext();</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.end.setVal(t);</span><br><span class="line">        ListNode&lt;T&gt; newEnd = <span class="keyword">new</span> ListNode&lt;T&gt;();</span><br><span class="line">        <span class="keyword">this</span>.end.setNext(newEnd);</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">this</span>.end.getNext();</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">this</span>.head.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.setVal(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span> || <span class="keyword">this</span>.head == <span class="keyword">this</span>.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlgorithmException(ErrorCode4Algorithm.INDEX_OUT_OF_RANGE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.end.getVal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
        <tag>线性表</tag>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-797 所有可能的路径</title>
    <url>/2021/08/14/leetcode-797/</url>
    <content><![CDATA[<p>题目描述：给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。提示：</p>
<ul>
<li>n == graph.length</li>
<li>2 &lt;= n &lt;= 15</li>
<li>0 &lt;= graph[i][j] &lt; n</li>
<li>graph[i][j] != i </li>
<li>保证输入为有向无环图 (GAD)</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; allPaths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        path.add(<span class="number">0</span>);</span><br><span class="line">        allPathsSourceTarget(graph, <span class="number">0</span>, graph.length - <span class="number">1</span>, path);</span><br><span class="line">        <span class="keyword">return</span> allPaths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allPathsSourceTarget</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> k, <span class="keyword">int</span> n, List&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; currentPath = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">        <span class="keyword">if</span> (k == n) &#123;</span><br><span class="line">            allPaths.add(currentPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : graph[k])&#123;</span><br><span class="line">            currentPath.add(i);</span><br><span class="line">            allPathsSourceTarget(graph, i, n, currentPath);</span><br><span class="line">            currentPath.remove(currentPath.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>难度中等</tag>
        <tag>有向无环图</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-297 二叉树的序列化与反序列化</title>
    <url>/2021/08/15/leetcode-297/</url>
    <content><![CDATA[<p>题目描述：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 104]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="前序实现"><a href="#前序实现" class="headerlink" title="前序实现"></a>前序实现</h3><ol>
<li>```java<br>class Codec {<pre><code>/**
 * 空节点
 */
private final static String NULL_NODE = &quot;#&quot;;

/**
 * 分隔符
 */
private final static String SEPARATOR = &quot;,&quot;;

/**
 * 前序序列化
 *
 * @param root TreeNode
 * @return String
 */
public String serialize(TreeNode root) &#123;
    if (root == null) &#123;
        return NULL_NODE;
    &#125;
    return String.valueOf(root.val) + SEPARATOR + serialize(root.left) + SEPARATOR + serialize(root.right);
&#125;

/**
 * 反序列化二叉树
 *
 * @param data String
 * @return 二叉树根节点
 */
public TreeNode deserialize(String data) &#123;
    //1. 分离二叉树节点
    String[] allNodeVal = data.split(SEPARATOR);

    //2. 尾插法二叉树节点
    LinkedList&lt;String&gt; nodes = new LinkedList&lt;&gt;();
    for (String nodeVal : allNodeVal) &#123;
        nodes.addLast(nodeVal);
    &#125;

    //3. 递归处理二叉树节点
    return deserialize(nodes);
&#125;

/**
 * 递归反序列化二叉树
 *
 * @param nodes LinkedList&lt;String&gt;
 * @return TreeNode
 */
public TreeNode deserialize(LinkedList&lt;String&gt; nodes) &#123;
    //1. 判空
    if (nodes.isEmpty()) &#123;
        return null;
    &#125;

    //2. 处理非空节点
    String firstVal = nodes.removeFirst();
    if (NULL_NODE.equals(firstVal)) &#123;
        return null;
    &#125;
    TreeNode node = new TreeNode(Integer.parseInt(firstVal));

    //3. 递归处理左子树
    node.left = deserialize(nodes);

    //4. 递归处理右子树
    node.right = deserialize(nodes);
    return node;
&#125;
</code></pre>
}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 后序实现</span><br><span class="line"></span><br><span class="line">1. &#96;&#96;&#96;java</span><br><span class="line">   class Codec &#123;</span><br><span class="line">       &#x2F;**</span><br><span class="line">        * 空节点</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private final static String NULL_NODE &#x3D; &quot;#&quot;;</span><br><span class="line">   </span><br><span class="line">       &#x2F;**</span><br><span class="line">        * 分隔符</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private final static String SEPARATOR &#x3D; &quot;,&quot;;</span><br><span class="line">   </span><br><span class="line">       &#x2F;**</span><br><span class="line">        * 后序序列化</span><br><span class="line">        *</span><br><span class="line">        * @param root TreeNode</span><br><span class="line">        * @return String</span><br><span class="line">        *&#x2F;</span><br><span class="line">       public String serialize(TreeNode root) &#123;</span><br><span class="line">           if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">               return NULL_NODE;</span><br><span class="line">           &#125;</span><br><span class="line">           return serialize(root.left) + SEPARATOR + serialize(root.right) + SEPARATOR + String.valueOf(root.val);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       &#x2F;**</span><br><span class="line">        * 反序列化二叉树</span><br><span class="line">        *</span><br><span class="line">        * @param data String</span><br><span class="line">        * @return 二叉树根节点</span><br><span class="line">        *&#x2F;</span><br><span class="line">       public TreeNode deserialize(String data) &#123;</span><br><span class="line">           &#x2F;&#x2F;1. 分离二叉树节点</span><br><span class="line">           String[] nodes &#x3D; data.split(SEPARATOR);</span><br><span class="line">   </span><br><span class="line">           &#x2F;&#x2F;2. 头插法二叉树节点</span><br><span class="line">           LinkedList&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">           for (String node : nodes) &#123;</span><br><span class="line">               list.addFirst(node);</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           &#x2F;&#x2F;3. 递归处理二叉树节点</span><br><span class="line">           return deserialize(list);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       &#x2F;**</span><br><span class="line">        * 递归反序列化二叉树</span><br><span class="line">        *</span><br><span class="line">        * @param nodes LinkedList&lt;String&gt;</span><br><span class="line">        * @return TreeNode</span><br><span class="line">        *&#x2F;</span><br><span class="line">       public TreeNode deserialize(LinkedList&lt;String&gt; nodes) &#123;</span><br><span class="line">           &#x2F;&#x2F;1. 判空</span><br><span class="line">           if (nodes.isEmpty()) &#123;</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           &#x2F;&#x2F;2. 处理非空节点</span><br><span class="line">           String firstVal &#x3D; nodes.removeFirst();</span><br><span class="line">           if (NULL_NODE.equals(firstVal)) &#123;</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           TreeNode root &#x3D; new TreeNode(Integer.parseInt(firstVal));</span><br><span class="line">   </span><br><span class="line">           &#x2F;&#x2F;3. 递归处理右子树</span><br><span class="line">           root.right &#x3D; deserialize(nodes);</span><br><span class="line">   </span><br><span class="line">           &#x2F;&#x2F;4. 递归处理左子树</span><br><span class="line">           root.left &#x3D; deserialize(nodes);</span><br><span class="line">           return root;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="中序实现"><a href="#中序实现" class="headerlink" title="中序实现"></a>中序实现</h3><p>中序只能序列化，无法反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NULL_NODE = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SEPARATOR = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NULL_NODE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serialize(root.left) + SEPARATOR + String.valueOf(root.val) + SEPARATOR + serialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="层序实现"><a href="#层序实现" class="headerlink" title="层序实现"></a>层序实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NULL_NODE = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SEPARATOR = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 层序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 序列化字符串</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 层序遍历</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = list.removeFirst();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(NULL_NODE).append(SEPARATOR);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(node.val).append(SEPARATOR);</span><br><span class="line">            list.addLast(node.left);</span><br><span class="line">            list.addLast(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 排除最后一个多余的分隔符</span></span><br><span class="line">        <span class="keyword">return</span> sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 判空</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理根节点</span></span><br><span class="line">        String[] nodes = data.split(SEPARATOR);</span><br><span class="line">        LinkedList&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 层序遍历</span></span><br><span class="line">        list.addLast(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodes.length; ) &#123;</span><br><span class="line">            TreeNode parent = list.removeFirst();</span><br><span class="line">            <span class="comment">//3.1 处理左节点</span></span><br><span class="line">            String left = nodes[i++];</span><br><span class="line">            <span class="keyword">if</span> (NULL_NODE.equals(left)) &#123;</span><br><span class="line">                parent.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(left));</span><br><span class="line">                list.addLast(parent.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.2 处理右节点</span></span><br><span class="line">            String right = nodes[i++];</span><br><span class="line">            <span class="keyword">if</span> (NULL_NODE.equals(right)) &#123;</span><br><span class="line">                parent.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(right));</span><br><span class="line">                list.addLast(parent.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>难度中等</tag>
        <tag>序列化与反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-341 扁平化嵌套列表迭代器</title>
    <url>/2021/08/16/leetcode-341/</url>
    <content><![CDATA[<p>题目描述：给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。</p>
<p>实现扁平迭代器类 NestedIterator ：</p>
<ol>
<li>NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器。</li>
</ol>
<ul>
<li><p>int next() 返回嵌套列表的下一个整数。</p>
</li>
<li><p>boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。<br>你的代码将会用下述伪代码检测：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">initialize iterator with nestedList</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> iterator.hasNext()</span><br><span class="line">    append iterator.next() to the end of res</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Integer&gt; it;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 扁平化展开嵌套列表</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger nit : nestedList) &#123;</span><br><span class="line">            traverse(nit, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理展开后的列表</span></span><br><span class="line">        <span class="keyword">this</span>.it = list.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.it.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.it.hasNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归展开列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nit  NestedInteger</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list List&lt;Integer&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(NestedInteger nit, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nit.isInteger()) &#123;</span><br><span class="line">            list.add(nit.getInteger());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger childNit : nit.getList()) &#123;</span><br><span class="line">            traverse(childNit, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="惰性实现"><a href="#惰性实现" class="headerlink" title="惰性实现"></a>惰性实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;NestedInteger&gt; it;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.it = <span class="keyword">new</span> LinkedList&lt;&gt;(nestedList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.it.remove(<span class="number">0</span>).getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断下一个原始是否是Integer</span></span><br><span class="line"><span class="comment">     * 如果是Integer则直接返回</span></span><br><span class="line"><span class="comment">     * 如果不是则使用头插法展开</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.it.isEmpty() &amp;&amp; !<span class="keyword">this</span>.it.get(<span class="number">0</span>).isInteger()) &#123;</span><br><span class="line">            List&lt;NestedInteger&gt; nit = <span class="keyword">this</span>.it.remove(<span class="number">0</span>).getList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nit.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">this</span>.it.addFirst(nit.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.it.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>oj</tag>
        <tag>二叉树</tag>
        <tag>难度中等</tag>
        <tag>扁平化迭代器</tag>
      </tags>
  </entry>
</search>
